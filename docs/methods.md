# Methods

BaderKit is based on the [Henkelman group's](https://theory.cm.utexas.edu/henkelman/code/bader/) excellent Fortran code.
In addition to the algorithms available in their code, we have created several
variations. This page provides descriptions and recommendations for when to use
each method.

## Summary

| Method        | Speed   | Accuracy | Single Basin Assignments |
|---------------|---------|----------|--------------------------|
|ongrid         |Very Fast|Low       |:material-check:          |
|neargrid       |Medium   |High      |:material-check:          |
|weight         |Fast     |Very High |:material-close:          |
|pseudo-neargrid|Fast     |High      |:material-check:          |

---

## Descriptions

=== "ongrid"
    
    **Key Takeaways:** Extremely fast, but prone to orientation errors
    
    This is the original algorithm proposed by Henkelman et. al. It is extremely
    fast, but prone to error. For example, it gives slightly different oxidation 
    states for different orientations of a molecule or material.
    
    For each point on the grid, the gradient is calculated for the 26 nearest 
    neighbors, and the neighbor with the steepest gradient is selected as the 
    next point in the path. This path is followed until a maximum is reached or
    a previous point in the path is hit. In the former case, all of the points in the path
    are assigned to the maximum, and in the latter they are assigned to the same
    maximum as the colliding path.
    
    **Reference**
    
    G. Henkelman, A. Arnaldsson, and H. JÃ³nsson, A fast and robust algorithm for Bader decomposition of charge density, [Comput. Mater. Sci. 36, 354-360 (2006)](https://theory.cm.utexas.edu/henkelman/code/bader/download/henkelman06_354.pdf)
    
=== "neargrid (default)"

    **Key Takeaways:** Accurate while providing only one assignment per grid point.
    Requires edge refinement.
    
    This algorithm was developed by Henkelman et. al. after the ongrid method
    to fix orientation errors. It is less accurate than the weight method, but 
    useful where it is desirable to have only one basin assignment per point on the grid.
    
    A gradient vector is calculated at each point using the three nearest neighbors. 
    A step is made to the neighboring point closest to this gradient vector. A
    correction vector pointing from the new point to the original gradient is
    calculated to preserve information about the true gradient.
    
    At each step, this correction vector is compounded. If any component of the 
    correction vector is ever closer to a neighboring point than the current one, 
    a correction is made to keep the path closer to the true gradient.
    
    After all of the points are assigned, a refinement must be made to the 
    points on the edge, as the accumulation of the gradient is technically only
    correct for the first point in the path.
    
    **Reference**
    
    W. Tang, E. Sanville, and G. Henkelman, A grid-based Bader analysis algorithm without lattice bias, [J. Phys.: Condens. Matter 21, 084204 (2009)](https://theory.cm.utexas.edu/henkelman/code/bader/download/tang09_084204.pdf)
    

=== "weight"
    
    **Key Takeaways:** Extremely accurate, but not suitable for codes relying
    on one assignment per grid point.

    This method reduces errors due to orientation by allowing each point to be
    partially assigned to multiple basins, resulting in high accuracy.
    A voronoi cell is generated at each point on the grid. A "flux" is calculated 
    from this point to each neighbor sharing a voronoi facet using the difference 
    in charge density modified by the distance to the neighbor and area of the 
    shared voronoi facet. The total flux is normalized to create "weights" which
    indicate the fraction of the volume that flows to each neighbor.
    
    Moving from highest to lowest, each point is assigned to basins by assigning
    the weight going to each neighbor to that neighbors own fractional assignments.
    The ordering from highest to lowest ensures that the higher neighbors have
    already received their assignment.
    
    !!! Note
        The `bader.basin_labels` and `bader.atom_labels` properties 
        for this method are generated by assigning the points to the basin with 
        the highest weight, or the first basin index in the case of a tie. This
        makes the assignments very unreliable for further analysis.
    
    **Reference**
    
    M. Yu and D. R. Trinkle, Accurate and efficient algorithm for Bader charge integration, [J. Chem. Phys. 134, 064111 (2011)](https://theory.cm.utexas.edu/henkelman/code/bader/download/yu11_064111.pdf)   

=== "pseudo-neargrid"
    **Key Takeaways:** Faster than the original neargrid method, but may be less
    accurate. Avoids edge refinement.
    
    This method is our own adaptation to the original neargrid method, attempting
    to avoid the need for edge refinement. **It is a work in progress and has not been tested thoroughly.**
    
    Similar to the original neargrid method, this method uses a correction
    vector to reduce orientation errors. The gradient and correction vectors are
    calculated upfront and used to determine the highest neighbor for each point. 
    The correction vector at each point is added to it's highest neighbor's correction
    vector once, without comounding to later points. Adjustments are then made where
    required.

    This method avoids the need to follow a gradient path, allowing the calculations
    to be done in parallel and removing the dependency on which points are selected
    as the start of the path.
    The downside is that the correction vectors are not compounded past the nearest
    neighbors, potentially reducing accuracy.
    
---

## Key Implementation Differences
Beyond the basic differences between Python and Fortran, we have made several
decisions in our implementation of these methods that may cause differences in 
results compared with the original Henkelman code. Here we provide a summary of
these differences.

- **General Basin Reduction:** In highly symmetric systems it is common for
local maxima to be positioned exactly between two or more grid points. This
results in adjacent grid points with the same value. The Henkelman group's code
treats these as individual maxima/basins, while we combine them to a single maximum/basin.
This can have major implications for codes utilizing basins rather than atoms.

- **Weight Basin Reduction:** The weight method uses a voronoi cell to determin neighbors
and reduce orientation errors. This often results in points being labeled as maxima
when they have a lower value than one of their 26 nearest neighbors. This can
result in many unrealistic basins and significantly slow down the calculation.
We remove these maxima by assigning them to true maxima using the ongrid method.

- **Parallelization:** Where possible, we perform calculations across the full grid
in parallel or with vectorized operations. We also often store the results in 
memory to avoid repeat calculations (e.g. neargrid gradients, weight fluxes). 
This is faster, but more memory intensive.
This may be prohibitive for large grids. If there is interest, we may add methods
that utilize minimal memory at the cost of speed.

- **Vacuum:** By default we remove grid points below a given tolerance, including
all negative values. The Henkelman group's code instead removes points with an
absolute value below this tolerance.

- **Iterative Edge Refinement:** The original `neargrid` paper suggests
only one edge refinement is needed. We found this is sometimes not the case, and
several refinements may be needed to reach convergence. In our [test case](https://github.com/SWeav02/baderkit/tree/main/src/baderkit/tests/test_files)
on a course grid, the Henkelman groups code assigns asymmetrical charges/volumes to 
symmetrical basins while iterative refinement reaches symmetry after several iterations.
Due to this, we use iterative refinement by default.
This can be changed to the original single refinement by setting `refinement_method="single"` 
in python or `--refinement-method single` in the command-line.