{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>BaderKit is a python package providing tools for calculating atomic charges using principles from Bader's Quantum Theory of Atoms in Molecules. The project has expanded to include methods for analyzing the Electron Localization Function. For more information on the core classes of the package, see their quick-start pages:</p> <ul> <li>Bader</li> <li>BadELF</li> <li>ElfLabeler</li> </ul>"},{"location":"#installation","title":"Installation","text":"conda (recommended)pipGUI App (Optional) <p>If you haven't already, install a conda environment manager such as Anaconda.</p> <ol> <li>Create a conda environment using the following command in your terminal. Replace <code>my_env</code> with whatever name you prefer. <pre><code>conda create -n my_env\n</code></pre></li> <li>Activate your environment. <pre><code>conda activate my_env\n</code></pre></li> <li>Install BaderKit. <pre><code>conda install -c conda-forge baderkit\n</code></pre></li> <li>Confirm the install by running the help command. <pre><code>baderkit --help\n</code></pre></li> </ol> <p>We generally recommend using a virtual environment manager such as Anaconda or venv to keep your Python work environments isolated. If you don't want to, you can still use pip so long as Python is installed.</p> <ol> <li>Install BaderKit with the following command in your terminal. <pre><code>pip install baderkit\n</code></pre></li> <li>Confirm the install by running the help command <pre><code>baderkit --help\n</code></pre></li> </ol> <p>In addition to the core package, there is an optional GUI feature which allows for easy viewing and plotting of results. This requires extra dependencies which can be installed through pip.</p> <pre><code>pip install baderkit[gui]\n</code></pre> <p>Note</p> <p>This is kept as optional as the GUI requires significantly more dependencies than the base app. Unfortunately, this means conda cannot be used, as it does not allow for optional dependencies.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page hosts various examples for using BaderKit for cases not covered on the Quick Start page. If you run into issues and cannot find the answer here or using our API reference, feel free to open an issue or discussion on our github page. Similarly, if you have an example you would like to add, please open a discussion or pull request.</p>"},{"location":"examples/#list-of-examples","title":"List of examples","text":"<p>File formats other than CHGCAR or cube</p> <p>Spin separated calculations</p>"},{"location":"api_reference/core/badelf/","title":"Badelf","text":"<p>Class for performing charge analysis using the electron localization function (ELF). For information on specific methods, see our docs.</p> <p>For more in-depth ELF analysis we recommend using the ElfLabeler class.</p> <p>This class only performs analysis on one spin system.</p> <p>Parameters:</p> Name Type Description Default <code>reference_grid</code> <code>Grid</code> <p>A badelf app Grid like object used for partitioning the unit cell volume. Usually contains ELF.</p> required <code>charge_grid</code> <code>Grid</code> <p>A badelf app Grid like object used for summing charge. Usually contains charge density.</p> required <code>method</code> <code>Literal['badelf', 'voronelf', 'zero-flux']</code> <p>The method to use for partitioning electrides from the nearby atoms.     'badelf' (default)         Separates electrides using zero-flux surfaces then uses         planes at atom radii to separate atoms. This may give more reasonable         results for atoms, particularly in ionic solids. Radii are         calculated directly from the ELF.     'voronelf'         Separates both electrides and atoms using planes at atomic/electride         radii. This is not recommended for electrides that are not         spherical, but may provide better results for those that are.         Radii are calculated directly from the ELF.     'zero-flux'         Separates electrides and atoms using zero-flux surface. This         is the most traditional ELF analysis, but may display some         bias towards atoms with higher ELF values. Results for electride         sites are identical to BadELF, and the method can be significantly         faster.</p> <code>'zero-flux'</code> <code>shared_feature_splitting_method</code> <code>Literal['pauling', 'equal', 'dist', 'nearest']</code> <p>The method of assigning charge from shared ELF features such as covalent or metallic bonds. This parameter is only used with the zero-flux method.     'weighted_dist' (default)         Fraction increases with decreasing distance to each atom. The         fraction is further weighted by the radius of each atom         calculated from the ELF     'pauling'         Distributes charge to neighboring atoms (calculated using CrystalNN)         based on the pualing electronegativity of each species normalized         such that their sum is equal to 1. If no EN is found for the         atom a default of 2.2 is used (including for electrides).     'equal'         Charge is distributed equaly to each neighboring atom/electride         (calculated using CrystalNN)     'dist'         Charge is distributed such that more charge is given to the         closest atoms. Portions are determined by normalizing the sum         of (1/dist) to each neighboring atom.     'nearest'         Gives all charge to the nearest atom or electride site.</p> <code>'weighted_dist'</code> <code>elf_labeler</code> <code>dict | ElfLabeler</code> <p>Keyword arguments to pass to the ElfLabeler class. This includes parameters controlling cutoffs for electrides as well as parameters controlling the Bader algorithm. Alternatively, an ElfLabeler class can be passed directly. The default is {}.</p> <code>{}</code> Source code in <code>src/baderkit/core/badelf/badelf.py</code> <pre><code>class Badelf:\n    \"\"\"\n    Class for performing charge analysis using the electron localization function\n    (ELF). For information on specific methods, see our [docs](https://sweav02.github.io/baderkit/).\n\n    For more in-depth ELF analysis we recommend using the ElfLabeler class.\n\n    This class only performs analysis on one spin system.\n\n    Parameters\n    ----------\n    reference_grid : Grid\n        A badelf app Grid like object used for partitioning the unit cell\n        volume. Usually contains ELF.\n    charge_grid : Grid\n        A badelf app Grid like object used for summing charge. Usually\n        contains charge density.\n    method : Literal[\"badelf\", \"voronelf\", \"zero-flux\"], optional\n        The method to use for partitioning electrides from the nearby\n        atoms.\n            'badelf' (default)\n                Separates electrides using zero-flux surfaces then uses\n                planes at atom radii to separate atoms. This may give more reasonable\n                results for atoms, particularly in ionic solids. Radii are\n                calculated directly from the ELF.\n            'voronelf'\n                Separates both electrides and atoms using planes at atomic/electride\n                radii. This is not recommended for electrides that are not\n                spherical, but may provide better results for those that are.\n                Radii are calculated directly from the ELF.\n            'zero-flux'\n                Separates electrides and atoms using zero-flux surface. This\n                is the most traditional ELF analysis, but may display some\n                bias towards atoms with higher ELF values. Results for electride\n                sites are identical to BadELF, and the method can be significantly\n                faster.\n    shared_feature_splitting_method : Literal[\"pauling\", \"equal\", \"dist\", \"nearest\"], optional\n        The method of assigning charge from shared ELF features\n        such as covalent or metallic bonds. This parameter is only used with the\n        zero-flux method.\n            'weighted_dist' (default)\n                Fraction increases with decreasing distance to each atom. The\n                fraction is further weighted by the radius of each atom\n                calculated from the ELF\n            'pauling'\n                Distributes charge to neighboring atoms (calculated using CrystalNN)\n                based on the pualing electronegativity of each species normalized\n                such that their sum is equal to 1. If no EN is found for the\n                atom a default of 2.2 is used (including for electrides).\n            'equal'\n                Charge is distributed equaly to each neighboring atom/electride\n                (calculated using CrystalNN)\n            'dist'\n                Charge is distributed such that more charge is given to the\n                closest atoms. Portions are determined by normalizing the sum\n                of (1/dist) to each neighboring atom.\n            'nearest'\n                Gives all charge to the nearest atom or electride site.\n    elf_labeler : dict | ElfLabeler, optional\n        Keyword arguments to pass to the ElfLabeler class. This includes\n        parameters controlling cutoffs for electrides as well as parameters\n        controlling the Bader algorithm. Alternatively, an\n        ElfLabeler class can be passed directly. The default is {}.\n\n    \"\"\"\n\n    spin_system = \"total\"\n\n    def __init__(\n        self,\n        reference_grid: Grid,\n        charge_grid: Grid,\n        method: Literal[\"badelf\", \"voronelf\", \"zero-flux\"] = \"zero-flux\",\n        shared_feature_splitting_method: Literal[\n            \"weighted_dist\", \"pauling\", \"equal\", \"dist\", \"nearest\"\n        ] = \"weighted_dist\",\n        elf_labeler: dict | ElfLabeler = {},\n        **kwargs,\n    ):\n        assert (\n            reference_grid.structure == charge_grid.structure\n        ), \"Grid structures must be the same.\"\n\n        if method not in [\"badelf\", \"voronelf\", \"zero-flux\"]:\n            raise ValueError(\n                \"\"\"The method setting you chose does not exist. Please select\n                  either 'badelf', 'voronelf', or 'zero-flux'.\n                  \"\"\"\n            )\n\n        self.reference_grid = reference_grid\n        self.charge_grid = charge_grid\n        self.method = method\n        self.shared_feature_splitting_method = shared_feature_splitting_method\n\n        # We want to use the ElfLabeler. We check if an ElfLabeler class is\n        # provided or a dict of kwargs\n        self._labeled_structure = None\n        if type(elf_labeler) == dict:\n            self.elf_labeler_kwargs = elf_labeler\n            self.elf_labeler = ElfLabeler(\n                charge_grid=charge_grid, reference_grid=reference_grid, **elf_labeler\n            )\n        else:\n            # use provided elf labeler\n            self.elf_labeler_kwargs = None\n            self.elf_labeler = elf_labeler\n        # connect the same bader class.\n        self.bader = self.elf_labeler.bader\n\n        # Properties that will be calculated and cached\n        self._structure = None\n        self._electride_structure = None\n        self._species = None\n\n        self._partitioning_planes = None\n        self._zero_flux_feature_labels_cache = None\n        self._atom_labels = None\n\n        self._electride_dim = None\n        self._all_electride_dims = None\n        self._all_electride_dim_cutoffs = None\n\n        self._nelectrons = None\n        self._charges = None\n        self._volumes = None\n\n        self._min_surface_distances = None\n        self._avg_surface_distances = None\n\n        self._electrides_per_formula = None\n        self._electrides_per_reduced_formula = None\n\n        self._results_summary = None\n\n    ###########################################################################\n    # Convenient Properites\n    ###########################################################################\n\n    @staticmethod\n    def _get_sorted_structure(structure: Structure) -&gt; Structure:\n        \"\"\"\n        Sorts a labeled structure such that atoms come first followed by electrides\n        and then covalent/metallic features.\n\n        Parameters\n        ----------\n        structure : Structure\n            The labeled structure to sort.\n\n        Returns\n        -------\n        Structure\n            The sorted structure.\n\n        \"\"\"\n        # For our partitioning scheme, we need the structure to be ordered as\n        # atoms, electrides, other. This is so that the labeled grid points map\n        # to structure indices.\n        bare_species = FeatureType.bare_species\n        shared_species = FeatureType.shared_species\n        atom_sites = []\n        bare_electron_sites = []\n        shared_sites = []\n        for site in structure:\n            symbol = site.specie.symbol\n            if symbol in bare_species:\n                bare_electron_sites.append(site)\n            elif symbol in shared_species:\n                shared_sites.append(site)\n            else:\n                atom_sites.append(site)\n        # get empty structure\n        new_structure = structure.copy()\n        new_structure.remove_sites([i for i in range(len(structure))])\n        # add back sites in appropriate order\n        for sites_list in [atom_sites, bare_electron_sites, shared_sites]:\n            for site in sites_list:\n                symbol = site.specie.symbol\n                coord = site.frac_coords\n                new_structure.append(symbol, coord)\n        return new_structure\n\n    @property\n    def labeled_structure(self) -&gt; Structure:\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The system's structure including dummy atoms representing electride\n            sites and covalent/metallic bonds.\n\n        \"\"\"\n        if self._labeled_structure is None:\n            labeled_structure = self.elf_labeler.get_feature_structure(\n                included_features=FeatureType.valence_types\n            )\n            self._labeled_structure = labeled_structure\n        return self._labeled_structure\n\n    @property\n    def structure(self) -&gt; Structure:\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The unlabeled structure representing the system, i.e. the structure\n            with no dummy atoms.\n\n        \"\"\"\n        if self._structure is None:\n            # NOTE: We don't just use the structure from one of the grids in\n            # case for some reason they differ from a provided structure from\n            # the user\n            structure = self.labeled_structure.copy()\n            # remove all non-atomic sites\n            for symbol in FEATURE_DUMMY_ATOMS.values():\n                if symbol in structure.symbol_set:\n                    structure.remove_species([symbol])\n            structure.relabel_sites(ignore_uniq=True)\n            self._structure = structure\n        return self._structure\n\n    @property\n    def electride_structure(self) -&gt; Structure:\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The system's structure including dummy atoms representing electride\n            sites.\n\n        \"\"\"\n        if self._electride_structure is None:\n            # create our elecride structure from our labeled structure.\n            # NOTE: We don't just use the structure from the elf labeler in\n            # case the user provided their own\n            electride_structure = self.structure.copy()\n            for site in self.labeled_structure:\n                if site.specie.symbol in FeatureType.bare_species:\n                    electride_structure.append(\n                        FeatureType.bare_electron.dummy_species, site.frac_coords\n                    )\n\n            electride_structure.relabel_sites(ignore_uniq=True)\n            self._electride_structure = electride_structure\n        return self._electride_structure\n\n    @property\n    def nelectrides(self) -&gt; int:\n        \"\"\"\n\n        Returns\n        -------\n        int\n            The number of electride sites (electride maxima) present in the system.\n\n        \"\"\"\n        return len(self.electride_structure) - len(self.structure)\n\n    @property\n    def species(self) -&gt; list[str]:\n        \"\"\"\n\n        Returns\n        -------\n        list[str]\n            The species of each atom/dummy atom in the electride structure. Covalent\n            and metallic features are not included.\n\n        \"\"\"\n        return [i.specie.symbol for i in self.electride_structure]\n\n    @property\n    def charges(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The charge associated with each atom and electride site in the system.\n\n        \"\"\"\n        if self._charges is None:\n            self._get_voxel_assignments()\n        return self._charges.round(10)\n\n    @property\n    def volumes(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The volume associated with each atom and electride site in the system.\n\n        \"\"\"\n        if self._volumes is None:\n            self._get_voxel_assignments()\n        return self._volumes.round(10)\n\n    @property\n    def elf_maxima(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The maximum ELF value for each atom and electride in the system.\n\n        \"\"\"\n\n        return self.elf_labeler.atom_max_values_e\n\n    @property\n    def _zero_flux_feature_labels(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            An array representing which atoms/dummy atoms each voxel point is\n            assigned to.\n\n        \"\"\"\n        if self._zero_flux_feature_labels_cache is None:\n            # Use the ElfLabeler's assignments.\n            self._zero_flux_feature_labels_cache = self.elf_labeler.get_feature_labels(\n                included_features=FeatureType.valence_types,\n                return_structure=False,\n                return_charge_volume=False,\n            )\n\n        return self._zero_flux_feature_labels_cache\n\n    @property\n    def partitioning_planes(self) -&gt; tuple | None:\n        \"\"\"\n\n        Returns\n        -------\n        tuple | None\n            The partitioning planes for each site in the structure as a tuple of\n            arrays. The first array is the site the plane belongs to, the second\n            is a point on the plane, and the third is the vector normal to the plane.\n            None if the zero-flux method is selected.\n\n        \"\"\"\n\n        if self.method == \"zero-flux\":\n            return None, None, None\n\n        if self._partitioning_planes is None:\n            logging.info(\"Finding partitioning planes\")\n\n            # if we have an elf labeler, use its results to get partitioning\n            if self.method == \"badelf\":\n                site_indices, neigh_indices, _, _ = (\n                    self.elf_labeler.nearest_neighbor_data\n                )\n                plane_points, plane_vectors = self.elf_labeler._atom_nn_planes\n            elif self.method == \"voronelf\":\n                site_indices, neigh_indices, _, _ = (\n                    self.elf_labeler.nearest_neighbor_data_e\n                )\n                plane_points, plane_vectors = self.elf_labeler._atom_nn_planes_e\n\n            # we want to transform our planes to the 26 nearest neighbor cells\n            # to ensure that we cover our unit cell.\n            # For speed, we can remove planes that contain the entire unit cell\n            # and we can remove a full set of planes if none of them contain any\n            # part of the unit cell.\n            # Finally, we can sort each plane by how much of the unit cell it slices\n            # such that planes that are likely to reject a grid point come first\n\n            # first we get wrapped planes\n            site_indices, transforms, plane_points, plane_vectors, plane_volumes = (\n                get_cell_wrapped_voronoi(\n                    site_indices=site_indices,\n                    plane_points=plane_points,\n                    plane_vectors=plane_vectors,\n                )\n            )\n\n            # sort planes by site, transform, and volume.\n            combined_sort = np.column_stack((plane_volumes, transforms, site_indices))\n            sorted_indices = np.lexsort(combined_sort.T)\n            transforms = transforms[sorted_indices]\n            plane_points = plane_points[sorted_indices]\n            plane_vectors = plane_vectors[sorted_indices]\n            plane_volumes = plane_volumes[sorted_indices]\n\n            # get plane equations in cartesian coordinates\n            plane_vectors = self.reference_grid.frac_to_cart(plane_vectors)\n            plane_points = self.reference_grid.frac_to_cart(plane_points)\n\n            # normalize vectors\n            plane_vectors = (plane_vectors.T / np.linalg.norm(plane_vectors, axis=1)).T\n\n            # calculate plane equations\n            b = -np.einsum(\"ij,ij-&gt;i\", plane_vectors, plane_points)\n\n            plane_equations = np.column_stack((plane_vectors, b))\n\n            self._partitioning_planes = (site_indices, transforms, plane_equations)\n        return self._partitioning_planes\n\n    @property\n    def atom_labels(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            A 3D array with the same shape as the charge grid indicating\n            which atom/electride each grid point is assigned to.\n\n        \"\"\"\n        if self._atom_labels is None:\n            self._get_voxel_assignments()\n        return self._atom_labels\n\n    def _get_voxel_assignments(self) -&gt; None:\n        \"\"\"\n\n        Returns\n        -------\n        None\n            Gets a dataframe of voxel assignments. The dataframe has columns\n            [x, y, z, charge, sites].\n\n        \"\"\"\n        # make sure we've run our partitioning (for logging clarity)\n        (\n            site_indices,\n            site_transforms,\n            plane_equations,\n        ) = self.partitioning_planes\n\n        logging.info(\"Beginning voxel assignment\")\n\n        # get the zero-flux labels as a starting point\n        labels = self._zero_flux_feature_labels.copy()\n\n        if self.method == \"zero-flux\":\n            # we are done here and can assign charges/volumes immediately\n            self._atom_labels = labels\n            self._charges, self._volumes = self.elf_labeler.get_charges_and_volumes(\n                splitting_method=self.shared_feature_splitting_method,\n                use_electrides=True,\n            )\n\n        else:\n            # In badelf, we want to label our electride basins ahead of time\n            if self.method == \"badelf\":\n                # get a mask only at electride indices\n                indices = np.array(\n                    [\n                        i\n                        for i in range(\n                            len(self.structure), len(self.electride_structure)\n                        )\n                    ]\n                )\n                mask = np.isin(labels, indices, invert=True)\n                # set regions where we don't want to use zero-flux results to -1\n                labels[mask] = -1\n                # get the number of atoms in the partitioning structure\n                structure_len = len(self.structure)\n            elif self.method == \"voronelf\":\n                # we are using the voronoi method with the plane method and don't want\n                # to override anything\n                structure_len = len(self.electride_structure)\n\n            # calculate the maximum distance in fractional coords from the center of\n            # a voxel to its edges\n            voxel_dist = self.reference_grid.max_point_dist + 1e-12\n\n            # get the transforms within a set radius\n            min_radius = voxel_dist * 2\n            max_radius = (np.array(self.structure.lattice.abc) / 2).min()\n            max_radius = min(max_radius, 3.0)  # cap radius for large cells\n            sphere_transforms, transform_dists = (\n                self.reference_grid.get_radial_neighbor_transforms(r=max_radius)\n            )\n            valid_mask = transform_dists &gt;= min_radius\n            sphere_transforms = sphere_transforms[np.where(valid_mask)[0]]\n            transform_dists = transform_dists[valid_mask]\n\n            # get the indices at which new transform dists occur\n            transform_breaks = np.where(transform_dists[:-1] != transform_dists[1:])[0]\n\n            # Now calculate labels, charges, and volumes assigned to each feature\n            labels, charges, volumes = get_badelf_assignments(\n                data=self.charge_grid.total,\n                labels=labels,\n                site_indices=site_indices,\n                site_transforms=site_transforms,\n                plane_equations=plane_equations,\n                vacuum_mask=self.vacuum_mask,\n                min_plane_dist=voxel_dist,\n                num_assignments=len(self.electride_structure),\n                lattice_matrix=self.reference_grid.matrix,\n                sphere_transforms=sphere_transforms,\n                transform_dists=transform_dists,\n                transform_breaks=transform_breaks,\n                max_label=structure_len,\n            )\n\n            # convert charges/volumes to correct units\n            charges /= self.charge_grid.ngridpts\n            volumes = volumes * self.structure.volume / self.charge_grid.ngridpts\n\n            # overwrite zero-flux feature charges/volumes\n            self._atom_labels = labels\n            self._charges = charges\n            self._volumes = volumes\n\n        logging.info(\"Finished voxel assignment\")\n\n    @property\n    def all_electride_dims(self) -&gt; list | None:\n        \"\"\"\n\n        Returns\n        -------\n        list\n            The possible dimensions the electride takes on from an ELF value of\n            0 to 1. If no electrides are present the value will be None.\n\n        \"\"\"\n        if self._all_electride_dims is None:\n            self._get_electride_dimensionality()\n        # if there are no electrides we want to return None, but we don't want\n        # to rerun the search each time. I mark the dims as -1 to avoid this\n        if self._all_electride_dims == -1:\n            return None\n        return self._all_electride_dims\n\n    @property\n    def all_electride_dim_cutoffs(self) -&gt; list:\n        \"\"\"\n\n        Returns\n        -------\n        list\n            The highest ELF value where each dimensionality in the \"all_electride_dims\"\n            property exists.\n\n        \"\"\"\n        if self._all_electride_dim_cutoffs is None:\n            self._get_electride_dimensionality()\n        if self._all_electride_dim_cutoffs == -1:\n            return None\n        return self._all_electride_dim_cutoffs\n\n    @property\n    def electride_dimensionality(self) -&gt; int:\n        \"\"\"\n\n        Returns\n        -------\n        int\n            The dimensionality of the electride volume at a value of 0 ELF.\n\n        \"\"\"\n        if self._electride_dim is None and self.all_electride_dims is not None:\n            self._electride_dim = self.all_electride_dims[0]\n\n        return self._electride_dim\n\n    def _get_ELF_dimensionality(\n        self,\n        electride_mask: NDArray,\n        cutoff: float,\n    ) -&gt; int:\n        \"\"\"\n\n        This algorithm works by checking if the voxels with values above the cutoff\n        are connected to the equivalent voxel in the unit cell one transformation\n        over. This is done primarily using scipy.ndimage.label which determines\n        which voxels are connected. To do this rigorously, the unit cell is repeated\n        to make a (2,2,2) super cell and the connections are checked going from\n        the original unit cell to the unit cells connected at the faces, edges,\n        and corners. If a connection in that direction is found, the total number\n        of connections increases. Dimensionalities of 0,1,2, and 3 are represented\n        by 0,1,4,and 13 connections respectively.\n\n        NOTE: This can be made much faster with numba using an algorithm similar\n        to that used in BaderKit to determine which atoms are surrounded. However,\n        this would require a lot of time.\n\n        Parameters\n        ----------\n        electride_mask : np.array\n            The ELF Grid object with only values associated with electrides.\n        cutoff : float\n            The minimum elf value to consider as a connection.\n\n        Returns\n        -------\n        int\n            The dimensionality at the ELF cutoff.\n\n        \"\"\"\n        # Remove data below our cutoff\n        mask = electride_mask &amp; (self.reference_grid.total &gt;= cutoff)\n\n        # if we have no features, return 0 immediately\n        if not np.any(mask):\n            return 0\n\n        # get the features that sit in the mask at this value\n        feature_indices = self.electride_structure.frac_coords[len(self.structure) :]\n        feature_indices = np.round(\n            self.charge_grid.frac_to_grid(feature_indices)\n        ).astype(int)\n        # only use indices that are not 0\n        feature_indices = [i for i in feature_indices if mask[i[0], i[1], i[2]]]\n\n        # if we have no electride features in the mask, immediately return 0\n        if len(feature_indices) == 0:\n            return 0\n\n        # create a supercell mask and label it\n        supercell_mask = np.tile(mask, [2, 2, 2])\n        labels, num_features = label(supercell_mask, structure=np.ones([3, 3, 3]))\n\n        # We are going to need to translate the above voxels and the entire unit\n        # cell so we create a list of desired transformations\n        transformations = [\n            [0, 0, 0],  # -\n            [1, 0, 0],  # x\n            [0, 1, 0],  # y\n            [0, 0, 1],  # z\n            [1, 1, 0],  # xy\n            [1, 0, 1],  # xz\n            [0, 1, 1],  # yz\n            [1, 1, 1],  # xyz\n        ]\n        transformations = np.array(transformations)\n        transformations = self.charge_grid.frac_to_grid(transformations)\n\n        # The unit cell can be connected to neighboring unit cells in 26 directions.\n        # however, we only need to consider half of these as the others are symmetrical.\n        connections = [\n            # surfaces (3)\n            [0, 1],  # x\n            [0, 2],  # y\n            [0, 3],  # z\n            # edges (6)\n            [0, 4],  # xy\n            [0, 5],  # xz\n            [0, 6],  # yz\n            [3, 1],  # x-z\n            [3, 2],  # y-z\n            [1, 2],  # -xy\n            # corners (4)\n            [0, 7],  # x,y,z\n            [1, 6],  # -x,y,z\n            [2, 5],  # x,-y,z\n            [3, 4],  # x,y,-z\n        ]\n        # Using these connections we can determine the dimensionality of the system.\n        # 1 connection is 1D, 2-4 connections is 2D and 5-13 connections is 3D.\n        # !!! These may need to be updated if I'm wrong. The idea comes from\n        # the fact that the connections should be 1, 4, and 13, but sometimes\n        # voxelation issues result in a connection not working in one direction\n        # while it would in the reverse direction (which isn't possible with\n        # true symmetry). The range accounts for this possibility. The problem\n        # might be if its possible to have for example a 2D connecting structure\n        # with 5 connections. However, I'm pretty sure that immediately causes\n        # an increase to 3D dimensionality.\n        # First we create a list to store potential dimensionalites based off of\n        # each feature. We will take the highest dimensionality.\n        dimensionalities = []\n        for coord in feature_indices:\n            # get the labels at each transformation\n            trans_labels = []\n            for trans in transformations:\n                x, y, z = trans + coord\n                trans_labels.append(labels[x, y, z])\n\n            # count number of connections\n            connections_num = 0\n            for connection in connections:\n                # get the feature label at each voxel\n                label1 = trans_labels[connection[0]]\n                label2 = trans_labels[connection[1]]\n                # If the labels are the same, the unit cell is connected in this\n                # direction\n                if label1 == label2:\n                    connections_num += 1\n            if connections_num == 0:\n                dimensionalities.append(0)\n            elif connections_num == 1:\n                dimensionalities.append(1)\n            elif 1 &lt; connections_num &lt;= 4:\n                dimensionalities.append(2)\n            elif 5 &lt; connections_num &lt;= 13:\n                dimensionalities.append(3)\n\n        return max(dimensionalities)\n\n    def _get_electride_dimensionality(self) -&gt; None:\n        \"\"\"\n\n        Gets the electride dimensionalities and range of ELF values that they\n        exist at.\n\n        \"\"\"\n        # TODO: This whole method should probably be rewritten in Numba\n        # If we have no electrides theres no reason to continue so we stop here\n        logging.info(\"Finding electride dimensionality cutoffs\")\n        if self.nelectrides == 0:\n            self._all_electride_dims = -1\n            self._all_electride_dim_cutoffs = -1\n\n        ###############################################################################\n        # This section preps an ELF grid that only contains values from the electride\n        # sites and is zero everywhere else.\n        ###############################################################################\n\n        # Create a mask at electrides\n        electride_indices = [\n            i for i in range(len(self.structure), len(self.electride_structure))\n        ]\n        # NOTE: even if we have shared features, these indices are still correct\n        # so long as the electride sites come first\n        electride_mask = np.isin(self.atom_labels, electride_indices)\n\n        #######################################################################\n        # This section scans across different cutoffs to determine what dimensionalities\n        # exist in the electride ELF\n        #######################################################################\n        logging.info(\"Calculating dimensionality at 0 ELF\")\n        highest_dimension = self._get_ELF_dimensionality(electride_mask, 0)\n        dimensions = [i for i in range(0, highest_dimension)]\n        dimensions.reverse()\n        # Create lists for the refined dimensions\n        final_dimensions = [highest_dimension]\n        final_connections = [0]\n        amounts_to_change = []\n        # We refine by guessing the cutoff is 0.5 then increasing or decreasing by\n        # 0.25, then 0.125 etc. down to 0.000015259.\n        for i in range(1, 16):\n            amounts_to_change.append(1 / (2 ** (i + 1)))\n        for dimension in dimensions:\n            guess = 0.5\n            # assume this dimension is not found\n            found_dimension = False\n            logging.info(f\"Refining cutoff for dimension {dimension}\")\n            for i in tqdm(amounts_to_change, total=len(amounts_to_change)):\n                # check what our current dimension is. If we are at a higher dimension\n                # we need to raise the cutoff. If we are at a lower dimension or at\n                # the dimension we need to lower it\n                current_dimension = self._get_ELF_dimensionality(electride_mask, guess)\n                if current_dimension &gt; dimension:\n                    guess += i\n                elif current_dimension &lt; dimension:\n                    guess -= i\n                elif current_dimension == dimension:\n                    # We have found the dimension so we add it to our lists.\n                    guess -= i\n                    found_dimension = True\n            if found_dimension:\n                final_connections.append(round(guess, 4))\n                final_dimensions.append(dimension)\n        self._all_electride_dims = final_dimensions\n        self._all_electride_dim_cutoffs = final_connections\n\n    def get_oxidation_from_potcar(self, potcar_path: Path | str = \"POTCAR\"):\n        \"\"\"\n        Calculates the oxidation state of each atom/electride using the\n        electron counts of the neutral atoms provided in a POTCAR.\n\n        Parameters\n        ----------\n        potcar_path : Path | str, optional\n            The Path to the POTCAR file. The default is \"POTCAR\".\n\n        Returns\n        -------\n        oxidation : list\n            The oxidation states of each atom/electride.\n\n        \"\"\"\n        # Check if POTCAR exists in path. If not, throw warning\n        potcar_path = Path(potcar_path)\n        if not potcar_path.exists():\n            logging.warning(\n                \"No POTCAR file found in the requested directory. Oxidation states cannot be calculated\"\n            )\n            return\n        # get POTCAR info\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            potcars = Potcar.from_file(potcar_path)\n        nelectron_data = {}\n        # the result is a list because there can be multiple element potcars\n        # in the file (e.g. for NaCl, POTCAR = POTCAR_Na + POTCAR_Cl)\n        for potcar in potcars:\n            nelectron_data[potcar.element] = potcar.nelectrons\n        # get valence electrons for each site in the structure\n        valence = np.zeros(len(self.electride_structure), dtype=np.float64)\n        for i, site in enumerate(self.structure):\n            valence[i] = nelectron_data[site.specie.symbol]\n        # subtract charges from valence to get oxidation\n        oxidation = valence - self.charges\n        return oxidation\n\n    def _get_min_avg_surface_dists(self) -&gt; None:\n        \"\"\"\n\n        Calculates the minimum and average distance from each atom and electride\n        to the partitioning surface.\n\n        \"\"\"\n        neigh_transforms, _ = self.charge_grid.point_neighbor_transforms\n        edges = get_edges(\n            labeled_array=self.atom_labels,\n            neighbor_transforms=neigh_transforms,\n            vacuum_mask=self.vacuum_mask,\n        )\n        self._min_surface_distances, self._avg_surface_distances = (\n            get_min_avg_surface_dists(\n                labels=self.atom_labels,\n                frac_coords=self.electride_structure.frac_coords,\n                edge_mask=edges,\n                matrix=self.charge_grid.matrix,\n                max_value=np.max(self.structure.lattice.abc) * 2,\n            )\n        )\n\n    @property\n    def min_surface_distances(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The minimum distance from each atom or electride center to the partioning\n            surface.\n\n        \"\"\"\n        if self._min_surface_distances is None:\n            self._get_min_avg_surface_dists()\n        return self._min_surface_distances.round(10)\n\n    @property\n    def avg_surface_distances(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The average distance from each atom or electride center to the partitioning\n            surface.\n\n        \"\"\"\n        if self._avg_surface_distances is None:\n            self._get_min_avg_surface_dists()\n        return self._avg_surface_distances.round(10)\n\n    @property\n    def electrides_per_formula(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The number of electride electrons for the full structure formula.\n\n        \"\"\"\n        if self._electrides_per_formula is None:\n            electrides_per_unit = 0\n            for i in range(len(self.structure), len(self.electride_structure)):\n                electrides_per_unit += self.charges[i]\n            self._electrides_per_formula = electrides_per_unit\n        return round(self._electrides_per_formula, 10)\n\n    @property\n    def electrides_per_reduced_formula(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The number of electrons in the reduced formula of the structure.\n\n        \"\"\"\n        if self._electrides_per_reduced_formula is None:\n            (\n                _,\n                formula_reduction_factor,\n            ) = self.structure.composition.get_reduced_composition_and_factor()\n            self._electrides_per_reduced_formula = (\n                self.electrides_per_formula / formula_reduction_factor\n            )\n        return round(self._electrides_per_reduced_formula, 10)\n\n    @property\n    def electride_formula(self) -&gt; str:\n        \"\"\"\n\n        Returns\n        -------\n        str\n            A string representation of the electride formula, rounding partial charge\n            to the nearest integer.\n\n        \"\"\"\n        return f\"{self.structure.formula} e{round(self.electrides_per_formula)}\"\n\n    @property\n    def total_volume(self):\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total volume integrated in the system. This should match the\n            volume of the structure. If it does not there may be a serious problem.\n\n        \"\"\"\n\n        return round(self.volumes.sum() + self.vacuum_volume, 10)\n\n    ###########################################################################\n    # Vacuum Properties\n    ###########################################################################\n    @property\n    def vacuum_charge(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The charge assigned to the vacuum.\n\n        \"\"\"\n        return self.elf_labeler.vacuum_charge\n\n    @property\n    def vacuum_volume(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total volume assigned to the vacuum.\n\n        \"\"\"\n        return self.elf_labeler.vacuum_volume\n\n    @property\n    def vacuum_mask(self) -&gt; NDArray[bool]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[bool]\n            A mask representing the voxels that belong to the vacuum.\n\n        \"\"\"\n        return self.elf_labeler.vacuum_mask\n\n    @property\n    def num_vacuum(self) -&gt; int:\n        \"\"\"\n\n        Returns\n        -------\n        int\n            The number of vacuum points in the array\n\n        \"\"\"\n        return self.elf_labeler.num_vacuum\n\n    @property\n    def total_electron_number(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total number of electrons in the system calculated from the\n            atom charges and vacuum charge. If this does not match the true\n            total electron number within reasonable floating point error,\n            there is a major problem.\n\n        \"\"\"\n\n        return round(self.charges.sum() + self.vacuum_charge, 10)\n\n    def to_dict(\n        self, potcar_path: Path | str = \"POTCAR\", use_json: bool = True\n    ) -&gt; dict:\n        \"\"\"\n\n        Gets a dictionary summary of the BadELF analysis.\n\n        Parameters\n        ----------\n        potcar_path : Path | str, optional\n            The Path to a POTCAR file. This must be provided for oxidation states\n            to be calculated, and they will be None otherwise. The default is \"POTCAR\".\n        use_json : bool, optional\n            Convert all entries to JSONable data types. The default is True.\n\n        Returns\n        -------\n        dict\n            A summary of the BadELF analysis in dictionary form.\n\n        \"\"\"\n        results = {}\n        # collect method kwargs\n        method_kwargs = {\n            \"method\": self.method,\n            \"shared_feature_splitting_method\": self.shared_feature_splitting_method,\n            \"elf_labeler_kwargs\": self.elf_labeler_kwargs,\n        }\n        results[\"method_kwargs\"] = method_kwargs\n\n        # only try to calculate oxidation state if this was a spin dependent system\n        if self.spin_system == \"total\":\n            results[\"oxidation_states\"] = self.get_oxidation_from_potcar(potcar_path)\n        else:\n            results[\"oxidation_states\"] = None\n\n        # get charges first to ensure good logging\n        self.charges\n\n        for result in [\n            \"species\",\n            \"structure\",\n            \"labeled_structure\",\n            \"electride_structure\",\n            \"nelectrides\",\n            \"all_electride_dims\",\n            \"all_electride_dim_cutoffs\",\n            \"electride_dimensionality\",\n            \"charges\",\n            \"volumes\",\n            \"elf_maxima\",\n            \"min_surface_distances\",\n            \"avg_surface_distances\",\n            \"electride_formula\",\n            \"electrides_per_formula\",\n            \"electrides_per_reduced_formula\",\n            \"total_electron_number\",\n            \"total_volume\",\n            \"spin_system\",\n            \"vacuum_charge\",\n            \"vacuum_volume\",\n        ]:\n            results[result] = getattr(self, result, None)\n        if use_json:\n            # get serializable versions of each attribute\n            for key in [\"structure\", \"labeled_structure\", \"electride_structure\"]:\n                results[key] = results[key].to(fmt=\"POSCAR\")\n            for key in [\n                \"charges\",\n                \"volumes\",\n                \"elf_maxima\",\n                \"oxidation_states\",\n                \"min_surface_distances\",\n                \"avg_surface_distances\",\n            ]:\n                if results[key] is None:\n                    continue  # skip oxidation states if they fail\n                results[key] = results[key].tolist()\n        return results\n\n    def to_json(self, **kwargs) -&gt; str:\n        \"\"\"\n        Creates a JSON string representation of the results, typically for writing\n        results to file.\n\n        Parameters\n        ----------\n        **kwargs : dict\n            Keyword arguments for the to_dict method.\n\n        Returns\n        -------\n        str\n            A JSON string representation of the BadELF results.\n\n        \"\"\"\n        return json.dumps(self.to_dict(use_json=True, **kwargs))\n\n    def write_json(self, filepath: Path | str = \"badelf.json\", **kwargs) -&gt; None:\n        \"\"\"\n        Writes results of the analysis to file in a JSON format.\n\n        Parameters\n        ----------\n        filepath : Path | str, optional\n            The Path to write the results to. The default is \"badelf.json\".\n        **kwargs : dict\n            keyword arguments for the to_dict method.\n\n        \"\"\"\n        filepath = Path(filepath)\n        with open(filepath, \"w\") as json_file:\n            json.dump(self.to_dict(use_json=True, **kwargs), json_file, indent=4)\n\n    @classmethod\n    def from_vasp(\n        cls,\n        reference_file: str | Path = \"ELFCAR\",\n        charge_file: str | Path = \"CHGCAR\",\n        **kwargs,\n    ):\n        \"\"\"\n        Creates a BadElfToolkit instance from the requested partitioning file\n        and charge file.\n\n        Parameters\n        ----------\n        reference_file : str | Path, optional\n            The path to the file to use for partitioning. Must be a VASP\n            CHGCAR or ELFCAR type file. The default is \"ELFCAR\".\n        charge_file : str | Path, optional\n            The path to the file containing the charge density. Must be a VASP\n            CHGCAR or ELFCAR type file. The default is \"CHGCAR\".\n        **kwargs : any\n            Additional keyword arguments for the BadElfToolkit class.\n\n        Returns\n        -------\n        BadElfToolkit\n            A BadElfToolkit instance.\n        \"\"\"\n\n        reference_grid = Grid.from_vasp(reference_file, **kwargs)\n        charge_grid = Grid.from_vasp(charge_file, **kwargs)\n        return cls(reference_grid=reference_grid, charge_grid=charge_grid, **kwargs)\n\n    def write_atom_volumes(\n        self,\n        atom_indices: list[int],\n        directory: str | Path = None,\n        write_reference: bool = True,\n        include_dummy_atoms: bool = True,\n        output_format: str | Format = None,\n        prefix_override: str = None,\n    ):\n        \"\"\"\n\n        Writes an the reference ELF or charge-density for the given atoms to\n        separate files. Electrides found during the calculation are appended to\n        the end of the structure.\n\n        Parameters\n        ----------\n        atom_indices : int\n            The index of the atom/electride to write for.\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is True.\n        include_dummy_atoms : bool, optional\n            Whether or not to add dummy files to the structure. The default is False.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n\n        \"\"\"\n        if directory is None:\n            directory = Path(\".\")\n\n        # Get voxel assignments and data\n        voxel_assignment_array = self.atom_labels\n        if write_reference:\n            grid = self.reference_grid.copy()\n        else:\n            grid = self.charge_grid.copy()\n\n        # add dummy atoms if desired\n        if include_dummy_atoms:\n            grid.structure = self.electride_structure\n\n        # get prefix\n        if prefix_override is None:\n            prefix_override = grid.data_type.prefix\n\n        # Get mask where the grid belongs to requested species\n        for atom_index in atom_indices:\n            mask = voxel_assignment_array == atom_index\n            grid.total[mask] = 0\n            if grid.diff is not None:\n                grid.diff[mask] = 0\n\n            file_path = directory / f\"{prefix_override}_a{atom_index}\"\n            # write file\n            grid.write(filename=file_path, output_format=output_format)\n\n    def write_all_atom_volumes(\n        self,\n        directory: str | Path = None,\n        write_reference: bool = True,\n        output_format: str | Format = None,\n        include_dummy_atoms: bool = True,\n        prefix_override: str = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes all atomic basins.\n\n        Parameters\n        ----------\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n        include_dummy_atoms : bool, optional\n            Whether or not to include . The default is True.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        atom_indices = np.array(range(len(self.electride_structure)))\n        self.write_volumes(\n            atom_indices=atom_indices,\n            directory=directory,\n            write_reference=write_reference,\n            include_dummy_atoms=include_dummy_atoms,\n            output_format=output_format,\n            prefix_override=prefix_override,\n            **writer_kwargs,\n        )\n\n    def write_atom_volumes_sum(\n        self,\n        atom_indices: NDArray,\n        directory: str | Path = None,\n        write_reference: bool = True,\n        output_format: str | Format = None,\n        include_dummy_atoms: bool = True,\n        prefix_override: str = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n\n        Writes the reference ELF or charge-density for the the union of the\n        given atoms to a single file.\n\n        Parameters\n        ----------\n        atom_indices : int\n            The index of the atom/electride to write for.\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is True.\n        include_dummy_atoms : bool, optional\n            Whether or not to add dummy files to the structure. The default is False.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n\n        \"\"\"\n        # get the data to use\n        if write_reference:\n            data_array = self.reference_grid.total\n            data_type = self.reference_grid.data_type\n        else:\n            data_array = self.charge_grid.total\n            data_type = self.charge_grid.data_type\n\n        if directory is None:\n            directory = Path(\".\")\n        mask = np.isin(self.atom_labels, atom_indices)\n        data_array_copy = data_array.copy()\n        data_array_copy[~mask] = 0.0\n        grid = Grid(\n            structure=self.structure,\n            data={\"total\": data_array_copy},\n            data_type=data_type,\n        )\n        # add dummy atoms if desired\n        if include_dummy_atoms:\n            grid.structure = self.electride_structure\n\n        # get prefix\n        if prefix_override is None:\n            prefix_override = grid.data_type.prefix\n\n        file_path = directory / f\"{prefix_override}_asum\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n\n    def write_species_volume(\n        self,\n        directory: str | Path = None,\n        write_reference: bool = True,\n        species: str = FeatureType.bare_electron.dummy_species,\n        include_dummy_atoms: bool = True,\n        output_format: str | Format = None,\n        prefix_override: str = None,\n    ):\n        \"\"\"\n        Writes an ELFCAR or CHGCAR for a given species.\n\n        Parameters\n        ----------\n        directory : str | Path, optional\n            The directory to write the result to. The default is None.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            The default is True.\n        species : str, optional\n            The species to write. The default is \"Le\" (the electrides).\n        include_dummy_atoms : bool, optional\n            Whether or not to include . The default is True.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n\n        \"\"\"\n        if directory is None:\n            directory = Path(\".\")\n\n        # Get voxel assignments and data\n        voxel_assignment_array = self.atom_labels\n        if write_reference:\n            grid = self.reference_grid.copy()\n        else:\n            grid = self.charge_grid.copy()\n\n        # add dummy atoms if desired\n        indices = self.electride_structure.indices_from_symbol(species)\n        if include_dummy_atoms:\n            grid.structure = self.electride_structure\n        # Get mask where the grid belongs to requested species\n        mask = np.isin(voxel_assignment_array, indices, invert=True)\n        grid.total[mask] = 0\n        if grid.diff is not None:\n            grid.diff[mask] = 0\n\n        # get prefix\n        if prefix_override is None:\n            prefix_override = grid.data_type.prefix\n\n        file_path = directory / f\"{prefix_override}_{species}\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format)\n\n    def get_atom_results_dataframe(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Collects a summary of results for the atoms in a pandas DataFrame.\n\n        Returns\n        -------\n        atoms_df : pd.DataFrame\n            A table summarizing the atomic basins.\n\n        \"\"\"\n        # Get atom results summary\n        atom_frac_coords = self.electride_structure.frac_coords\n        atoms_df = pd.DataFrame(\n            {\n                \"label\": self.electride_structure.labels,\n                \"x\": atom_frac_coords[:, 0],\n                \"y\": atom_frac_coords[:, 1],\n                \"z\": atom_frac_coords[:, 2],\n                \"charge\": self.charges,\n                \"volume\": self.volumes,\n                \"surface_dist\": self.min_surface_distances,\n            }\n        )\n        return atoms_df\n\n    def write_atom_tsv(self, filepath: Path | str = \"badelf_atoms.tsv\"):\n        \"\"\"\n        Writes a summary of atom results to .tsv files.\n\n        Parameters\n        ----------\n        filepath : str | Path\n            The Path to write the results to. The default is \"badelf_atoms.tsv\".\n\n        \"\"\"\n        filepath = Path(filepath)\n\n        # Get atom results summary\n        atoms_df = self.get_atom_results_dataframe()\n        formatted_atoms_df = atoms_df.copy()\n        numeric_cols = formatted_atoms_df.select_dtypes(include=\"number\").columns\n        formatted_atoms_df[numeric_cols] = formatted_atoms_df[numeric_cols].map(\n            lambda x: f\"{x:.5f}\"\n        )\n\n        # Determine max width per column including header\n        col_widths = {\n            col: max(len(col), formatted_atoms_df[col].map(len).max())\n            for col in atoms_df.columns\n        }\n\n        # Note what we're writing in log\n        logging.info(f\"Writing Atom Summary to {filepath}\")\n\n        # write output summaries\n        with open(filepath, \"w\") as f:\n            # Write header\n            header = \"\\t\".join(\n                f\"{col:&lt;{col_widths[col]}}\" for col in formatted_atoms_df.columns\n            )\n            f.write(header + \"\\n\")\n\n            # Write rows\n            for _, row in formatted_atoms_df.iterrows():\n                line = \"\\t\".join(\n                    f\"{val:&lt;{col_widths[col]}}\" for col, val in row.items()\n                )\n                f.write(line + \"\\n\")\n\n            f.write(\"\\n\")\n            # f.write(f\"Vacuum Charge:\\t\\t{self.vacuum_charge:.5f}\\n\")\n            # f.write(f\"Vacuum Volume:\\t\\t{self.vacuum_volume:.5f}\\n\")\n            f.write(f\"Total Electrons:\\t{self.total_electron_number:.5f}\\n\")\n</code></pre>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.all_electride_dim_cutoffs","title":"<code>all_electride_dim_cutoffs</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list</code> <p>The highest ELF value where each dimensionality in the \"all_electride_dims\" property exists.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.all_electride_dims","title":"<code>all_electride_dims</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list</code> <p>The possible dimensions the electride takes on from an ELF value of 0 to 1. If no electrides are present the value will be None.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.atom_labels","title":"<code>atom_labels</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>A 3D array with the same shape as the charge grid indicating which atom/electride each grid point is assigned to.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.avg_surface_distances","title":"<code>avg_surface_distances</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The average distance from each atom or electride center to the partitioning surface.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.charges","title":"<code>charges</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The charge associated with each atom and electride site in the system.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.electride_dimensionality","title":"<code>electride_dimensionality</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The dimensionality of the electride volume at a value of 0 ELF.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.electride_formula","title":"<code>electride_formula</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>A string representation of the electride formula, rounding partial charge to the nearest integer.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.electride_structure","title":"<code>electride_structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The system's structure including dummy atoms representing electride sites.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.electrides_per_formula","title":"<code>electrides_per_formula</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The number of electride electrons for the full structure formula.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.electrides_per_reduced_formula","title":"<code>electrides_per_reduced_formula</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The number of electrons in the reduced formula of the structure.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.elf_maxima","title":"<code>elf_maxima</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The maximum ELF value for each atom and electride in the system.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.labeled_structure","title":"<code>labeled_structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The system's structure including dummy atoms representing electride sites and covalent/metallic bonds.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.min_surface_distances","title":"<code>min_surface_distances</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The minimum distance from each atom or electride center to the partioning surface.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.nelectrides","title":"<code>nelectrides</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The number of electride sites (electride maxima) present in the system.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.num_vacuum","title":"<code>num_vacuum</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The number of vacuum points in the array</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.partitioning_planes","title":"<code>partitioning_planes</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>tuple | None</code> <p>The partitioning planes for each site in the structure as a tuple of arrays. The first array is the site the plane belongs to, the second is a point on the plane, and the third is the vector normal to the plane. None if the zero-flux method is selected.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.species","title":"<code>species</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list[str]</code> <p>The species of each atom/dummy atom in the electride structure. Covalent and metallic features are not included.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.structure","title":"<code>structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The unlabeled structure representing the system, i.e. the structure with no dummy atoms.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.total_electron_number","title":"<code>total_electron_number</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total number of electrons in the system calculated from the atom charges and vacuum charge. If this does not match the true total electron number within reasonable floating point error, there is a major problem.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.total_volume","title":"<code>total_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total volume integrated in the system. This should match the volume of the structure. If it does not there may be a serious problem.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.vacuum_charge","title":"<code>vacuum_charge</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The charge assigned to the vacuum.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.vacuum_mask","title":"<code>vacuum_mask</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool]</code> <p>A mask representing the voxels that belong to the vacuum.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.vacuum_volume","title":"<code>vacuum_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total volume assigned to the vacuum.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.volumes","title":"<code>volumes</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The volume associated with each atom and electride site in the system.</p>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.from_vasp","title":"<code>from_vasp(reference_file='ELFCAR', charge_file='CHGCAR', **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a BadElfToolkit instance from the requested partitioning file and charge file.</p> <p>Parameters:</p> Name Type Description Default <code>reference_file</code> <code>str | Path</code> <p>The path to the file to use for partitioning. Must be a VASP CHGCAR or ELFCAR type file. The default is \"ELFCAR\".</p> <code>'ELFCAR'</code> <code>charge_file</code> <code>str | Path</code> <p>The path to the file containing the charge density. Must be a VASP CHGCAR or ELFCAR type file. The default is \"CHGCAR\".</p> <code>'CHGCAR'</code> <code>**kwargs</code> <code>any</code> <p>Additional keyword arguments for the BadElfToolkit class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BadElfToolkit</code> <p>A BadElfToolkit instance.</p> Source code in <code>src/baderkit/core/badelf/badelf.py</code> <pre><code>@classmethod\ndef from_vasp(\n    cls,\n    reference_file: str | Path = \"ELFCAR\",\n    charge_file: str | Path = \"CHGCAR\",\n    **kwargs,\n):\n    \"\"\"\n    Creates a BadElfToolkit instance from the requested partitioning file\n    and charge file.\n\n    Parameters\n    ----------\n    reference_file : str | Path, optional\n        The path to the file to use for partitioning. Must be a VASP\n        CHGCAR or ELFCAR type file. The default is \"ELFCAR\".\n    charge_file : str | Path, optional\n        The path to the file containing the charge density. Must be a VASP\n        CHGCAR or ELFCAR type file. The default is \"CHGCAR\".\n    **kwargs : any\n        Additional keyword arguments for the BadElfToolkit class.\n\n    Returns\n    -------\n    BadElfToolkit\n        A BadElfToolkit instance.\n    \"\"\"\n\n    reference_grid = Grid.from_vasp(reference_file, **kwargs)\n    charge_grid = Grid.from_vasp(charge_file, **kwargs)\n    return cls(reference_grid=reference_grid, charge_grid=charge_grid, **kwargs)\n</code></pre>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.get_atom_results_dataframe","title":"<code>get_atom_results_dataframe()</code>","text":"<p>Collects a summary of results for the atoms in a pandas DataFrame.</p> <p>Returns:</p> Name Type Description <code>atoms_df</code> <code>DataFrame</code> <p>A table summarizing the atomic basins.</p> Source code in <code>src/baderkit/core/badelf/badelf.py</code> <pre><code>def get_atom_results_dataframe(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Collects a summary of results for the atoms in a pandas DataFrame.\n\n    Returns\n    -------\n    atoms_df : pd.DataFrame\n        A table summarizing the atomic basins.\n\n    \"\"\"\n    # Get atom results summary\n    atom_frac_coords = self.electride_structure.frac_coords\n    atoms_df = pd.DataFrame(\n        {\n            \"label\": self.electride_structure.labels,\n            \"x\": atom_frac_coords[:, 0],\n            \"y\": atom_frac_coords[:, 1],\n            \"z\": atom_frac_coords[:, 2],\n            \"charge\": self.charges,\n            \"volume\": self.volumes,\n            \"surface_dist\": self.min_surface_distances,\n        }\n    )\n    return atoms_df\n</code></pre>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.get_oxidation_from_potcar","title":"<code>get_oxidation_from_potcar(potcar_path='POTCAR')</code>","text":"<p>Calculates the oxidation state of each atom/electride using the electron counts of the neutral atoms provided in a POTCAR.</p> <p>Parameters:</p> Name Type Description Default <code>potcar_path</code> <code>Path | str</code> <p>The Path to the POTCAR file. The default is \"POTCAR\".</p> <code>'POTCAR'</code> <p>Returns:</p> Name Type Description <code>oxidation</code> <code>list</code> <p>The oxidation states of each atom/electride.</p> Source code in <code>src/baderkit/core/badelf/badelf.py</code> <pre><code>def get_oxidation_from_potcar(self, potcar_path: Path | str = \"POTCAR\"):\n    \"\"\"\n    Calculates the oxidation state of each atom/electride using the\n    electron counts of the neutral atoms provided in a POTCAR.\n\n    Parameters\n    ----------\n    potcar_path : Path | str, optional\n        The Path to the POTCAR file. The default is \"POTCAR\".\n\n    Returns\n    -------\n    oxidation : list\n        The oxidation states of each atom/electride.\n\n    \"\"\"\n    # Check if POTCAR exists in path. If not, throw warning\n    potcar_path = Path(potcar_path)\n    if not potcar_path.exists():\n        logging.warning(\n            \"No POTCAR file found in the requested directory. Oxidation states cannot be calculated\"\n        )\n        return\n    # get POTCAR info\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        potcars = Potcar.from_file(potcar_path)\n    nelectron_data = {}\n    # the result is a list because there can be multiple element potcars\n    # in the file (e.g. for NaCl, POTCAR = POTCAR_Na + POTCAR_Cl)\n    for potcar in potcars:\n        nelectron_data[potcar.element] = potcar.nelectrons\n    # get valence electrons for each site in the structure\n    valence = np.zeros(len(self.electride_structure), dtype=np.float64)\n    for i, site in enumerate(self.structure):\n        valence[i] = nelectron_data[site.specie.symbol]\n    # subtract charges from valence to get oxidation\n    oxidation = valence - self.charges\n    return oxidation\n</code></pre>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.to_dict","title":"<code>to_dict(potcar_path='POTCAR', use_json=True)</code>","text":"<p>Gets a dictionary summary of the BadELF analysis.</p> <p>Parameters:</p> Name Type Description Default <code>potcar_path</code> <code>Path | str</code> <p>The Path to a POTCAR file. This must be provided for oxidation states to be calculated, and they will be None otherwise. The default is \"POTCAR\".</p> <code>'POTCAR'</code> <code>use_json</code> <code>bool</code> <p>Convert all entries to JSONable data types. The default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A summary of the BadELF analysis in dictionary form.</p> Source code in <code>src/baderkit/core/badelf/badelf.py</code> <pre><code>def to_dict(\n    self, potcar_path: Path | str = \"POTCAR\", use_json: bool = True\n) -&gt; dict:\n    \"\"\"\n\n    Gets a dictionary summary of the BadELF analysis.\n\n    Parameters\n    ----------\n    potcar_path : Path | str, optional\n        The Path to a POTCAR file. This must be provided for oxidation states\n        to be calculated, and they will be None otherwise. The default is \"POTCAR\".\n    use_json : bool, optional\n        Convert all entries to JSONable data types. The default is True.\n\n    Returns\n    -------\n    dict\n        A summary of the BadELF analysis in dictionary form.\n\n    \"\"\"\n    results = {}\n    # collect method kwargs\n    method_kwargs = {\n        \"method\": self.method,\n        \"shared_feature_splitting_method\": self.shared_feature_splitting_method,\n        \"elf_labeler_kwargs\": self.elf_labeler_kwargs,\n    }\n    results[\"method_kwargs\"] = method_kwargs\n\n    # only try to calculate oxidation state if this was a spin dependent system\n    if self.spin_system == \"total\":\n        results[\"oxidation_states\"] = self.get_oxidation_from_potcar(potcar_path)\n    else:\n        results[\"oxidation_states\"] = None\n\n    # get charges first to ensure good logging\n    self.charges\n\n    for result in [\n        \"species\",\n        \"structure\",\n        \"labeled_structure\",\n        \"electride_structure\",\n        \"nelectrides\",\n        \"all_electride_dims\",\n        \"all_electride_dim_cutoffs\",\n        \"electride_dimensionality\",\n        \"charges\",\n        \"volumes\",\n        \"elf_maxima\",\n        \"min_surface_distances\",\n        \"avg_surface_distances\",\n        \"electride_formula\",\n        \"electrides_per_formula\",\n        \"electrides_per_reduced_formula\",\n        \"total_electron_number\",\n        \"total_volume\",\n        \"spin_system\",\n        \"vacuum_charge\",\n        \"vacuum_volume\",\n    ]:\n        results[result] = getattr(self, result, None)\n    if use_json:\n        # get serializable versions of each attribute\n        for key in [\"structure\", \"labeled_structure\", \"electride_structure\"]:\n            results[key] = results[key].to(fmt=\"POSCAR\")\n        for key in [\n            \"charges\",\n            \"volumes\",\n            \"elf_maxima\",\n            \"oxidation_states\",\n            \"min_surface_distances\",\n            \"avg_surface_distances\",\n        ]:\n            if results[key] is None:\n                continue  # skip oxidation states if they fail\n            results[key] = results[key].tolist()\n    return results\n</code></pre>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.to_json","title":"<code>to_json(**kwargs)</code>","text":"<p>Creates a JSON string representation of the results, typically for writing results to file.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Keyword arguments for the to_dict method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the BadELF results.</p> Source code in <code>src/baderkit/core/badelf/badelf.py</code> <pre><code>def to_json(self, **kwargs) -&gt; str:\n    \"\"\"\n    Creates a JSON string representation of the results, typically for writing\n    results to file.\n\n    Parameters\n    ----------\n    **kwargs : dict\n        Keyword arguments for the to_dict method.\n\n    Returns\n    -------\n    str\n        A JSON string representation of the BadELF results.\n\n    \"\"\"\n    return json.dumps(self.to_dict(use_json=True, **kwargs))\n</code></pre>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.write_all_atom_volumes","title":"<code>write_all_atom_volumes(directory=None, write_reference=True, output_format=None, include_dummy_atoms=True, prefix_override=None, **writer_kwargs)</code>","text":"<p>Writes all atomic basins.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>True</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <code>include_dummy_atoms</code> <code>bool</code> <p>Whether or not to include . The default is True.</p> <code>True</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/badelf/badelf.py</code> <pre><code>def write_all_atom_volumes(\n    self,\n    directory: str | Path = None,\n    write_reference: bool = True,\n    output_format: str | Format = None,\n    include_dummy_atoms: bool = True,\n    prefix_override: str = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes all atomic basins.\n\n    Parameters\n    ----------\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n    include_dummy_atoms : bool, optional\n        Whether or not to include . The default is True.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    atom_indices = np.array(range(len(self.electride_structure)))\n    self.write_volumes(\n        atom_indices=atom_indices,\n        directory=directory,\n        write_reference=write_reference,\n        include_dummy_atoms=include_dummy_atoms,\n        output_format=output_format,\n        prefix_override=prefix_override,\n        **writer_kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.write_atom_tsv","title":"<code>write_atom_tsv(filepath='badelf_atoms.tsv')</code>","text":"<p>Writes a summary of atom results to .tsv files.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | Path</code> <p>The Path to write the results to. The default is \"badelf_atoms.tsv\".</p> <code>'badelf_atoms.tsv'</code> Source code in <code>src/baderkit/core/badelf/badelf.py</code> <pre><code>def write_atom_tsv(self, filepath: Path | str = \"badelf_atoms.tsv\"):\n    \"\"\"\n    Writes a summary of atom results to .tsv files.\n\n    Parameters\n    ----------\n    filepath : str | Path\n        The Path to write the results to. The default is \"badelf_atoms.tsv\".\n\n    \"\"\"\n    filepath = Path(filepath)\n\n    # Get atom results summary\n    atoms_df = self.get_atom_results_dataframe()\n    formatted_atoms_df = atoms_df.copy()\n    numeric_cols = formatted_atoms_df.select_dtypes(include=\"number\").columns\n    formatted_atoms_df[numeric_cols] = formatted_atoms_df[numeric_cols].map(\n        lambda x: f\"{x:.5f}\"\n    )\n\n    # Determine max width per column including header\n    col_widths = {\n        col: max(len(col), formatted_atoms_df[col].map(len).max())\n        for col in atoms_df.columns\n    }\n\n    # Note what we're writing in log\n    logging.info(f\"Writing Atom Summary to {filepath}\")\n\n    # write output summaries\n    with open(filepath, \"w\") as f:\n        # Write header\n        header = \"\\t\".join(\n            f\"{col:&lt;{col_widths[col]}}\" for col in formatted_atoms_df.columns\n        )\n        f.write(header + \"\\n\")\n\n        # Write rows\n        for _, row in formatted_atoms_df.iterrows():\n            line = \"\\t\".join(\n                f\"{val:&lt;{col_widths[col]}}\" for col, val in row.items()\n            )\n            f.write(line + \"\\n\")\n\n        f.write(\"\\n\")\n        # f.write(f\"Vacuum Charge:\\t\\t{self.vacuum_charge:.5f}\\n\")\n        # f.write(f\"Vacuum Volume:\\t\\t{self.vacuum_volume:.5f}\\n\")\n        f.write(f\"Total Electrons:\\t{self.total_electron_number:.5f}\\n\")\n</code></pre>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.write_atom_volumes","title":"<code>write_atom_volumes(atom_indices, directory=None, write_reference=True, include_dummy_atoms=True, output_format=None, prefix_override=None)</code>","text":"<p>Writes an the reference ELF or charge-density for the given atoms to separate files. Electrides found during the calculation are appended to the end of the structure.</p> <p>Parameters:</p> Name Type Description Default <code>atom_indices</code> <code>int</code> <p>The index of the atom/electride to write for.</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is True.</p> <code>True</code> <code>include_dummy_atoms</code> <code>bool</code> <p>Whether or not to add dummy files to the structure. The default is False.</p> <code>True</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> Source code in <code>src/baderkit/core/badelf/badelf.py</code> <pre><code>def write_atom_volumes(\n    self,\n    atom_indices: list[int],\n    directory: str | Path = None,\n    write_reference: bool = True,\n    include_dummy_atoms: bool = True,\n    output_format: str | Format = None,\n    prefix_override: str = None,\n):\n    \"\"\"\n\n    Writes an the reference ELF or charge-density for the given atoms to\n    separate files. Electrides found during the calculation are appended to\n    the end of the structure.\n\n    Parameters\n    ----------\n    atom_indices : int\n        The index of the atom/electride to write for.\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is True.\n    include_dummy_atoms : bool, optional\n        Whether or not to add dummy files to the structure. The default is False.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n\n    \"\"\"\n    if directory is None:\n        directory = Path(\".\")\n\n    # Get voxel assignments and data\n    voxel_assignment_array = self.atom_labels\n    if write_reference:\n        grid = self.reference_grid.copy()\n    else:\n        grid = self.charge_grid.copy()\n\n    # add dummy atoms if desired\n    if include_dummy_atoms:\n        grid.structure = self.electride_structure\n\n    # get prefix\n    if prefix_override is None:\n        prefix_override = grid.data_type.prefix\n\n    # Get mask where the grid belongs to requested species\n    for atom_index in atom_indices:\n        mask = voxel_assignment_array == atom_index\n        grid.total[mask] = 0\n        if grid.diff is not None:\n            grid.diff[mask] = 0\n\n        file_path = directory / f\"{prefix_override}_a{atom_index}\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format)\n</code></pre>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.write_atom_volumes_sum","title":"<code>write_atom_volumes_sum(atom_indices, directory=None, write_reference=True, output_format=None, include_dummy_atoms=True, prefix_override=None, **writer_kwargs)</code>","text":"<p>Writes the reference ELF or charge-density for the the union of the given atoms to a single file.</p> <p>Parameters:</p> Name Type Description Default <code>atom_indices</code> <code>int</code> <p>The index of the atom/electride to write for.</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is True.</p> <code>True</code> <code>include_dummy_atoms</code> <code>bool</code> <p>Whether or not to add dummy files to the structure. The default is False.</p> <code>True</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> Source code in <code>src/baderkit/core/badelf/badelf.py</code> <pre><code>def write_atom_volumes_sum(\n    self,\n    atom_indices: NDArray,\n    directory: str | Path = None,\n    write_reference: bool = True,\n    output_format: str | Format = None,\n    include_dummy_atoms: bool = True,\n    prefix_override: str = None,\n    **writer_kwargs,\n):\n    \"\"\"\n\n    Writes the reference ELF or charge-density for the the union of the\n    given atoms to a single file.\n\n    Parameters\n    ----------\n    atom_indices : int\n        The index of the atom/electride to write for.\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is True.\n    include_dummy_atoms : bool, optional\n        Whether or not to add dummy files to the structure. The default is False.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n\n    \"\"\"\n    # get the data to use\n    if write_reference:\n        data_array = self.reference_grid.total\n        data_type = self.reference_grid.data_type\n    else:\n        data_array = self.charge_grid.total\n        data_type = self.charge_grid.data_type\n\n    if directory is None:\n        directory = Path(\".\")\n    mask = np.isin(self.atom_labels, atom_indices)\n    data_array_copy = data_array.copy()\n    data_array_copy[~mask] = 0.0\n    grid = Grid(\n        structure=self.structure,\n        data={\"total\": data_array_copy},\n        data_type=data_type,\n    )\n    # add dummy atoms if desired\n    if include_dummy_atoms:\n        grid.structure = self.electride_structure\n\n    # get prefix\n    if prefix_override is None:\n        prefix_override = grid.data_type.prefix\n\n    file_path = directory / f\"{prefix_override}_asum\"\n    # write file\n    grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n</code></pre>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.write_json","title":"<code>write_json(filepath='badelf.json', **kwargs)</code>","text":"<p>Writes results of the analysis to file in a JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Path | str</code> <p>The Path to write the results to. The default is \"badelf.json\".</p> <code>'badelf.json'</code> <code>**kwargs</code> <code>dict</code> <p>keyword arguments for the to_dict method.</p> <code>{}</code> Source code in <code>src/baderkit/core/badelf/badelf.py</code> <pre><code>def write_json(self, filepath: Path | str = \"badelf.json\", **kwargs) -&gt; None:\n    \"\"\"\n    Writes results of the analysis to file in a JSON format.\n\n    Parameters\n    ----------\n    filepath : Path | str, optional\n        The Path to write the results to. The default is \"badelf.json\".\n    **kwargs : dict\n        keyword arguments for the to_dict method.\n\n    \"\"\"\n    filepath = Path(filepath)\n    with open(filepath, \"w\") as json_file:\n        json.dump(self.to_dict(use_json=True, **kwargs), json_file, indent=4)\n</code></pre>"},{"location":"api_reference/core/badelf/#src.baderkit.core.badelf.Badelf.write_species_volume","title":"<code>write_species_volume(directory=None, write_reference=True, species=FeatureType.bare_electron.dummy_species, include_dummy_atoms=True, output_format=None, prefix_override=None)</code>","text":"<p>Writes an ELFCAR or CHGCAR for a given species.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The directory to write the result to. The default is None.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. The default is True.</p> <code>True</code> <code>species</code> <code>str</code> <p>The species to write. The default is \"Le\" (the electrides).</p> <code>dummy_species</code> <code>include_dummy_atoms</code> <code>bool</code> <p>Whether or not to include . The default is True.</p> <code>True</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> Source code in <code>src/baderkit/core/badelf/badelf.py</code> <pre><code>def write_species_volume(\n    self,\n    directory: str | Path = None,\n    write_reference: bool = True,\n    species: str = FeatureType.bare_electron.dummy_species,\n    include_dummy_atoms: bool = True,\n    output_format: str | Format = None,\n    prefix_override: str = None,\n):\n    \"\"\"\n    Writes an ELFCAR or CHGCAR for a given species.\n\n    Parameters\n    ----------\n    directory : str | Path, optional\n        The directory to write the result to. The default is None.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        The default is True.\n    species : str, optional\n        The species to write. The default is \"Le\" (the electrides).\n    include_dummy_atoms : bool, optional\n        Whether or not to include . The default is True.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n\n    \"\"\"\n    if directory is None:\n        directory = Path(\".\")\n\n    # Get voxel assignments and data\n    voxel_assignment_array = self.atom_labels\n    if write_reference:\n        grid = self.reference_grid.copy()\n    else:\n        grid = self.charge_grid.copy()\n\n    # add dummy atoms if desired\n    indices = self.electride_structure.indices_from_symbol(species)\n    if include_dummy_atoms:\n        grid.structure = self.electride_structure\n    # Get mask where the grid belongs to requested species\n    mask = np.isin(voxel_assignment_array, indices, invert=True)\n    grid.total[mask] = 0\n    if grid.diff is not None:\n        grid.diff[mask] = 0\n\n    # get prefix\n    if prefix_override is None:\n        prefix_override = grid.data_type.prefix\n\n    file_path = directory / f\"{prefix_override}_{species}\"\n    # write file\n    grid.write(filename=file_path, output_format=output_format)\n</code></pre>"},{"location":"api_reference/core/badelf_spin/","title":"SpinBadelf","text":"<p>This class is a wrapper for the Badelf class adding the capability to individually handle spin-up and spin-down components of the ELF and charge density.</p> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>class SpinBadelf:\n    \"\"\"\n    This class is a wrapper for the Badelf class adding the capability\n    to individually handle spin-up and spin-down components of the\n    ELF and charge density.\n    \"\"\"\n\n    spin_system = \"combined\"\n\n    def __init__(\n        self,\n        reference_grid: Grid,\n        charge_grid: Grid,\n        elf_labeler: SpinElfLabeler | dict = {},\n        **kwargs,\n    ):\n        \"\"\"\n        An extension of the BadElfToolkit that performs separate calculations on\n        the spin-up and spin-down systems.\n\n        Parameters\n        ----------\n        reference_grid : Grid\n            A badelf app Grid like object used for partitioning the unit cell\n            volume. Usually contains ELF.\n        charge_grid : Grid\n            A badelf app Grid like object used for summing charge. Usually\n            contains charge density.\n        elf_labeler : dict | SpinElfLabeler, optional\n            Keyword arguments to pass to the SpinElfLabeler class. This includes\n            parameters controlling cutoffs for electrides. Alternatively, a\n            SpinElfLabeler class can be passed directly. The default is {}.\n        **kwargs : dict\n            Any additional keyword arguments to pass to the ElfLabeler class.\n\n        \"\"\"\n        # make sure our grids are spin polarized\n        assert (\n            reference_grid.is_spin_polarized\n        ), \"Provided grid is not spin polarized. Use the standard BadElfToolkit.\"\n\n        self.reference_grid = reference_grid\n        self.charge_grid = charge_grid\n\n        # If no labeled structures are provided, we want to use the spin elf\n        # labeler and link it to our badelf objects\n        # we want to attach a SpinElfLabeler to our badelf objects\n        if type(elf_labeler) is dict:\n            elf_labeler = SpinElfLabeler(\n                charge_grid=charge_grid, reference_grid=reference_grid, **elf_labeler\n            )\n\n        self.elf_labeler = elf_labeler\n        # link charge grids\n        self.reference_grid_up = elf_labeler.reference_grid_up\n        self.reference_grid_down = elf_labeler.reference_grid_down\n        self.charge_grid_up = elf_labeler.charge_grid_up\n        self.charge_grid_down = elf_labeler.charge_grid_down\n        self.equal_spin = elf_labeler.equal_spin\n        # link labelers\n        self.elf_labeler_up = elf_labeler.elf_labeler_up\n        self.elf_labeler_down = elf_labeler.elf_labeler_down\n\n        # Now check if we should run a spin polarized badelf calc or not\n        if not self.equal_spin:\n            self.badelf_up = Badelf(\n                reference_grid=self.reference_grid_up,\n                charge_grid=self.charge_grid_up,\n                elf_labeler=self.elf_labeler_up,\n                **kwargs,\n            )\n            self.badelf_down = Badelf(\n                reference_grid=self.reference_grid_down,\n                charge_grid=self.charge_grid_down,\n                elf_labeler=self.elf_labeler_down,\n                **kwargs,\n            )\n            self.badelf_up.spin_system = \"up\"\n            self.badelf_down.spin_system = \"down\"\n        else:\n            self.badelf_up = Badelf(\n                reference_grid=self.reference_grid_up,\n                charge_grid=self.charge_grid_up,\n                elf_labeler=self.elf_labeler_up,\n                **kwargs,\n            )\n            self.badelf_up.spin_system = \"half\"\n            self.badelf_down = self.badelf_up\n\n        # Properties that will be calculated and cached\n        self._electride_structure = None\n        self._labeled_structure = None\n        self._species = None\n\n        self._electride_dim = None\n\n        self._nelectrons = None\n        self._charges = None\n        self._volumes = None\n\n        self._min_surface_distances = None\n        self._avg_surface_distances = None\n\n        self._electrides_per_formula = None\n        self._electrides_per_reduced_formula = None\n\n        self._results_summary = None\n\n    @property\n    def structure(self):\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The unlabeled structure representing the system, i.e. the structure\n            with no dummy atoms.\n\n        \"\"\"\n        return self.badelf_up.structure\n\n    @property\n    def labeled_structure(self):\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The system's structure including dummy atoms representing electride\n            sites and covalent/metallic bonds. Features unique to the spin-up/spin-down\n            systems will have xu or xd appended to the species name respectively.\n            Features that exist in both will have nothing appended.\n\n        \"\"\"\n        if self._labeled_structure is None:\n            # start with only atoms\n            labeled_structure = self.structure.copy()\n            # get up and downs structures\n            structure_up = self.badelf_up.labeled_structure\n            structure_down = self.badelf_down.labeled_structure\n            # get species from the spin up system\n            new_species = []\n            new_coords = []\n            for site in structure_up[len(self.structure) :]:\n                species = site.specie.symbol\n                # add frac coords no matter what\n                new_coords.append(site.frac_coords)\n                # if this site is in the spin-down structure, it exists in both and\n                # we add the site with the original species name\n                if site in structure_down:\n                    new_species.append(species)\n                else:\n                    # otherwise, we rename the species\n                    new_species.append(species + \"xu\")\n            # do the same for the spin down system\n            for site in structure_down[len(self.structure) :]:\n                # only add the structure if it didn't exist in the spin up system\n                if site not in structure_up:\n                    species = site.specie.symbol\n                    new_species.append(species + \"xd\")\n                    new_coords.append(site.frac_coords)\n            # add our sites\n            for species, coords in zip(new_species, new_coords):\n                labeled_structure.append(species, coords)\n            self._labeled_structure = labeled_structure\n        return self._labeled_structure\n\n    @property\n    def electride_structure(self) -&gt; Structure:\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The system's structure including dummy atoms representing electride\n            sites. Electrides unique to the spin-up/spin-down\n            systems will have xu or xd appended to the species name respectively.\n            Electrides that exist in both will have nothing appended.\n\n        \"\"\"\n        if self._electride_structure is None:\n            # create our elecride structure from our labeled structure.\n            # NOTE: We don't just use the structure from the elf labeler in\n            # case the user provided their own\n            electride_structure = self.structure.copy()\n            # get bare species including up/down spin\n            all_bare_species = []\n            for species in FeatureType.bare_species:\n                all_bare_species.append(species)\n                all_bare_species.append(species + \"xu\")\n                all_bare_species.append(species + \"xd\")\n            # add any bare electron/electrides to our structure\n            for site in self.labeled_structure:\n                if site.specie.symbol in all_bare_species:\n                    electride_structure.append(site.specie.symbol, site.frac_coords)\n            self._electride_structure = electride_structure\n        return self._electride_structure\n\n    @property\n    def nelectrides(self):\n        \"\"\"\n\n        Returns\n        -------\n        int\n            The number of electride sites (electride maxima) present in the system.\n\n        \"\"\"\n        return len(self.electride_structure) - len(self.structure)\n\n    @property\n    def species(self) -&gt; list[str]:\n        \"\"\"\n\n        Returns\n        -------\n        list[str]\n            The species of each atom/dummy atom in the electride structure. Covalent\n            and metallic features are not included.\n\n        \"\"\"\n        return [i.specie.symbol for i in self.electride_structure]\n\n    @property\n    def electride_dimensionality(self):\n        \"\"\"\n\n        Returns\n        -------\n        int\n            The dimensionality of the electride volume at a value of 0 ELF. If\n            the dimensionality differes between the spin-up/spin-down results, the\n            largest dimensionality is selected.\n\n        \"\"\"\n        return max(\n            self.badelf_up.electride_dimensionality,\n            self.badelf_down.electride_dimensionality,\n        )\n\n    def _get_charges_and_volumes(self):\n        \"\"\"\n        NOTE: Volumes may not have a physical meaning when differences are found\n        between spin up/down systems. They are calculated as the average between\n        the systems.\n        \"\"\"\n        # get the initial charges/volumes from the spin up system\n        charges = self.badelf_up.charges.tolist()\n        volumes = self.badelf_up.volumes.tolist()\n\n        # get the charges from the spin down system\n        charges_down = self.badelf_down.charges.tolist()\n        volumes_down = self.badelf_down.volumes.tolist()\n\n        # get structures from each system\n        structure_up = self.badelf_up.electride_structure\n        structure_down = self.badelf_down.electride_structure\n\n        # add charge from spin down structure\n        for site, charge, volume in zip(structure_down, charges_down, volumes_down):\n            if site in structure_up:\n                index = structure_up.index(site)\n                charges[index] += charge\n                volumes[index] += volume\n            else:\n                charges.append(charge)\n                volumes.append(volume)\n        self._charges = np.array(charges)\n        self._volumes = np.array(volumes) / 2\n\n    @property\n    def charges(self):\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The charge associated with each atom and electride site in the system.\n            If an electride site appears in both spin systems, the assigned charge\n            is the sum.\n\n        \"\"\"\n        if self._charges is None:\n            self._get_charges_and_volumes()\n        return self._charges.round(10)\n\n    @property\n    def volumes(self):\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The volume associated with each atom and electride site in the system.\n            The volume is taken as the average of the two systems, and may not have\n            a physical meaning.\n\n        \"\"\"\n        if self._volumes is None:\n            self._get_charges_and_volumes()\n        return self._volumes.round(10)\n\n    def get_oxidation_from_potcar(self, potcar_path: Path | str = \"POTCAR\"):\n        \"\"\"\n        Calculates the oxidation state of each atom/electride using the\n        electron counts of the neutral atoms provided in a POTCAR.\n\n        Parameters\n        ----------\n        potcar_path : Path | str, optional\n            The Path to the POTCAR file. The default is \"POTCAR\".\n\n        Returns\n        -------\n        oxidation : list\n            The oxidation states of each atom/electride.\n\n        \"\"\"\n        # Check if POTCAR exists in path. If not, throw warning\n        potcar_path = Path(potcar_path)\n        if not potcar_path.exists():\n            logging.warning(\n                \"No POTCAR file found in the requested directory. Oxidation states cannot be calculated\"\n            )\n            return\n        # get POTCAR info\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            potcars = Potcar.from_file(potcar_path)\n        nelectron_data = {}\n        # the result is a list because there can be multiple element potcars\n        # in the file (e.g. for NaCl, POTCAR = POTCAR_Na + POTCAR_Cl)\n        for potcar in potcars:\n            nelectron_data[potcar.element] = potcar.nelectrons\n        # get valence electrons for each site in the structure\n        valence = np.zeros(len(self.electride_structure), dtype=np.float64)\n        for i, site in enumerate(self.structure):\n            valence[i] = nelectron_data[site.specie.symbol]\n        # subtract charges from valence to get oxidation\n        oxidation = valence - self.charges\n        return oxidation\n\n    @property\n    def electrides_per_formula(self):\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The number of electride electrons for the full structure formula.\n\n        \"\"\"\n        if self._electrides_per_formula is None:\n            electrides_per_unit = 0\n            for i in range(len(self.structure), len(self.electride_structure)):\n                electrides_per_unit += self.charges[i]\n            self._electrides_per_formula = electrides_per_unit\n        return round(self._electrides_per_formula, 10)\n\n    @property\n    def electrides_per_reduced_formula(self):\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The number of electrons in the reduced formula of the structure.\n\n        \"\"\"\n        if self._electrides_per_reduced_formula is None:\n            (\n                _,\n                formula_reduction_factor,\n            ) = self.structure.composition.get_reduced_composition_and_factor()\n            self._electrides_per_reduced_formula = (\n                self.electrides_per_formula / formula_reduction_factor\n            )\n        return round(self._electrides_per_reduced_formula, 10)\n\n    @property\n    def electride_formula(self):\n        \"\"\"\n\n        Returns\n        -------\n        str\n            A string representation of the electride formula, rounding partial charge\n            to the nearest integer.\n\n        \"\"\"\n        return f\"{self.structure.formula} e{round(self.electrides_per_formula)}\"\n\n    ###########################################################################\n    # Vacuum Properties\n    ###########################################################################\n    @property\n    def vacuum_charge(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The charge assigned to the vacuum.\n\n        \"\"\"\n        return self.badelf_up.vacuum_charge + self.badelf_down.vacuum_charge\n\n    @property\n    def vacuum_volume(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total volume assigned to the vacuum. This is an average between\n            the spin up and spin down values.\n\n        \"\"\"\n        return (self.badelf_up.vacuum_volume + self.badelf_down.vacuum_volume) / 2\n\n    @property\n    def total_electron_number(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total number of electrons in the system calculated from the\n            spin-up and spin-down systems. If this does not match the true\n            total electron number within reasonable floating point error,\n            there is a major problem.\n\n        \"\"\"\n\n        return round(\n            self.badelf_up.total_electron_number\n            + self.badelf_down.total_electron_number,\n            10,\n        )\n\n    @property\n    def total_volume(self):\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total volume integrated in the system. This should match the\n            volume of the structure. If it does not there may be a serious problem.\n\n            This is the average of the two systems\n\n        \"\"\"\n\n        return (self.badelf_up.total_volume + self.badelf_down.total_volume) / 2\n\n    def to_dict(self, potcar_path: Path | str = \"POTCAR\", use_json: bool = True):\n        \"\"\"\n\n        Gets a dictionary summary of the BadELF analysis.\n\n        Parameters\n        ----------\n        potcar_path : Path | str, optional\n            The Path to a POTCAR file. This must be provided for oxidation states\n            to be calculated, and they will be None otherwise. The default is \"POTCAR\".\n        use_json : bool, optional\n            Convert all entries to JSONable data types. The default is True.\n\n        Returns\n        -------\n        dict\n            A summary of the BadELF analysis in dictionary form.\n\n        \"\"\"\n        results = {}\n\n        results[\"method_kwargs\"] = self.badelf_up.to_dict()[\"method_kwargs\"]\n\n        results[\"oxidation_states\"] = self.get_oxidation_from_potcar(potcar_path)\n\n        for result in [\n            \"spin_system\",\n            \"species\",\n            \"structure\",\n            \"labeled_structure\",\n            \"electride_structure\",\n            \"nelectrides\",\n            \"electride_dimensionality\",\n            \"charges\",\n            \"volumes\",\n            \"electride_formula\",\n            \"electrides_per_formula\",\n            \"electrides_per_reduced_formula\",\n            \"total_electron_number\",\n            \"total_volume\",\n            \"vacuum_charge\",\n            \"vacuum_volume\",\n        ]:\n            results[result] = getattr(self, result, None)\n        if use_json:\n            # get serializable versions of each attribute\n            for key in [\"structure\", \"labeled_structure\", \"electride_structure\"]:\n                results[key] = results[key].to(fmt=\"POSCAR\")\n            for key in [\"charges\", \"volumes\", \"oxidation_states\"]:\n                if results[key] is None:\n                    continue\n                results[key] = results[key].tolist()\n        return results\n\n    def to_json(self, **kwargs):\n        \"\"\"\n        Creates a JSON string representation of the results, typically for writing\n        results to file.\n\n        Parameters\n        ----------\n        **kwargs : dict\n            Keyword arguments for the to_dict method.\n\n        Returns\n        -------\n        str\n            A JSON string representation of the BadELF results.\n\n        \"\"\"\n        return json.dumps(self.to_dict(use_json=True, **kwargs))\n\n    def write_json(\n        self, filepath: Path | str = \"badelf.json\", write_spin: bool = False, **kwargs\n    ):\n        \"\"\"\n        Writes results of the analysis to file in a JSON format.\n\n        Parameters\n        ----------\n        filepath : Path | str, optional\n            The Path to write the results to. The default is \"badelf_results_summary.json\".\n        write_spin : bool, optional\n            Whether or not to write the spin up/down summary jsons as well\n        **kwargs : dict\n            keyword arguments for the to_dict method.\n\n        \"\"\"\n        filepath = Path(filepath)\n\n        # write total summary\n        with open(filepath, \"w\") as json_file:\n            json.dump(self.to_dict(use_json=True, **kwargs), json_file, indent=4)\n        # write spin up and spin down summaries\n        if write_spin:\n            filepath_up = filepath.parent / f\"{filepath.stem}_up{filepath.suffix}\"\n            filepath_down = filepath.parent / f\"{filepath.stem}_down{filepath.suffix}\"\n            self.badelf_up.write_json(filepath=filepath_up)\n            self.badelf_down.write_json(filepath=filepath_down)\n\n    @classmethod\n    def from_vasp(\n        cls,\n        reference_file: str | Path = \"ELFCAR\",\n        charge_file: str | Path = \"CHGCAR\",\n        **kwargs,\n    ):\n        \"\"\"\n        Creates a SpinBadElfToolkit instance from the requested partitioning file\n        and charge file.\n\n        Parameters\n        ----------\n        reference_file : str | Path, optional\n            The path to the file to use for partitioning. Must be a VASP\n            CHGCAR or ELFCAR type file. The default is \"ELFCAR\".\n        charge_file : str | Path, optional\n            The path to the file containing the charge density. Must be a VASP\n            CHGCAR or ELFCAR type file. The default is \"CHGCAR\".\n        **kwargs : any\n            Additional keyword arguments for the SpinBadElfToolkit class.\n\n        Returns\n        -------\n        SpinBadElfToolkit\n            A SpinBadElfToolkit instance.\n        \"\"\"\n\n        reference_grid = Grid.from_vasp(reference_file, total_only=False)\n        charge_grid = Grid.from_vasp(charge_file, total_only=False)\n        return cls(reference_grid=reference_grid, charge_grid=charge_grid, **kwargs)\n\n    def write_atom_volumes(\n        self,\n        atom_indices: NDArray,\n        directory: str | Path = None,\n        write_reference: bool = True,\n        include_dummy_atoms: bool = True,\n        output_format: str | Format = None,\n        prefix_override: str = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Writes the reference ELF or charge-density for the given atoms to\n        separate files. Electrides found during the calculation are appended to\n        the end of the structure. Note that non-atomic features of the same index\n        in different spin systems may not correspond to the same feature.\n\n        Parameters\n        ----------\n        atom_indices : NDArray\n            The list of atom/electride indices to write\n        directory : str | Path, optional\n            The directory to write the result to. The default is None.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            The default is True.\n        include_dummy_atoms : bool, optional\n            Whether or not to include . The default is True.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n\n        \"\"\"\n\n        if directory is None:\n            directory = Path(\".\")\n\n        # get prefix\n        if prefix_override is None:\n            if write_reference:\n                prefix_override = self.reference_grid.data_type.prefix\n            else:\n                prefix_override = self.charge_grid.data_type.prefix\n\n        # temporarily update prefix override to avoid overwriting\n        if self.equal_spin:\n            temp_prefix = f\"{prefix_override}_temp\"\n        else:\n            temp_prefix = prefix_override\n\n        for atom_index in atom_indices:\n            self.badelf_up.write_atom_volumes(\n                atom_indices=[atom_index],\n                directory=directory,\n                prefix_override=temp_prefix,\n                include_dummy_atoms=include_dummy_atoms,\n                write_reference=write_reference,\n                **kwargs,\n            )\n            if not self.equal_spin:\n                # rename with \"up\" so we don't overwrite\n                os.rename(\n                    directory / f\"{temp_prefix}_a{atom_index}\",\n                    directory / f\"{prefix_override}_a{atom_index}_up\",\n                )\n                # Write the spin down file and change the name\n                self.badelf_down.write_atom_volumes(\n                    atom_indices=[atom_index],\n                    directory=directory,\n                    prefix_override=temp_prefix,\n                    include_dummy_atoms=include_dummy_atoms,\n                    write_reference=write_reference,\n                    **kwargs,\n                )\n                os.rename(\n                    directory / f\"{temp_prefix}_a{atom_index}\",\n                    directory / f\"{prefix_override}_a{atom_index}_down\",\n                )\n\n    def write_all_atom_volumes(\n        self,\n        directory: str | Path = None,\n        write_reference: bool = True,\n        include_dummy_atoms: bool = True,\n        output_format: str | Format = None,\n        prefix_override: str = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Writes the reference ELF or charge-density for the each atom to\n        separate files. Electrides found during the calculation are appended to\n        the end of the structure. Note that non-atomic features of the same index\n        in different spin systems may not correspond to the same feature.\n\n        Parameters\n        ----------\n        directory : str | Path, optional\n            The directory to write the result to. The default is None.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            The default is True.\n        include_dummy_atoms : bool, optional\n            Whether or not to include . The default is True.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n\n        \"\"\"\n\n        if directory is None:\n            directory = Path(\".\")\n\n        # get prefix\n        if prefix_override is None:\n            if write_reference:\n                prefix_override = self.reference_grid.data_type.prefix\n            else:\n                prefix_override = self.charge_grid.data_type.prefix\n\n        # temporarily update prefix override to avoid overwriting\n        if self.equal_spin:\n            temp_prefix = f\"{prefix_override}_temp\"\n        else:\n            temp_prefix = prefix_override\n\n        for atom_index in range(len(self.electride_structure)):\n            self.badelf_up.write_atom_volumes(\n                atom_indices=[atom_index],\n                directory=directory,\n                write_reference=write_reference,\n                include_dummy_atoms=include_dummy_atoms,\n                prefix_override=temp_prefix,\n                **kwargs,\n            )\n            if not self.equal_spin:\n                # rename with \"up\" so we don't overwrite\n                os.rename(\n                    directory / f\"{temp_prefix}_a{atom_index}\",\n                    directory / f\"{prefix_override}_a{atom_index}_up\",\n                )\n                # Write the spin down file and change the name\n                self.badelf_down.write_atom_volumes(\n                    atom_indices=[atom_index],\n                    directory=directory,\n                    write_reference=write_reference,\n                    include_dummy_atoms=include_dummy_atoms,\n                    prefix_override=temp_prefix,\n                    **kwargs,\n                )\n                os.rename(\n                    directory / f\"{temp_prefix}_a{atom_index}\",\n                    directory / f\"{prefix_override}_a{atom_index}_down\",\n                )\n\n    def write_atom_volumes_sum(\n        self,\n        atom_indices: NDArray,\n        directory: str | Path = None,\n        write_reference: bool = True,\n        output_format: str | Format = None,\n        include_dummy_atoms: bool = True,\n        prefix_override: str = None,\n        **kwargs,\n    ):\n        \"\"\"\n\n        Writes the reference ELF or charge-density for the the union of the\n        given atoms to a single file. Note that non-atomic features of the same index\n        in different spin systems may not correspond to the same feature.\n\n        Parameters\n        ----------\n        atom_indices : int\n            The index of the atom/electride to write for.\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is True.\n        include_dummy_atoms : bool, optional\n            Whether or not to add dummy files to the structure. The default is False.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n\n        \"\"\"\n        if directory is None:\n            directory = Path(\".\")\n\n        # get prefix\n        if prefix_override is None:\n            if write_reference:\n                prefix_override = self.reference_grid.data_type.prefix\n            else:\n                prefix_override = self.charge_grid.data_type.prefix\n\n        temp_prefix = f\"{prefix_override}_temp\"\n        self.badelf_up.write_atom_volumes_sum(\n            atom_indices=atom_indices,\n            directory=directory,\n            write_reference=write_reference,\n            include_dummy_atoms=include_dummy_atoms,\n            prefix_override=temp_prefix,\n            **kwargs,\n        )\n        if not self.equal_spin:\n            # rename with \"up\" so we don't overwrite\n            os.rename(\n                directory / f\"{temp_prefix}_asum\",\n                directory / f\"{prefix_override}_asum_up\",\n            )\n            # Write the spin down file and change the name\n            self.badelf_down.write_atom_volumes_sum(\n                atom_indices=atom_indices,\n                directory=directory,\n                write_reference=write_reference,\n                include_dummy_atoms=include_dummy_atoms,\n                prefix_override=temp_prefix,\n                **kwargs,\n            )\n            os.rename(\n                directory / f\"{temp_prefix}_asum\",\n                directory / f\"{prefix_override}_asum_down\",\n            )\n\n    def write_species_volume(\n        self,\n        directory: str | Path = None,\n        species: str = FeatureType.bare_electron.dummy_species,\n        write_reference: bool = True,\n        output_format: str | Format = None,\n        include_dummy_atoms: bool = True,\n        prefix_override: str = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Writes the reference ELF or charge-density for all atoms of the given\n        species to the same file.\n\n        Parameters\n        ----------\n        directory : str | Path, optional\n            The directory to write the result to. The default is None.\n        species : str, optional\n            The species to write. The default is \"Le\" (the electrides).\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            The default is True.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n        include_dummy_atoms : bool, optional\n            Whether or not to include . The default is True.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n\n        \"\"\"\n\n        if directory is None:\n            directory = Path(\".\")\n\n        # get prefix\n        if prefix_override is None:\n            if write_reference:\n                prefix_override = self.reference_grid.data_type.prefix\n            else:\n                prefix_override = self.charge_grid.data_type.prefix\n\n        self.badelf_up.write_species_volume(\n            species=species,\n            directory=directory,\n            prefix_override=prefix_override,\n            write_reference=write_reference,\n            include_dummy_atoms=include_dummy_atoms,\n            **kwargs,\n        )\n        if not self.equal_spin:\n            # rename with \"up\" so we don't overwrite\n            os.rename(\n                directory / f\"{prefix_override}_{species}\",\n                directory / f\"{prefix_override}_{species}_up\",\n            )\n            # Write the spin down file and change the name\n            self.badelf_down.write_species_volume(\n                species=species,\n                directory=directory,\n                prefix_override=prefix_override,\n                write_reference=write_reference,\n                include_dummy_atoms=include_dummy_atoms,\n                **kwargs,\n            )\n            os.rename(\n                directory / f\"{prefix_override}_{species}\",\n                directory / f\"{prefix_override}_{species}_down\",\n            )\n\n    def get_atom_results_dataframe(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Collects a summary of results for the atoms in a pandas DataFrame.\n\n        Returns\n        -------\n        atoms_df : pd.DataFrame\n            A table summarizing the atomic basins.\n\n        \"\"\"\n        # Get atom results summary\n        atom_frac_coords = self.electride_structure.frac_coords\n        atoms_df = pd.DataFrame(\n            {\n                \"label\": self.electride_structure.labels,\n                \"x\": atom_frac_coords[:, 0],\n                \"y\": atom_frac_coords[:, 1],\n                \"z\": atom_frac_coords[:, 2],\n                \"charge\": self.charges,\n                \"volume\": self.volumes,\n                # \"surface_dist\": self.min_surface_distances,\n            }\n        )\n        return atoms_df\n\n    def write_atom_tsv(\n        self,\n        filepath: Path | str = \"badelf_atoms.tsv\",\n        write_spin: bool = False,\n    ):\n        \"\"\"\n        Writes a summary of atom results to .tsv files.\n\n        Parameters\n        ----------\n        filepath : str | Path, optional\n            The Path to write the results to. The default is \"badelf_atoms.tsv\".\n        write_spin : bool, optional\n            Whether or not to write the spin up/down tsv files as well\n\n        \"\"\"\n        if write_spin:\n            # write spin up and spin down summaries\n            filepath_up = filepath.parent / f\"{filepath.stem}_up{filepath.suffix}\"\n            filepath_down = filepath.parent / f\"{filepath.stem}_down{filepath.suffix}\"\n            self.badelf_up.write_atom_tsv(filepath=filepath_up)\n            self.badelf_down.write_atom_tsv(filepath=filepath_down)\n        filepath = Path(filepath)\n\n        # Get atom results summary\n        atoms_df = self.get_atom_results_dataframe()\n        formatted_atoms_df = atoms_df.copy()\n        numeric_cols = formatted_atoms_df.select_dtypes(include=\"number\").columns\n        formatted_atoms_df[numeric_cols] = formatted_atoms_df[numeric_cols].map(\n            lambda x: f\"{x:.5f}\"\n        )\n\n        # Determine max width per column including header\n        col_widths = {\n            col: max(len(col), formatted_atoms_df[col].map(len).max())\n            for col in atoms_df.columns\n        }\n\n        # Note what we're writing in log\n        logging.info(f\"Writing Atom Summary to {filepath}\")\n\n        # write output summaries\n        with open(filepath, \"w\") as f:\n            # Write header\n            header = \"\\t\".join(\n                f\"{col:&lt;{col_widths[col]}}\" for col in formatted_atoms_df.columns\n            )\n            f.write(header + \"\\n\")\n\n            # Write rows\n            for _, row in formatted_atoms_df.iterrows():\n                line = \"\\t\".join(\n                    f\"{val:&lt;{col_widths[col]}}\" for col, val in row.items()\n                )\n                f.write(line + \"\\n\")\n\n            f.write(\"\\n\")\n            # f.write(f\"Vacuum Charge:\\t\\t{self.vacuum_charge:.5f}\\n\")\n            # f.write(f\"Vacuum Volume:\\t\\t{self.vacuum_volume:.5f}\\n\")\n            f.write(f\"Total Electrons:\\t{self.total_electron_number:.5f}\\n\")\n</code></pre>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.charges","title":"<code>charges</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The charge associated with each atom and electride site in the system. If an electride site appears in both spin systems, the assigned charge is the sum.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.electride_dimensionality","title":"<code>electride_dimensionality</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The dimensionality of the electride volume at a value of 0 ELF. If the dimensionality differes between the spin-up/spin-down results, the largest dimensionality is selected.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.electride_formula","title":"<code>electride_formula</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>A string representation of the electride formula, rounding partial charge to the nearest integer.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.electride_structure","title":"<code>electride_structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The system's structure including dummy atoms representing electride sites. Electrides unique to the spin-up/spin-down systems will have xu or xd appended to the species name respectively. Electrides that exist in both will have nothing appended.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.electrides_per_formula","title":"<code>electrides_per_formula</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The number of electride electrons for the full structure formula.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.electrides_per_reduced_formula","title":"<code>electrides_per_reduced_formula</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The number of electrons in the reduced formula of the structure.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.labeled_structure","title":"<code>labeled_structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The system's structure including dummy atoms representing electride sites and covalent/metallic bonds. Features unique to the spin-up/spin-down systems will have xu or xd appended to the species name respectively. Features that exist in both will have nothing appended.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.nelectrides","title":"<code>nelectrides</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The number of electride sites (electride maxima) present in the system.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.species","title":"<code>species</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list[str]</code> <p>The species of each atom/dummy atom in the electride structure. Covalent and metallic features are not included.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.structure","title":"<code>structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The unlabeled structure representing the system, i.e. the structure with no dummy atoms.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.total_electron_number","title":"<code>total_electron_number</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total number of electrons in the system calculated from the spin-up and spin-down systems. If this does not match the true total electron number within reasonable floating point error, there is a major problem.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.total_volume","title":"<code>total_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total volume integrated in the system. This should match the volume of the structure. If it does not there may be a serious problem.</p> <p>This is the average of the two systems</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.vacuum_charge","title":"<code>vacuum_charge</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The charge assigned to the vacuum.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.vacuum_volume","title":"<code>vacuum_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total volume assigned to the vacuum. This is an average between the spin up and spin down values.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.volumes","title":"<code>volumes</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The volume associated with each atom and electride site in the system. The volume is taken as the average of the two systems, and may not have a physical meaning.</p>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.__init__","title":"<code>__init__(reference_grid, charge_grid, elf_labeler={}, **kwargs)</code>","text":"<p>An extension of the BadElfToolkit that performs separate calculations on the spin-up and spin-down systems.</p> <p>Parameters:</p> Name Type Description Default <code>reference_grid</code> <code>Grid</code> <p>A badelf app Grid like object used for partitioning the unit cell volume. Usually contains ELF.</p> required <code>charge_grid</code> <code>Grid</code> <p>A badelf app Grid like object used for summing charge. Usually contains charge density.</p> required <code>elf_labeler</code> <code>dict | SpinElfLabeler</code> <p>Keyword arguments to pass to the SpinElfLabeler class. This includes parameters controlling cutoffs for electrides. Alternatively, a SpinElfLabeler class can be passed directly. The default is {}.</p> <code>{}</code> <code>**kwargs</code> <code>dict</code> <p>Any additional keyword arguments to pass to the ElfLabeler class.</p> <code>{}</code> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>def __init__(\n    self,\n    reference_grid: Grid,\n    charge_grid: Grid,\n    elf_labeler: SpinElfLabeler | dict = {},\n    **kwargs,\n):\n    \"\"\"\n    An extension of the BadElfToolkit that performs separate calculations on\n    the spin-up and spin-down systems.\n\n    Parameters\n    ----------\n    reference_grid : Grid\n        A badelf app Grid like object used for partitioning the unit cell\n        volume. Usually contains ELF.\n    charge_grid : Grid\n        A badelf app Grid like object used for summing charge. Usually\n        contains charge density.\n    elf_labeler : dict | SpinElfLabeler, optional\n        Keyword arguments to pass to the SpinElfLabeler class. This includes\n        parameters controlling cutoffs for electrides. Alternatively, a\n        SpinElfLabeler class can be passed directly. The default is {}.\n    **kwargs : dict\n        Any additional keyword arguments to pass to the ElfLabeler class.\n\n    \"\"\"\n    # make sure our grids are spin polarized\n    assert (\n        reference_grid.is_spin_polarized\n    ), \"Provided grid is not spin polarized. Use the standard BadElfToolkit.\"\n\n    self.reference_grid = reference_grid\n    self.charge_grid = charge_grid\n\n    # If no labeled structures are provided, we want to use the spin elf\n    # labeler and link it to our badelf objects\n    # we want to attach a SpinElfLabeler to our badelf objects\n    if type(elf_labeler) is dict:\n        elf_labeler = SpinElfLabeler(\n            charge_grid=charge_grid, reference_grid=reference_grid, **elf_labeler\n        )\n\n    self.elf_labeler = elf_labeler\n    # link charge grids\n    self.reference_grid_up = elf_labeler.reference_grid_up\n    self.reference_grid_down = elf_labeler.reference_grid_down\n    self.charge_grid_up = elf_labeler.charge_grid_up\n    self.charge_grid_down = elf_labeler.charge_grid_down\n    self.equal_spin = elf_labeler.equal_spin\n    # link labelers\n    self.elf_labeler_up = elf_labeler.elf_labeler_up\n    self.elf_labeler_down = elf_labeler.elf_labeler_down\n\n    # Now check if we should run a spin polarized badelf calc or not\n    if not self.equal_spin:\n        self.badelf_up = Badelf(\n            reference_grid=self.reference_grid_up,\n            charge_grid=self.charge_grid_up,\n            elf_labeler=self.elf_labeler_up,\n            **kwargs,\n        )\n        self.badelf_down = Badelf(\n            reference_grid=self.reference_grid_down,\n            charge_grid=self.charge_grid_down,\n            elf_labeler=self.elf_labeler_down,\n            **kwargs,\n        )\n        self.badelf_up.spin_system = \"up\"\n        self.badelf_down.spin_system = \"down\"\n    else:\n        self.badelf_up = Badelf(\n            reference_grid=self.reference_grid_up,\n            charge_grid=self.charge_grid_up,\n            elf_labeler=self.elf_labeler_up,\n            **kwargs,\n        )\n        self.badelf_up.spin_system = \"half\"\n        self.badelf_down = self.badelf_up\n\n    # Properties that will be calculated and cached\n    self._electride_structure = None\n    self._labeled_structure = None\n    self._species = None\n\n    self._electride_dim = None\n\n    self._nelectrons = None\n    self._charges = None\n    self._volumes = None\n\n    self._min_surface_distances = None\n    self._avg_surface_distances = None\n\n    self._electrides_per_formula = None\n    self._electrides_per_reduced_formula = None\n\n    self._results_summary = None\n</code></pre>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.from_vasp","title":"<code>from_vasp(reference_file='ELFCAR', charge_file='CHGCAR', **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a SpinBadElfToolkit instance from the requested partitioning file and charge file.</p> <p>Parameters:</p> Name Type Description Default <code>reference_file</code> <code>str | Path</code> <p>The path to the file to use for partitioning. Must be a VASP CHGCAR or ELFCAR type file. The default is \"ELFCAR\".</p> <code>'ELFCAR'</code> <code>charge_file</code> <code>str | Path</code> <p>The path to the file containing the charge density. Must be a VASP CHGCAR or ELFCAR type file. The default is \"CHGCAR\".</p> <code>'CHGCAR'</code> <code>**kwargs</code> <code>any</code> <p>Additional keyword arguments for the SpinBadElfToolkit class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>SpinBadElfToolkit</code> <p>A SpinBadElfToolkit instance.</p> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>@classmethod\ndef from_vasp(\n    cls,\n    reference_file: str | Path = \"ELFCAR\",\n    charge_file: str | Path = \"CHGCAR\",\n    **kwargs,\n):\n    \"\"\"\n    Creates a SpinBadElfToolkit instance from the requested partitioning file\n    and charge file.\n\n    Parameters\n    ----------\n    reference_file : str | Path, optional\n        The path to the file to use for partitioning. Must be a VASP\n        CHGCAR or ELFCAR type file. The default is \"ELFCAR\".\n    charge_file : str | Path, optional\n        The path to the file containing the charge density. Must be a VASP\n        CHGCAR or ELFCAR type file. The default is \"CHGCAR\".\n    **kwargs : any\n        Additional keyword arguments for the SpinBadElfToolkit class.\n\n    Returns\n    -------\n    SpinBadElfToolkit\n        A SpinBadElfToolkit instance.\n    \"\"\"\n\n    reference_grid = Grid.from_vasp(reference_file, total_only=False)\n    charge_grid = Grid.from_vasp(charge_file, total_only=False)\n    return cls(reference_grid=reference_grid, charge_grid=charge_grid, **kwargs)\n</code></pre>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.get_atom_results_dataframe","title":"<code>get_atom_results_dataframe()</code>","text":"<p>Collects a summary of results for the atoms in a pandas DataFrame.</p> <p>Returns:</p> Name Type Description <code>atoms_df</code> <code>DataFrame</code> <p>A table summarizing the atomic basins.</p> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>def get_atom_results_dataframe(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Collects a summary of results for the atoms in a pandas DataFrame.\n\n    Returns\n    -------\n    atoms_df : pd.DataFrame\n        A table summarizing the atomic basins.\n\n    \"\"\"\n    # Get atom results summary\n    atom_frac_coords = self.electride_structure.frac_coords\n    atoms_df = pd.DataFrame(\n        {\n            \"label\": self.electride_structure.labels,\n            \"x\": atom_frac_coords[:, 0],\n            \"y\": atom_frac_coords[:, 1],\n            \"z\": atom_frac_coords[:, 2],\n            \"charge\": self.charges,\n            \"volume\": self.volumes,\n            # \"surface_dist\": self.min_surface_distances,\n        }\n    )\n    return atoms_df\n</code></pre>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.get_oxidation_from_potcar","title":"<code>get_oxidation_from_potcar(potcar_path='POTCAR')</code>","text":"<p>Calculates the oxidation state of each atom/electride using the electron counts of the neutral atoms provided in a POTCAR.</p> <p>Parameters:</p> Name Type Description Default <code>potcar_path</code> <code>Path | str</code> <p>The Path to the POTCAR file. The default is \"POTCAR\".</p> <code>'POTCAR'</code> <p>Returns:</p> Name Type Description <code>oxidation</code> <code>list</code> <p>The oxidation states of each atom/electride.</p> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>def get_oxidation_from_potcar(self, potcar_path: Path | str = \"POTCAR\"):\n    \"\"\"\n    Calculates the oxidation state of each atom/electride using the\n    electron counts of the neutral atoms provided in a POTCAR.\n\n    Parameters\n    ----------\n    potcar_path : Path | str, optional\n        The Path to the POTCAR file. The default is \"POTCAR\".\n\n    Returns\n    -------\n    oxidation : list\n        The oxidation states of each atom/electride.\n\n    \"\"\"\n    # Check if POTCAR exists in path. If not, throw warning\n    potcar_path = Path(potcar_path)\n    if not potcar_path.exists():\n        logging.warning(\n            \"No POTCAR file found in the requested directory. Oxidation states cannot be calculated\"\n        )\n        return\n    # get POTCAR info\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        potcars = Potcar.from_file(potcar_path)\n    nelectron_data = {}\n    # the result is a list because there can be multiple element potcars\n    # in the file (e.g. for NaCl, POTCAR = POTCAR_Na + POTCAR_Cl)\n    for potcar in potcars:\n        nelectron_data[potcar.element] = potcar.nelectrons\n    # get valence electrons for each site in the structure\n    valence = np.zeros(len(self.electride_structure), dtype=np.float64)\n    for i, site in enumerate(self.structure):\n        valence[i] = nelectron_data[site.specie.symbol]\n    # subtract charges from valence to get oxidation\n    oxidation = valence - self.charges\n    return oxidation\n</code></pre>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.to_dict","title":"<code>to_dict(potcar_path='POTCAR', use_json=True)</code>","text":"<p>Gets a dictionary summary of the BadELF analysis.</p> <p>Parameters:</p> Name Type Description Default <code>potcar_path</code> <code>Path | str</code> <p>The Path to a POTCAR file. This must be provided for oxidation states to be calculated, and they will be None otherwise. The default is \"POTCAR\".</p> <code>'POTCAR'</code> <code>use_json</code> <code>bool</code> <p>Convert all entries to JSONable data types. The default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A summary of the BadELF analysis in dictionary form.</p> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>def to_dict(self, potcar_path: Path | str = \"POTCAR\", use_json: bool = True):\n    \"\"\"\n\n    Gets a dictionary summary of the BadELF analysis.\n\n    Parameters\n    ----------\n    potcar_path : Path | str, optional\n        The Path to a POTCAR file. This must be provided for oxidation states\n        to be calculated, and they will be None otherwise. The default is \"POTCAR\".\n    use_json : bool, optional\n        Convert all entries to JSONable data types. The default is True.\n\n    Returns\n    -------\n    dict\n        A summary of the BadELF analysis in dictionary form.\n\n    \"\"\"\n    results = {}\n\n    results[\"method_kwargs\"] = self.badelf_up.to_dict()[\"method_kwargs\"]\n\n    results[\"oxidation_states\"] = self.get_oxidation_from_potcar(potcar_path)\n\n    for result in [\n        \"spin_system\",\n        \"species\",\n        \"structure\",\n        \"labeled_structure\",\n        \"electride_structure\",\n        \"nelectrides\",\n        \"electride_dimensionality\",\n        \"charges\",\n        \"volumes\",\n        \"electride_formula\",\n        \"electrides_per_formula\",\n        \"electrides_per_reduced_formula\",\n        \"total_electron_number\",\n        \"total_volume\",\n        \"vacuum_charge\",\n        \"vacuum_volume\",\n    ]:\n        results[result] = getattr(self, result, None)\n    if use_json:\n        # get serializable versions of each attribute\n        for key in [\"structure\", \"labeled_structure\", \"electride_structure\"]:\n            results[key] = results[key].to(fmt=\"POSCAR\")\n        for key in [\"charges\", \"volumes\", \"oxidation_states\"]:\n            if results[key] is None:\n                continue\n            results[key] = results[key].tolist()\n    return results\n</code></pre>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.to_json","title":"<code>to_json(**kwargs)</code>","text":"<p>Creates a JSON string representation of the results, typically for writing results to file.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Keyword arguments for the to_dict method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the BadELF results.</p> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>def to_json(self, **kwargs):\n    \"\"\"\n    Creates a JSON string representation of the results, typically for writing\n    results to file.\n\n    Parameters\n    ----------\n    **kwargs : dict\n        Keyword arguments for the to_dict method.\n\n    Returns\n    -------\n    str\n        A JSON string representation of the BadELF results.\n\n    \"\"\"\n    return json.dumps(self.to_dict(use_json=True, **kwargs))\n</code></pre>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.write_all_atom_volumes","title":"<code>write_all_atom_volumes(directory=None, write_reference=True, include_dummy_atoms=True, output_format=None, prefix_override=None, **kwargs)</code>","text":"<p>Writes the reference ELF or charge-density for the each atom to separate files. Electrides found during the calculation are appended to the end of the structure. Note that non-atomic features of the same index in different spin systems may not correspond to the same feature.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The directory to write the result to. The default is None.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. The default is True.</p> <code>True</code> <code>include_dummy_atoms</code> <code>bool</code> <p>Whether or not to include . The default is True.</p> <code>True</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>def write_all_atom_volumes(\n    self,\n    directory: str | Path = None,\n    write_reference: bool = True,\n    include_dummy_atoms: bool = True,\n    output_format: str | Format = None,\n    prefix_override: str = None,\n    **kwargs,\n):\n    \"\"\"\n    Writes the reference ELF or charge-density for the each atom to\n    separate files. Electrides found during the calculation are appended to\n    the end of the structure. Note that non-atomic features of the same index\n    in different spin systems may not correspond to the same feature.\n\n    Parameters\n    ----------\n    directory : str | Path, optional\n        The directory to write the result to. The default is None.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        The default is True.\n    include_dummy_atoms : bool, optional\n        Whether or not to include . The default is True.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n\n    \"\"\"\n\n    if directory is None:\n        directory = Path(\".\")\n\n    # get prefix\n    if prefix_override is None:\n        if write_reference:\n            prefix_override = self.reference_grid.data_type.prefix\n        else:\n            prefix_override = self.charge_grid.data_type.prefix\n\n    # temporarily update prefix override to avoid overwriting\n    if self.equal_spin:\n        temp_prefix = f\"{prefix_override}_temp\"\n    else:\n        temp_prefix = prefix_override\n\n    for atom_index in range(len(self.electride_structure)):\n        self.badelf_up.write_atom_volumes(\n            atom_indices=[atom_index],\n            directory=directory,\n            write_reference=write_reference,\n            include_dummy_atoms=include_dummy_atoms,\n            prefix_override=temp_prefix,\n            **kwargs,\n        )\n        if not self.equal_spin:\n            # rename with \"up\" so we don't overwrite\n            os.rename(\n                directory / f\"{temp_prefix}_a{atom_index}\",\n                directory / f\"{prefix_override}_a{atom_index}_up\",\n            )\n            # Write the spin down file and change the name\n            self.badelf_down.write_atom_volumes(\n                atom_indices=[atom_index],\n                directory=directory,\n                write_reference=write_reference,\n                include_dummy_atoms=include_dummy_atoms,\n                prefix_override=temp_prefix,\n                **kwargs,\n            )\n            os.rename(\n                directory / f\"{temp_prefix}_a{atom_index}\",\n                directory / f\"{prefix_override}_a{atom_index}_down\",\n            )\n</code></pre>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.write_atom_tsv","title":"<code>write_atom_tsv(filepath='badelf_atoms.tsv', write_spin=False)</code>","text":"<p>Writes a summary of atom results to .tsv files.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | Path</code> <p>The Path to write the results to. The default is \"badelf_atoms.tsv\".</p> <code>'badelf_atoms.tsv'</code> <code>write_spin</code> <code>bool</code> <p>Whether or not to write the spin up/down tsv files as well</p> <code>False</code> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>def write_atom_tsv(\n    self,\n    filepath: Path | str = \"badelf_atoms.tsv\",\n    write_spin: bool = False,\n):\n    \"\"\"\n    Writes a summary of atom results to .tsv files.\n\n    Parameters\n    ----------\n    filepath : str | Path, optional\n        The Path to write the results to. The default is \"badelf_atoms.tsv\".\n    write_spin : bool, optional\n        Whether or not to write the spin up/down tsv files as well\n\n    \"\"\"\n    if write_spin:\n        # write spin up and spin down summaries\n        filepath_up = filepath.parent / f\"{filepath.stem}_up{filepath.suffix}\"\n        filepath_down = filepath.parent / f\"{filepath.stem}_down{filepath.suffix}\"\n        self.badelf_up.write_atom_tsv(filepath=filepath_up)\n        self.badelf_down.write_atom_tsv(filepath=filepath_down)\n    filepath = Path(filepath)\n\n    # Get atom results summary\n    atoms_df = self.get_atom_results_dataframe()\n    formatted_atoms_df = atoms_df.copy()\n    numeric_cols = formatted_atoms_df.select_dtypes(include=\"number\").columns\n    formatted_atoms_df[numeric_cols] = formatted_atoms_df[numeric_cols].map(\n        lambda x: f\"{x:.5f}\"\n    )\n\n    # Determine max width per column including header\n    col_widths = {\n        col: max(len(col), formatted_atoms_df[col].map(len).max())\n        for col in atoms_df.columns\n    }\n\n    # Note what we're writing in log\n    logging.info(f\"Writing Atom Summary to {filepath}\")\n\n    # write output summaries\n    with open(filepath, \"w\") as f:\n        # Write header\n        header = \"\\t\".join(\n            f\"{col:&lt;{col_widths[col]}}\" for col in formatted_atoms_df.columns\n        )\n        f.write(header + \"\\n\")\n\n        # Write rows\n        for _, row in formatted_atoms_df.iterrows():\n            line = \"\\t\".join(\n                f\"{val:&lt;{col_widths[col]}}\" for col, val in row.items()\n            )\n            f.write(line + \"\\n\")\n\n        f.write(\"\\n\")\n        # f.write(f\"Vacuum Charge:\\t\\t{self.vacuum_charge:.5f}\\n\")\n        # f.write(f\"Vacuum Volume:\\t\\t{self.vacuum_volume:.5f}\\n\")\n        f.write(f\"Total Electrons:\\t{self.total_electron_number:.5f}\\n\")\n</code></pre>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.write_atom_volumes","title":"<code>write_atom_volumes(atom_indices, directory=None, write_reference=True, include_dummy_atoms=True, output_format=None, prefix_override=None, **kwargs)</code>","text":"<p>Writes the reference ELF or charge-density for the given atoms to separate files. Electrides found during the calculation are appended to the end of the structure. Note that non-atomic features of the same index in different spin systems may not correspond to the same feature.</p> <p>Parameters:</p> Name Type Description Default <code>atom_indices</code> <code>NDArray</code> <p>The list of atom/electride indices to write</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the result to. The default is None.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. The default is True.</p> <code>True</code> <code>include_dummy_atoms</code> <code>bool</code> <p>Whether or not to include . The default is True.</p> <code>True</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>def write_atom_volumes(\n    self,\n    atom_indices: NDArray,\n    directory: str | Path = None,\n    write_reference: bool = True,\n    include_dummy_atoms: bool = True,\n    output_format: str | Format = None,\n    prefix_override: str = None,\n    **kwargs,\n):\n    \"\"\"\n    Writes the reference ELF or charge-density for the given atoms to\n    separate files. Electrides found during the calculation are appended to\n    the end of the structure. Note that non-atomic features of the same index\n    in different spin systems may not correspond to the same feature.\n\n    Parameters\n    ----------\n    atom_indices : NDArray\n        The list of atom/electride indices to write\n    directory : str | Path, optional\n        The directory to write the result to. The default is None.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        The default is True.\n    include_dummy_atoms : bool, optional\n        Whether or not to include . The default is True.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n\n    \"\"\"\n\n    if directory is None:\n        directory = Path(\".\")\n\n    # get prefix\n    if prefix_override is None:\n        if write_reference:\n            prefix_override = self.reference_grid.data_type.prefix\n        else:\n            prefix_override = self.charge_grid.data_type.prefix\n\n    # temporarily update prefix override to avoid overwriting\n    if self.equal_spin:\n        temp_prefix = f\"{prefix_override}_temp\"\n    else:\n        temp_prefix = prefix_override\n\n    for atom_index in atom_indices:\n        self.badelf_up.write_atom_volumes(\n            atom_indices=[atom_index],\n            directory=directory,\n            prefix_override=temp_prefix,\n            include_dummy_atoms=include_dummy_atoms,\n            write_reference=write_reference,\n            **kwargs,\n        )\n        if not self.equal_spin:\n            # rename with \"up\" so we don't overwrite\n            os.rename(\n                directory / f\"{temp_prefix}_a{atom_index}\",\n                directory / f\"{prefix_override}_a{atom_index}_up\",\n            )\n            # Write the spin down file and change the name\n            self.badelf_down.write_atom_volumes(\n                atom_indices=[atom_index],\n                directory=directory,\n                prefix_override=temp_prefix,\n                include_dummy_atoms=include_dummy_atoms,\n                write_reference=write_reference,\n                **kwargs,\n            )\n            os.rename(\n                directory / f\"{temp_prefix}_a{atom_index}\",\n                directory / f\"{prefix_override}_a{atom_index}_down\",\n            )\n</code></pre>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.write_atom_volumes_sum","title":"<code>write_atom_volumes_sum(atom_indices, directory=None, write_reference=True, output_format=None, include_dummy_atoms=True, prefix_override=None, **kwargs)</code>","text":"<p>Writes the reference ELF or charge-density for the the union of the given atoms to a single file. Note that non-atomic features of the same index in different spin systems may not correspond to the same feature.</p> <p>Parameters:</p> Name Type Description Default <code>atom_indices</code> <code>int</code> <p>The index of the atom/electride to write for.</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is True.</p> <code>True</code> <code>include_dummy_atoms</code> <code>bool</code> <p>Whether or not to add dummy files to the structure. The default is False.</p> <code>True</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>def write_atom_volumes_sum(\n    self,\n    atom_indices: NDArray,\n    directory: str | Path = None,\n    write_reference: bool = True,\n    output_format: str | Format = None,\n    include_dummy_atoms: bool = True,\n    prefix_override: str = None,\n    **kwargs,\n):\n    \"\"\"\n\n    Writes the reference ELF or charge-density for the the union of the\n    given atoms to a single file. Note that non-atomic features of the same index\n    in different spin systems may not correspond to the same feature.\n\n    Parameters\n    ----------\n    atom_indices : int\n        The index of the atom/electride to write for.\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is True.\n    include_dummy_atoms : bool, optional\n        Whether or not to add dummy files to the structure. The default is False.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n\n    \"\"\"\n    if directory is None:\n        directory = Path(\".\")\n\n    # get prefix\n    if prefix_override is None:\n        if write_reference:\n            prefix_override = self.reference_grid.data_type.prefix\n        else:\n            prefix_override = self.charge_grid.data_type.prefix\n\n    temp_prefix = f\"{prefix_override}_temp\"\n    self.badelf_up.write_atom_volumes_sum(\n        atom_indices=atom_indices,\n        directory=directory,\n        write_reference=write_reference,\n        include_dummy_atoms=include_dummy_atoms,\n        prefix_override=temp_prefix,\n        **kwargs,\n    )\n    if not self.equal_spin:\n        # rename with \"up\" so we don't overwrite\n        os.rename(\n            directory / f\"{temp_prefix}_asum\",\n            directory / f\"{prefix_override}_asum_up\",\n        )\n        # Write the spin down file and change the name\n        self.badelf_down.write_atom_volumes_sum(\n            atom_indices=atom_indices,\n            directory=directory,\n            write_reference=write_reference,\n            include_dummy_atoms=include_dummy_atoms,\n            prefix_override=temp_prefix,\n            **kwargs,\n        )\n        os.rename(\n            directory / f\"{temp_prefix}_asum\",\n            directory / f\"{prefix_override}_asum_down\",\n        )\n</code></pre>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.write_json","title":"<code>write_json(filepath='badelf.json', write_spin=False, **kwargs)</code>","text":"<p>Writes results of the analysis to file in a JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Path | str</code> <p>The Path to write the results to. The default is \"badelf_results_summary.json\".</p> <code>'badelf.json'</code> <code>write_spin</code> <code>bool</code> <p>Whether or not to write the spin up/down summary jsons as well</p> <code>False</code> <code>**kwargs</code> <code>dict</code> <p>keyword arguments for the to_dict method.</p> <code>{}</code> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>def write_json(\n    self, filepath: Path | str = \"badelf.json\", write_spin: bool = False, **kwargs\n):\n    \"\"\"\n    Writes results of the analysis to file in a JSON format.\n\n    Parameters\n    ----------\n    filepath : Path | str, optional\n        The Path to write the results to. The default is \"badelf_results_summary.json\".\n    write_spin : bool, optional\n        Whether or not to write the spin up/down summary jsons as well\n    **kwargs : dict\n        keyword arguments for the to_dict method.\n\n    \"\"\"\n    filepath = Path(filepath)\n\n    # write total summary\n    with open(filepath, \"w\") as json_file:\n        json.dump(self.to_dict(use_json=True, **kwargs), json_file, indent=4)\n    # write spin up and spin down summaries\n    if write_spin:\n        filepath_up = filepath.parent / f\"{filepath.stem}_up{filepath.suffix}\"\n        filepath_down = filepath.parent / f\"{filepath.stem}_down{filepath.suffix}\"\n        self.badelf_up.write_json(filepath=filepath_up)\n        self.badelf_down.write_json(filepath=filepath_down)\n</code></pre>"},{"location":"api_reference/core/badelf_spin/#src.baderkit.core.badelf.SpinBadelf.write_species_volume","title":"<code>write_species_volume(directory=None, species=FeatureType.bare_electron.dummy_species, write_reference=True, output_format=None, include_dummy_atoms=True, prefix_override=None, **kwargs)</code>","text":"<p>Writes the reference ELF or charge-density for all atoms of the given species to the same file.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The directory to write the result to. The default is None.</p> <code>None</code> <code>species</code> <code>str</code> <p>The species to write. The default is \"Le\" (the electrides).</p> <code>dummy_species</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. The default is True.</p> <code>True</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <code>include_dummy_atoms</code> <code>bool</code> <p>Whether or not to include . The default is True.</p> <code>True</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> Source code in <code>src/baderkit/core/badelf/badelf_spin.py</code> <pre><code>def write_species_volume(\n    self,\n    directory: str | Path = None,\n    species: str = FeatureType.bare_electron.dummy_species,\n    write_reference: bool = True,\n    output_format: str | Format = None,\n    include_dummy_atoms: bool = True,\n    prefix_override: str = None,\n    **kwargs,\n):\n    \"\"\"\n    Writes the reference ELF or charge-density for all atoms of the given\n    species to the same file.\n\n    Parameters\n    ----------\n    directory : str | Path, optional\n        The directory to write the result to. The default is None.\n    species : str, optional\n        The species to write. The default is \"Le\" (the electrides).\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        The default is True.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n    include_dummy_atoms : bool, optional\n        Whether or not to include . The default is True.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n\n    \"\"\"\n\n    if directory is None:\n        directory = Path(\".\")\n\n    # get prefix\n    if prefix_override is None:\n        if write_reference:\n            prefix_override = self.reference_grid.data_type.prefix\n        else:\n            prefix_override = self.charge_grid.data_type.prefix\n\n    self.badelf_up.write_species_volume(\n        species=species,\n        directory=directory,\n        prefix_override=prefix_override,\n        write_reference=write_reference,\n        include_dummy_atoms=include_dummy_atoms,\n        **kwargs,\n    )\n    if not self.equal_spin:\n        # rename with \"up\" so we don't overwrite\n        os.rename(\n            directory / f\"{prefix_override}_{species}\",\n            directory / f\"{prefix_override}_{species}_up\",\n        )\n        # Write the spin down file and change the name\n        self.badelf_down.write_species_volume(\n            species=species,\n            directory=directory,\n            prefix_override=prefix_override,\n            write_reference=write_reference,\n            include_dummy_atoms=include_dummy_atoms,\n            **kwargs,\n        )\n        os.rename(\n            directory / f\"{prefix_override}_{species}\",\n            directory / f\"{prefix_override}_{species}_down\",\n        )\n</code></pre>"},{"location":"api_reference/core/bader/","title":"Bader","text":"<p>Class for running Bader analysis on a regular grid. For information on each method, see our docs</p> <p>Parameters:</p> Name Type Description Default <code>charge_grid</code> <code>Grid</code> <p>A Grid object with the charge density that will be integrated.</p> required <code>reference_grid</code> <code>Grid | None</code> <p>A Grid object whose values will be used to construct the basins. If None, defaults to the charge_grid.</p> <code>None</code> <code>method</code> <code>str | Method</code> <p>The algorithm to use for generating bader basins.</p> <code>weight</code> <code>vacuum_tol</code> <code>float | bool</code> <p>If a float is provided, this is the value below which a point will be considered part of the vacuum. If a bool is provided, no vacuum will be used on False, and the default tolerance will be used on True.</p> <code>0.001</code> <code>basin_tol</code> <code>float</code> <p>The value below which a basin will not be considered significant. This is used only used to avoid writing out data that is likely not valuable.</p> <code>0.001</code> <code>use_reference_vacuum</code> <code>bool</code> <p>Whether or not to use the reference file to determine regions of vacuum (low charge density). This should generally be set to True unless the ELF is being used as the reference. The default is True.</p> <code>True</code> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>class Bader:\n    \"\"\"\n    Class for running Bader analysis on a regular grid. For information on each\n    method, see our [docs](https://sweav02.github.io/baderkit/)\n\n    Parameters\n    ----------\n    charge_grid : Grid\n        A Grid object with the charge density that will be integrated.\n    reference_grid : Grid | None\n        A Grid object whose values will be used to construct the basins. If\n        None, defaults to the charge_grid.\n    method : str | Method, optional\n        The algorithm to use for generating bader basins.\n    vacuum_tol : float | bool, optional\n        If a float is provided, this is the value below which a point will\n        be considered part of the vacuum. If a bool is provided, no vacuum\n        will be used on False, and the default tolerance will be used on True.\n    basin_tol : float, optional\n        The value below which a basin will not be considered significant. This\n        is used only used to avoid writing out data that is likely not valuable.\n    use_reference_vacuum : bool, optional\n        Whether or not to use the reference file to determine regions of vacuum\n        (low charge density). This should generally be set to True unless the\n        ELF is being used as the reference. The default is True.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        charge_grid: Grid,\n        reference_grid: Grid | None = None,\n        method: str | Method = Method.weight,\n        vacuum_tol: float | bool = 1.0e-3,\n        # normalize_vacuum: bool | None = None,\n        basin_tol: float = 1.0e-3,\n        use_reference_vacuum: bool = True,\n        **kwargs,\n    ):\n\n        # ensure th method is valid\n        valid_methods = [m.value for m in Method]\n        if isinstance(method, Method):\n            self._method = method\n        elif method in valid_methods:\n            self._method = Method(method)\n        else:\n            raise ValueError(\n                f\"Invalid method '{method}'. Available options are: {valid_methods}\"\n            )\n\n        self._charge_grid = charge_grid\n\n        # if no reference is provided, use the base charge grid\n        if reference_grid is None:\n            reference_grid = charge_grid.copy()\n        self._reference_grid = reference_grid\n\n        self._use_reference_vacuum = use_reference_vacuum\n\n        # if vacuum tolerance is True, set it to the same default as above\n        if vacuum_tol is True:\n            self._vacuum_tol = 1.0e-3\n        else:\n            self._vacuum_tol = vacuum_tol\n        self._basin_tol = basin_tol\n\n        # set hidden class variables. This allows us to cache properties and\n        # still be able to recalculate them if needed, though that should only\n        # be done by advanced users\n        self._reset_properties()\n\n        # whether or not to use overdetermined gradients in neargrid methods.\n        self._use_overdetermined = False\n\n    ###########################################################################\n    # Set Properties\n    ###########################################################################\n    def _reset_properties(\n        self,\n        include_properties: list[str] = None,\n        exclude_properties: list[str] = [],\n    ):\n        # if include properties is not provided, we wnat to reset everything\n        if include_properties is None:\n            include_properties = [\n                # assigned by run_bader\n                \"basin_labels\",\n                \"basin_maxima_frac\",\n                \"basin_maxima_charge_values\",\n                \"basin_maxima_ref_values\",\n                \"basin_maxima_vox\",\n                \"basin_charges\",\n                \"basin_volumes\",\n                \"vacuum_charge\",\n                \"vacuum_volume\",\n                \"significant_basins\",\n                \"vacuum_mask\",\n                \"num_vacuum\",\n                # Assigned by calling the property\n                \"basin_min_surface_distances\",\n                \"basin_avg_surface_distances\",\n                \"basin_edges\",\n                \"atom_edges\",\n                \"structure\",\n                # Assigned by run_atom_assignment\n                \"basin_atoms\",\n                \"basin_atom_dists\",\n                \"atom_labels\",\n                \"atom_charges\",\n                \"atom_volumes\",\n                \"atom_min_surface_distances\",\n                \"atom_avg_surface_distances\",\n            ]\n        # get our final list of properties\n        reset_properties = [\n            i for i in include_properties if i not in exclude_properties\n        ]\n        # set corresponding hidden variable to None\n        for prop in reset_properties:\n            setattr(self, f\"_{prop}\", None)\n\n    @property\n    def structure(self) -&gt; Structure:\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The pymatgen structure basins are assigned to.\n\n        \"\"\"\n        if self._structure is None:\n            self._structure = self.reference_grid.structure.copy()\n            self._structure.relabel_sites(ignore_uniq=True)\n        return self._structure\n\n    @property\n    def species(self) -&gt; list[str]:\n        \"\"\"\n\n        Returns\n        -------\n        list[str]\n            The species of each atom/dummy atom in the electride structure. Covalent\n            and metallic features are not included.\n\n        \"\"\"\n        return [i.specie.symbol for i in self.structure]\n\n    @property\n    def charge_grid(self) -&gt; Grid:\n        \"\"\"\n\n        Returns\n        -------\n        Grid\n            A Grid object with the charge density that will be integrated.\n\n        \"\"\"\n        return self._charge_grid\n\n    @charge_grid.setter\n    def charge_grid(self, value: Grid):\n        self._charge_grid = value\n        self._reset_properties()\n\n    @property\n    def reference_grid(self) -&gt; Grid:\n        \"\"\"\n\n        Returns\n        -------\n        Grid\n            A grid object whose values will be used to construct the basins.\n\n        \"\"\"\n        return self._reference_grid\n\n    @reference_grid.setter\n    def reference_grid(self, value: Grid):\n        self._reference_grid = value\n        self._reset_properties()\n\n    @property\n    def method(self) -&gt; str:\n        \"\"\"\n\n        Returns\n        -------\n        str\n            The algorithm to use for generating bader basins. If None, defaults\n            to neargrid.\n\n        \"\"\"\n        return self._method\n\n    @method.setter\n    def method(self, value: str | Method):\n        # Support both Method instances and their string values\n        valid_values = [m.value for m in Method]\n        if isinstance(value, Method):\n            self._method = value\n        elif value in valid_values:\n            self._method = Method(value)\n        else:\n            raise ValueError(\n                f\"Invalid method '{value}'. Available options are: {valid_values}\"\n            )\n        self._reset_properties(exclude_properties=[\"vacuum_mask\", \"num_vacuum\"])\n\n    @property\n    def vacuum_tol(self) -&gt; float | bool:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The value below which a point will be considered part of the vacuum.\n            The default is 0.001.\n\n        \"\"\"\n        return self._vacuum_tol\n\n    @vacuum_tol.setter\n    def vacuum_tol(self, value: float | bool):\n        self._vacuum_tol = value\n        self._reset_properties()\n        # TODO: only reset everything if the vacuum actually changes\n\n    @property\n    def use_reference_vacuum(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            Whether or not to use the reference file to determine regions of vacuum\n            (low charge density). This should generally be set to True unless the\n            ELF is being used as the reference. The default is True.\n\n        \"\"\"\n        return self._use_reference_vacuum\n\n    @use_reference_vacuum.setter\n    def use_reference_vacuum(self, value: bool) -&gt; bool:\n        self._use_reference_vacuum = value\n        self._reset_properties()\n        # TODO: only reset everything if the vacuum actually changes\n\n    @property\n    def basin_tol(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The value below which a basin will not be considered significant. This\n            is used to avoid writing out data that is likely not valuable.\n            The default is 0.001.\n\n        \"\"\"\n        return self._basin_tol\n\n    @basin_tol.setter\n    def basin_tol(self, value: float):\n        self._basin_tol = value\n        self._reset_properties(include_properties=[\"significant_basins\"])\n\n    ###########################################################################\n    # Calculated Properties\n    ###########################################################################\n\n    @property\n    def basin_labels(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            A 3D array of the same shape as the reference grid with entries\n            representing the basin the voxel belongs to. Note that for some\n            methods (e.g. weight) the voxels have weights for each basin.\n            These will be stored in the basin_weights property.\n\n        \"\"\"\n        if self._basin_labels is None:\n            self.run_bader()\n        return self._basin_labels\n\n    @property\n    def basin_maxima_frac(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The fractional coordinates of each attractor.\n\n        \"\"\"\n        if self._basin_maxima_frac is None:\n            self.run_bader()\n        return self._basin_maxima_frac\n\n    @property\n    def basin_maxima_charge_values(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The charge data value at each maximum. If the maximum is\n            off grid, this value will be interpolated.\n\n        \"\"\"\n        if self._basin_maxima_charge_values is None:\n            self._basin_maxima_charge_values = self.charge_grid.values_at(\n                self.basin_maxima_frac\n            )\n        return self._basin_maxima_charge_values.round(10)\n\n    @property\n    def basin_maxima_ref_values(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The reference data value at each maximum. If the maximum is\n            off grid, this value will be interpolated.\n\n        \"\"\"\n        if self._basin_maxima_ref_values is None:\n            # we get these values during each bader method anyways, so\n            # we run this here.\n            self.run_bader()\n        return self._basin_maxima_ref_values.round(10)\n\n    @property\n    def basin_maxima_vox(self) -&gt; NDArray[int]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[int]\n            The voxel coordinates of each attractor. There may be more of these\n            than the fractional coordinates, as some maxima sit exactly between\n            several voxels.\n\n        \"\"\"\n        if self._basin_maxima_vox is None:\n            self.run_bader()\n        return self._basin_maxima_vox\n\n    @property\n    def basin_charges(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The charges assigned to each attractor.\n\n        \"\"\"\n        if self._basin_charges is None:\n            self.run_bader()\n        return self._basin_charges.round(10)\n\n    @property\n    def basin_volumes(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The volume assigned to each attractor.\n\n        \"\"\"\n        if self._basin_volumes is None:\n            self.run_bader()\n        return self._basin_volumes.round(10)\n\n    @property\n    def basin_min_surface_distances(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The distance from each basin maxima to the nearest point on\n            the basins surface\n\n        \"\"\"\n        if self._basin_min_surface_distances is None:\n            self._get_basin_surface_distances()\n        return self._basin_min_surface_distances.round(10)\n\n    @property\n    def basin_avg_surface_distances(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The avg distance from each basin maxima to the edges of its basin\n\n        \"\"\"\n        if self._basin_avg_surface_distances is None:\n            self._get_basin_surface_distances()\n        return self._basin_avg_surface_distances.round(10)\n\n    @property\n    def basin_atoms(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The atom index of each basin is assigned to.\n\n        \"\"\"\n        if self._basin_atoms is None:\n            self.run_atom_assignment()\n        return self._basin_atoms\n\n    @property\n    def basin_atom_dists(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The distance from each attractor to the nearest atom\n\n        \"\"\"\n        if self._basin_atom_dists is None:\n            self.run_atom_assignment()\n        return self._basin_atom_dists.round(10)\n\n    @property\n    def significant_basins(self) -&gt; NDArray[bool]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[bool]\n            A 1D mask with an entry for each basin that is True where basins\n            are significant.\n\n        \"\"\"\n        if self._significant_basins is None:\n            self._significant_basins = self.basin_charges &gt; self.basin_tol\n        return self._significant_basins\n\n    @property\n    def atom_labels(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            A 3D array of the same shape as the reference grid with entries\n            representing the atoms the voxel belongs to.\n\n            Note that for some methods (e.g. weight) some voxels have fractional\n            assignments for each basin and this will not represent exactly how\n            charges are assigned.\n\n        \"\"\"\n        if self._atom_labels is None:\n            self.run_atom_assignment()\n        return self._atom_labels\n\n    @property\n    def atom_charges(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The charge assigned to each atom\n\n        \"\"\"\n        if self._atom_charges is None:\n            self.run_atom_assignment()\n        return self._atom_charges.round(10)\n\n    @property\n    def atom_volumes(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The volume assigned to each atom\n\n        \"\"\"\n        if self._atom_volumes is None:\n            self.run_atom_assignment()\n        return self._atom_volumes.round(10)\n\n    @property\n    def atom_min_surface_distances(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The distance from each atom to the nearest point on the atoms surface.\n\n        \"\"\"\n        if self._atom_min_surface_distances is None:\n            self._get_atom_surface_distances()\n        return self._atom_min_surface_distances.round(10)\n\n    @property\n    def atom_avg_surface_distances(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The avg distance from each atom to the edges of its basin\n\n        \"\"\"\n        if self._atom_avg_surface_distances is None:\n            self._get_basin_surface_distances()\n        return self._atom_avg_surface_distances.round(10)\n\n    @property\n    def basin_edges(self) -&gt; NDArray[np.bool_]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[np.bool_]\n            A mask with the same shape as the input grids that is True at points\n            on basin edges.\n\n        \"\"\"\n        if self._basin_edges is None:\n            self._basin_edges = get_edges(\n                labeled_array=self.basin_labels,\n                vacuum_mask=np.zeros(self.basin_labels.shape, dtype=np.bool_),\n                neighbor_transforms=self.reference_grid.point_neighbor_transforms[0],\n            )\n        return self._basin_edges\n\n    @property\n    def atom_edges(self) -&gt; NDArray[np.bool_]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[np.bool_]\n            A mask with the same shape as the input grids that is True at points\n            on atom edges.\n\n        \"\"\"\n        if self._atom_edges is None:\n            self._atom_edges = get_edges(\n                labeled_array=self.atom_labels,\n                vacuum_mask=np.zeros(self.atom_labels.shape, dtype=np.bool_),\n                neighbor_transforms=self.reference_grid.point_neighbor_transforms[0],\n            )\n        return self._atom_edges\n\n    @property\n    def vacuum_charge(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The charge assigned to the vacuum.\n\n        \"\"\"\n        if self._vacuum_charge is None:\n            self.run_bader()\n        return round(self._vacuum_charge, 10)\n\n    @property\n    def vacuum_volume(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total volume assigned to the vacuum.\n\n        \"\"\"\n        if self._vacuum_volume is None:\n            self.run_bader()\n        return round(self._vacuum_volume, 10)\n\n    @property\n    def vacuum_mask(self) -&gt; NDArray[bool]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[bool]\n            A mask representing the voxels that belong to the vacuum.\n\n        \"\"\"\n        if self._vacuum_mask is None:\n            # get appropriate grid\n            if self._use_reference_vacuum:\n                grid = self.reference_grid.total\n            else:\n                grid = self.charge_grid.total\n            # if vacuum tolerance is set to False, ignore vacuum\n            if self.vacuum_tol is False:\n                self._vacuum_mask = np.zeros_like(grid, dtype=np.bool_)\n            else:\n                # get vacuum mask\n                self._vacuum_mask = grid &lt; (\n                    self.vacuum_tol * self.structure.volume  # normalize\n                )\n        return self._vacuum_mask\n\n    @property\n    def num_vacuum(self) -&gt; int:\n        \"\"\"\n\n        Returns\n        -------\n        int\n            The number of vacuum points in the array\n\n        \"\"\"\n        if self._num_vacuum is None:\n            self._num_vacuum = np.count_nonzero(self.vacuum_mask)\n        return self._num_vacuum\n\n    @property\n    def total_electron_number(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total number of electrons in the system calculated from the\n            atom charges and vacuum charge. If this does not match the true\n            total electron number within reasonable floating point error,\n            there is a major problem.\n\n        \"\"\"\n\n        return round(self.atom_charges.sum() + self.vacuum_charge, 10)\n\n    @property\n    def total_volume(self):\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total volume integrated in the system. This should match the\n            volume of the structure. If it does not there may be a serious problem.\n\n        \"\"\"\n\n        return round(self.atom_volumes.sum() + self.vacuum_volume, 10)\n\n    @staticmethod\n    def all_methods() -&gt; list[str]:\n        \"\"\"\n\n        Returns\n        -------\n        list[str]\n            A list of the available methods.\n\n        \"\"\"\n\n        return [i.value for i in Method]\n\n    def run_bader(self) -&gt; None:\n        \"\"\"\n        Runs the entire Bader process and saves results to class variables.\n\n        \"\"\"\n        t0 = time.time()\n        logging.info(f\"Beginning Bader Algorithm Using '{self.method.name}' Method\")\n        # Normalize the method name to a module and class name\n        module_name = self.method.replace(\n            \"-\", \"_\"\n        )  # 'pseudo-neargrid' -&gt; 'pseudo_neargrid'\n        class_name = (\n            \"\".join(part.capitalize() for part in module_name.split(\"_\")) + \"Method\"\n        )\n\n        # import method\n        mod = importlib.import_module(f\"baderkit.core.bader.methods.{module_name}\")\n        Method = getattr(mod, class_name)\n\n        # Instantiate and run the selected method\n        method = Method(\n            charge_grid=self.charge_grid,\n            reference_grid=self.reference_grid,\n            vacuum_mask=self.vacuum_mask,\n            num_vacuum=self.num_vacuum,\n        )\n        if self._use_overdetermined:\n            method._use_overdetermined = True\n        results = method.run()\n\n        for key, value in results.items():\n            setattr(self, f\"_{key}\", value)\n        t1 = time.time()\n        logging.info(\"Bader Algorithm Complete\")\n        logging.info(f\"Time: {round(t1-t0,2)}\")\n\n    def assign_basins_to_structure(self, structure: Structure):\n\n        # Get basin and atom frac coords\n        basins = self.basin_maxima_frac  # (N_basins, 3)\n        atoms = structure.frac_coords  # (N_atoms, 3)\n\n        # get lattice matrix and number of atoms/basins\n        L = structure.lattice.matrix  # (3, 3)\n        N_basins = len(basins)\n\n        # Vectorized deltas, minimum\u2011image wrapping\n        diffs = atoms[None, :, :] - basins[:, None, :]\n        diffs += np.where(diffs &lt;= -0.5, 1, 0)\n        diffs -= np.where(diffs &gt;= 0.5, 1, 0)\n\n        # Cartesian diffs &amp; distances\n        cart = np.einsum(\"bij,jk-&gt;bik\", diffs, L)\n        dists = np.linalg.norm(cart, axis=2)\n\n        # Basin\u2192atom assignment &amp; distances\n        basin_atoms = np.argmin(dists, axis=1)  # (N_basins,)\n        basin_atom_dists = dists[np.arange(N_basins), basin_atoms]  # (N_basins,)\n\n        # Atom labels per grid point\n        # NOTE: append -1 so that vacuum gets assigned to -1 in the atom_labels\n        # array\n        basin_atoms = np.insert(basin_atoms, len(basin_atoms), -1)\n        atom_labels = basin_atoms[self.basin_labels]\n        basin_atoms = basin_atoms[:-1]\n\n        atom_charges = np.bincount(\n            basin_atoms, weights=self.basin_charges, minlength=len(structure)\n        )\n        atom_volumes = np.bincount(\n            basin_atoms, weights=self.basin_volumes, minlength=len(structure)\n        )\n\n        return atom_labels, atom_charges, atom_volumes, basin_atoms, basin_atom_dists\n\n    def run_atom_assignment(self):\n        \"\"\"\n        Assigns bader basins to this Bader objects structure.\n\n        \"\"\"\n        # ensure bader has run (otherwise our time will include the bader time)\n        self.basin_maxima_frac\n\n        # Default structure\n        structure = self.structure\n\n        t0 = time.time()\n        logging.info(\"Assigning Atom Properties\")\n        # get basin assignments for this bader objects structure\n        atom_labels, atom_charges, atom_volumes, basin_atoms, basin_atom_dists = (\n            self.assign_basins_to_structure(structure)\n        )\n\n        # Store everything\n        self._basin_atoms = basin_atoms\n        self._basin_atom_dists = basin_atom_dists\n        self._atom_labels = atom_labels\n        self._atom_charges = atom_charges\n        self._atom_volumes = atom_volumes\n        logging.info(\"Atom Assignment Finished\")\n        t1 = time.time()\n        logging.info(f\"Time: {round(t1-t0, 2)}\")\n\n    def get_oxidation_from_potcar(self, potcar_path: Path = \"POTCAR\"):\n        \"\"\"\n        Calculates the oxidation state of each atom from the provided POTCAR\n        file.\n\n        Parameters\n        ----------\n        potcar_path : Path, optional\n            The path to the POTCAR to calculate oxidation states from. The default is \"POTCAR\".\n\n        Returns\n        -------\n        NDArray\n            The oxidation state of each atom in the structure.\n\n        \"\"\"\n        # convert to path\n        potcar_path = Path(potcar_path)\n        if not potcar_path.exists():\n            logging.warning(\n                \"No POTCAR file found in the requested directory. Oxidation states cannot be calculated\"\n            )\n            return\n        # load\n        with warnings.catch_warnings(record=True):\n            potcars = Potcar.from_file(potcar_path)\n        nelectron_data = {}\n        # the result is a list because there can be multiple element potcars\n        # in the file (e.g. for NaCl, POTCAR = POTCAR_Na + POTCAR_Cl)\n        for potcar in potcars:\n            nelectron_data.update({potcar.element: potcar.nelectrons})\n        # calculate oxidation states\n        oxi_state_data = []\n        for site, site_charge in zip(self.structure, self.atom_charges):\n            element_str = site.specie.name\n            oxi_state = nelectron_data[element_str] - site_charge\n            oxi_state_data.append(oxi_state)\n\n        return np.array(oxi_state_data)\n\n    def _get_atom_surface_distances(self):\n        \"\"\"\n        Calculates the distance from each atom to the nearest surface. This is\n        automatically called during the atom assignment and generally should\n        not be called manually.\n\n        \"\"\"\n        self._atom_min_surface_distances, self._atom_avg_surface_distances = (\n            get_min_avg_surface_dists(\n                labels=self.atom_labels,\n                frac_coords=self.structure.frac_coords,\n                edge_mask=self.atom_edges,\n                matrix=self.reference_grid.matrix,\n                max_value=np.max(self.structure.lattice.abc) * 2,\n            )\n        )\n\n    def _get_basin_surface_distances(self):\n        \"\"\"\n        Calculates the distance from each basin maxima to the nearest surface.\n        This is automatically called during the atom assignment and generally\n        should not be called manually.\n\n        \"\"\"\n        # get the minimum distances\n        self._basin_min_surface_distances, self._basin_avg_surface_distances = (\n            get_min_avg_surface_dists(\n                labels=self.basin_labels,\n                frac_coords=self.basin_maxima_frac,\n                edge_mask=self.basin_edges,\n                matrix=self.reference_grid.matrix,\n                max_value=np.max(self.structure.lattice.abc) * 2,\n            )\n        )\n\n    @classmethod\n    def from_vasp(\n        cls,\n        charge_filename: Path | str = \"CHGCAR\",\n        reference_filename: Path | None | str = None,\n        total_only: bool = True,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Creates a Bader class object from VASP files.\n\n        Parameters\n        ----------\n        charge_filename : Path | str, optional\n            The path to the CHGCAR like file that will be used for summing charge.\n            The default is \"CHGCAR\".\n        reference_filename : Path | None | str, optional\n            The path to CHGCAR like file that will be used for partitioning.\n            If None, the charge file will be used for partitioning.\n        total_only: bool\n            If true, only the first set of data in the file will be read. This\n            increases speed and reduced memory usage as the other data is typically\n            not used.\n            Defaults to True.\n        **kwargs : dict\n            Keyword arguments to pass to the Bader class.\n\n        Returns\n        -------\n        Self\n            A Bader class object.\n\n        \"\"\"\n        charge_grid = Grid.from_vasp(charge_filename, total_only=total_only)\n        if reference_filename is None:\n            reference_grid = None\n        else:\n            reference_grid = Grid.from_vasp(reference_filename, total_only=total_only)\n\n        return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n\n    @classmethod\n    def from_cube(\n        cls,\n        charge_filename: Path | str,\n        reference_filename: Path | None | str = None,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Creates a Bader class object from .cube files.\n\n        Parameters\n        ----------\n        charge_filename : Path | str, optional\n            The path to the .cube file that will be used for summing charge.\n        reference_filename : Path | None | str, optional\n            The path to .cube file that will be used for partitioning.\n            If None, the charge file will be used for partitioning.\n        **kwargs : dict\n            Keyword arguments to pass to the Bader class.\n\n        Returns\n        -------\n        Self\n            A Bader class object.\n\n        \"\"\"\n        charge_grid = Grid.from_cube(charge_filename)\n        if reference_filename is None:\n            reference_grid = None\n        else:\n            reference_grid = Grid.from_cube(reference_filename)\n        return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n\n    @classmethod\n    def from_dynamic(\n        cls,\n        charge_filename: Path | str,\n        reference_filename: Path | None | str = None,\n        format: Literal[\"vasp\", \"cube\", None] = None,\n        total_only: bool = True,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Creates a Bader class object from VASP or .cube files. If no format is\n        provided the method will automatically try and determine the file type\n        from the name\n\n        Parameters\n        ----------\n        charge_filename : Path | str\n            The path to the file containing the charge density that will be\n            integrated.\n        reference_filename : Path | None | str, optional\n            The path to the file that will be used for partitioning.\n            If None, the charge file will be used for partitioning.\n        format : Literal[\"vasp\", \"cube\", None], optional\n            The format of the grids to read in. If None, the formats will be\n            guessed from the file names.\n        total_only: bool\n            If true, only the first set of data in the file will be read. This\n            increases speed and reduced memory usage as the other data is typically\n            not used. This is only used if the file format is determined to be\n            VASP, as cube files are assumed to contain only one set of data.\n            Defaults to True.\n        **kwargs : dict\n            Keyword arguments to pass to the Bader class.\n\n        Returns\n        -------\n        Self\n            A Bader class object.\n\n        \"\"\"\n\n        charge_grid = Grid.from_dynamic(\n            charge_filename, format=format, total_only=total_only\n        )\n        if reference_filename is None:\n            reference_grid = None\n        else:\n            reference_grid = Grid.from_dynamic(\n                reference_filename, format=format, total_only=total_only\n            )\n        return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n\n    def copy(self) -&gt; Self:\n        \"\"\"\n\n        Returns\n        -------\n        Self\n            A deep copy of this Bader object.\n\n        \"\"\"\n        return copy.deepcopy(self)\n\n    def write_basin_volumes(\n        self,\n        basin_indices: NDArray,\n        directory: str | Path = None,\n        write_reference: bool = False,\n        prefix_override: str = None,\n        output_format: str | Format = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes bader basins to vasp-like files. Points belonging to the basin\n        will have values from the charge or reference grid, and all other points\n        will be 0.\n\n        Parameters\n        ----------\n        basin_indices : NDArray\n            The list of basin indices to write\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        \"\"\"\n        # get the data to use\n        if write_reference:\n            data_array = self.reference_grid.total\n            data_type = self.reference_grid.data_type\n        else:\n            data_array = self.charge_grid.total\n            data_type = self.charge_grid.data_type\n\n        if directory is None:\n            directory = Path(\".\")\n        for basin in basin_indices:\n            # get a mask everywhere but the requested basin\n            mask = self.basin_labels != basin\n            # copy data to avoid overwriting. Set data off of basin to 0\n            data_array_copy = data_array.copy()\n            data_array_copy[mask] = 0.0\n            grid = Grid(\n                structure=self.structure,\n                data={\"total\": data_array_copy},\n                data_type=data_type,\n            )\n            # get prefix\n            if prefix_override is None:\n                prefix_override = grid.data_type.prefix\n\n            file_path = directory / f\"{prefix_override}_b{basin}\"\n            # write file\n            grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n\n    def write_all_basin_volumes(\n        self,\n        directory: str | Path = None,\n        write_reference: bool = False,\n        prefix_override: str = None,\n        output_format: str | Format = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes all bader basins to vasp-like files. Points belonging to the basin\n        will have values from the charge or reference grid, and all other points\n        will be 0.\n\n        Parameters\n        ----------\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        \"\"\"\n        basin_indices = np.where(self.significant_basins)[0]\n        self.write_basin_volumes(\n            basin_indices=basin_indices,\n            directory=directory,\n            write_reference=write_reference,\n            prefix_override=prefix_override,\n            output_format=output_format,\n            **writer_kwargs,\n        )\n\n    def write_basin_volumes_sum(\n        self,\n        basin_indices: NDArray,\n        directory: str | Path = None,\n        write_reference: bool = False,\n        prefix_override: str = None,\n        output_format: str | Format = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes the union of the provided bader basins to vasp-like files.\n        Points belonging to the basins will have values from the charge or\n        reference grid, and all other points will be 0.\n\n        Parameters\n        ----------\n        basin_indices : NDArray\n            The list of basin indices to sum and write\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        \"\"\"\n        # get the data to use\n        if write_reference:\n            data_array = self.reference_grid.total\n            data_type = self.reference_grid.data_type\n        else:\n            data_array = self.charge_grid.total\n            data_type = self.charge_grid.data_type\n\n        if directory is None:\n            directory = Path(\".\")\n        # create a mask including each of the requested basins\n        mask = np.isin(self.basin_labels, basin_indices)\n        # copy data to avoid overwriting. Set data off of basin to 0\n        data_array_copy = data_array.copy()\n        data_array_copy[~mask] = 0.0\n        grid = Grid(\n            structure=self.structure,\n            data={\"total\": data_array_copy},\n            data_type=data_type,\n        )\n        # get prefix\n        if prefix_override is None:\n            prefix_override = grid.data_type.prefix\n\n        file_path = directory / f\"{prefix_override}_bsum\"\n\n        # write file\n        grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n\n    def write_atom_volumes(\n        self,\n        atom_indices: NDArray,\n        directory: str | Path = None,\n        write_reference: bool = False,\n        prefix_override: str = None,\n        output_format: str | Format = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes atomic basins to vasp-like files. Points belonging to the atom\n        will have values from the charge or reference grid, and all other points\n        will be 0.\n\n        Parameters\n        ----------\n        atom_indices : NDArray\n            The list of atom indices to write\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        \"\"\"\n        # get the data to use\n        if write_reference:\n            data_array = self.reference_grid.total\n            data_type = self.reference_grid.data_type\n        else:\n            data_array = self.charge_grid.total\n            data_type = self.charge_grid.data_type\n\n        if directory is None:\n            directory = Path(\".\")\n        for atom_index in atom_indices:\n            # get a mask everywhere but the requested basin\n            mask = self.atom_labels != atom_index\n            # copy data to avoid overwriting. Set data off of basin to 0\n            data_array_copy = data_array.copy()\n            data_array_copy[mask] = 0.0\n            grid = Grid(\n                structure=self.structure,\n                data={\"total\": data_array_copy},\n                data_type=data_type,\n            )\n\n            # get prefix\n            if prefix_override is None:\n                prefix_override = grid.data_type.prefix\n\n            file_path = directory / f\"{prefix_override}_a{atom_index}\"\n            # write file\n            grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n\n    def write_all_atom_volumes(\n        self,\n        directory: str | Path = None,\n        write_reference: bool = False,\n        prefix_override: str = None,\n        output_format: str | Format = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes all atomic basins to vasp-like files. Points belonging to the atom\n        will have values from the charge or reference grid, and all other points\n        will be 0.\n\n        Parameters\n        ----------\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        \"\"\"\n        atom_indices = np.array(range(len(self.structure)))\n        self.write_atom_volumes(\n            atom_indices=atom_indices,\n            directory=directory,\n            write_reference=write_reference,\n            prefix_override=prefix_override,\n            output_format=output_format,\n            **writer_kwargs,\n        )\n\n    def write_atom_volumes_sum(\n        self,\n        atom_indices: NDArray,\n        directory: str | Path = None,\n        write_reference: bool = False,\n        prefix_override: str = None,\n        output_format: str | Format = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes the union of the provided atom basins to vasp-like files.\n        Points belonging to the atoms will have values from the charge or\n        reference grid, and all other points will be 0.\n\n        Parameters\n        ----------\n        atom_indices : NDArray\n            The list of atom indices to sum and write\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        \"\"\"\n        # get the data to use\n        if write_reference:\n            data_array = self.reference_grid.total\n            data_type = self.reference_grid.data_type\n        else:\n            data_array = self.charge_grid.total\n            data_type = self.charge_grid.data_type\n\n        if directory is None:\n            directory = Path(\".\")\n        mask = np.isin(self.atom_labels, atom_indices)\n        data_array_copy = data_array.copy()\n        data_array_copy[~mask] = 0.0\n        grid = Grid(\n            structure=self.structure,\n            data={\"total\": data_array_copy},\n            data_type=data_type,\n        )\n\n        # get prefix\n        if prefix_override is None:\n            prefix_override = grid.data_type.prefix\n\n        file_path = directory / f\"{prefix_override}_asum\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n\n    def write_species_volume(\n        self,\n        species: str,\n        directory: str | Path = None,\n        write_reference: bool = True,\n        prefix_override: str = None,\n        output_format: str | Format = None,\n    ):\n        \"\"\"\n        Writes the charge density or reference file for all atoms of the given\n        species to a single file.\n\n        Parameters\n        ----------\n        species : str, optional\n            The species to write.\n        directory : str | Path, optional\n            The directory to write the result to. The default is None.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            The default is True.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        \"\"\"\n        if directory is None:\n            directory = Path(\".\")\n\n        # Get voxel assignments and data\n        voxel_assignment_array = self.atom_labels\n        if write_reference:\n            grid = self.reference_grid.copy()\n        else:\n            grid = self.charge_grid.copy()\n\n        # add dummy atoms if desired\n        indices = self.structure.indices_from_symbol(species)\n\n        # Get mask where the grid belongs to requested species\n        mask = np.isin(voxel_assignment_array, indices, invert=True)\n        grid.total[mask] = 0\n        if grid.diff is not None:\n            grid.diff[mask] = 0\n\n        # get prefix\n        if prefix_override is None:\n            prefix_override = grid.data_type.prefix\n\n        file_path = directory / f\"{prefix_override}_{species}\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format)\n\n    def get_atom_results_dataframe(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Collects a summary of results for the atoms in a pandas DataFrame.\n\n        Returns\n        -------\n        atoms_df : pd.DataFrame\n            A table summarizing the atomic basins.\n\n        \"\"\"\n        # Get atom results summary\n        atom_frac_coords = self.structure.frac_coords\n        atoms_df = pd.DataFrame(\n            {\n                \"label\": self.structure.labels,\n                \"x\": atom_frac_coords[:, 0],\n                \"y\": atom_frac_coords[:, 1],\n                \"z\": atom_frac_coords[:, 2],\n                \"charge\": self.atom_charges,\n                \"volume\": self.atom_volumes,\n                \"surface_dist\": self.atom_min_surface_distances,\n            }\n        )\n        return atoms_df\n\n    def get_basin_results_dataframe(self):\n        \"\"\"\n        Collects a summary of results for the basins in a pandas DataFrame.\n\n        Returns\n        -------\n        basin_df : pd.DataFrame\n            A table summarizing the basins.\n\n        \"\"\"\n        subset = self.significant_basins\n        basin_frac_coords = self.basin_maxima_frac[subset]\n        basin_df = pd.DataFrame(\n            {\n                \"atoms\": np.array(self.structure.labels)[self.basin_atoms[subset]],\n                \"x\": basin_frac_coords[:, 0],\n                \"y\": basin_frac_coords[:, 1],\n                \"z\": basin_frac_coords[:, 2],\n                \"charge\": self.basin_charges[subset],\n                \"volume\": self.basin_volumes[subset],\n                \"surface_dist\": self.basin_min_surface_distances[subset],\n                \"atom_dist\": self.basin_atom_dists[subset],\n            }\n        )\n        return basin_df\n\n    def write_atom_tsv(self, filepath: Path | str = \"bader_atoms.tsv\"):\n        \"\"\"\n        Writes a summary of atom results to .tsv files.\n\n        Parameters\n        ----------\n        filepath : str | Path\n            The Path to write the results to. The default is \"bader_atoms.tsv\".\n\n\n        \"\"\"\n        filepath = Path(filepath)\n\n        # Get atom results summary\n        atoms_df = self.get_atom_results_dataframe()\n        formatted_atoms_df = atoms_df.copy()\n        numeric_cols = formatted_atoms_df.select_dtypes(include=\"number\").columns\n        formatted_atoms_df[numeric_cols] = formatted_atoms_df[numeric_cols].map(\n            lambda x: f\"{x:.5f}\"\n        )\n\n        # Determine max width per column including header\n        col_widths = {\n            col: max(len(col), formatted_atoms_df[col].map(len).max())\n            for col in atoms_df.columns\n        }\n\n        # Note what we're writing in log\n        logging.info(f\"Writing Atom Summary to {filepath}\")\n\n        # write output summaries\n        with open(filepath, \"w\") as f:\n            # Write header\n            header = \"\\t\".join(\n                f\"{col:&lt;{col_widths[col]}}\" for col in formatted_atoms_df.columns\n            )\n            f.write(header + \"\\n\")\n\n            # Write rows\n            for _, row in formatted_atoms_df.iterrows():\n                line = \"\\t\".join(\n                    f\"{val:&lt;{col_widths[col]}}\" for col, val in row.items()\n                )\n                f.write(line + \"\\n\")\n            # write vacuum summary to atom file\n            f.write(\"\\n\")\n            f.write(f\"Vacuum Charge:\\t\\t{self.vacuum_charge:.5f}\\n\")\n            f.write(f\"Vacuum Volume:\\t\\t{self.vacuum_volume:.5f}\\n\")\n            f.write(f\"Total Electrons:\\t{self.total_electron_number:.5f}\\n\")\n            f.write(f\"Total Volume:\\t{self.total_volume:.5f}\\n\")\n\n    def write_basin_tsv(self, filepath: Path | str = \"bader_basins.tsv\"):\n        \"\"\"\n        Writes a summary of basin results to .tsv files.\n\n        Parameters\n        ----------\n        filepath : str | Path\n            The Path to write the results to. The default is \"bader_basins.tsv\".\n\n        \"\"\"\n        filepath = Path(filepath)\n\n        # Get basin results summary\n        basin_df = self.get_basin_results_dataframe()\n        formatted_basin_df = basin_df.copy()\n        numeric_cols = formatted_basin_df.select_dtypes(include=\"number\").columns\n        formatted_basin_df[numeric_cols] = formatted_basin_df[numeric_cols].map(\n            lambda x: f\"{x:.5f}\"\n        )\n\n        # Determine max width per column including header\n        col_widths = {\n            col: max(len(col), formatted_basin_df[col].map(len).max())\n            for col in basin_df.columns\n        }\n\n        # Write to file with aligned columns using tab as separator\n\n        # Note what we're writing in log\n\n        logging.info(f\"Writing Basin Summary to {filepath}\")\n\n        # write output summaries\n        with open(filepath, \"w\") as f:\n            # Write header\n            header = \"\\t\".join(f\"{col:&lt;{col_widths[col]}}\" for col in basin_df.columns)\n            f.write(header + \"\\n\")\n\n            # Write rows\n            for _, row in formatted_basin_df.iterrows():\n                line = \"\\t\".join(\n                    f\"{val:&lt;{col_widths[col]}}\" for col, val in row.items()\n                )\n                f.write(line + \"\\n\")\n\n    def to_dict(\n        self,\n        potcar_path: Path | str = \"POTCAR\",\n        use_json: bool = True,\n    ) -&gt; dict:\n        \"\"\"\n\n        Gets a dictionary summary of the Bader analysis.\n\n        Parameters\n        ----------\n        potcar_path : Path | str, optional\n            The Path to a POTCAR file. This must be provided for oxidation states\n            to be calculated, and they will be None otherwise. The default is \"POTCAR\".\n        use_json : bool, optional\n            Convert all entries to JSONable data types. The default is True.\n\n        Returns\n        -------\n        dict\n            A summary of the BadELF analysis in dictionary form.\n\n        \"\"\"\n        # get charges first to ensure good logging\n        self.atom_charges\n        results = {}\n        # collect method kwargs\n        method_kwargs = {\n            \"method\": self.method,\n            \"vacuum_tol\": self.vacuum_tol,\n            \"basin_tol\": self.basin_tol,\n        }\n        results[\"method_kwargs\"] = method_kwargs\n        results[\"oxidation_states\"] = self.get_oxidation_from_potcar(potcar_path)\n\n        # split into basin and atom sections\n        atom_results = {}\n        for result in [\n            \"species\",\n            \"atom_charges\",\n            \"atom_volumes\",\n            \"atom_min_surface_distances\",\n            \"atom_avg_surface_distances\",\n        ]:\n            atom_results[result] = getattr(self, result, None)\n\n        basin_results = {}\n        for result in [\n            \"basin_atoms\",\n            \"basin_atom_dists\",\n            \"basin_charges\",\n            \"basin_volumes\",\n            \"basin_maxima_frac\",\n            \"basin_maxima_charge_values\",\n            \"basin_maxima_ref_values\",\n            \"basin_maxima_vox\",\n            \"significant_basins\",\n            \"basin_min_surface_distances\",\n            \"basin_avg_surface_distances\",\n        ]:\n            basin_results[result] = getattr(self, result, None)\n\n        for result in [\n            \"structure\",\n            \"vacuum_charge\",\n            \"vacuum_volume\",\n            \"num_vacuum\",\n            \"total_electron_number\",\n            \"total_volume\",\n        ]:\n            results[result] = getattr(self, result, None)\n\n        if use_json:\n            # get serializable versions of each attribute\n            results[\"structure\"] = results[\"structure\"].to(fmt=\"POSCAR\")\n            for key in [\n                \"basin_maxima_frac\",\n                \"basin_maxima_charge_values\",\n                \"basin_maxima_ref_values\",\n                \"basin_maxima_vox\",\n                \"basin_charges\",\n                \"basin_volumes\",\n                \"significant_basins\",\n                \"basin_min_surface_distances\",\n                \"basin_avg_surface_distances\",\n                \"basin_atoms\",\n                \"basin_atom_dists\",\n            ]:\n                if basin_results[key] is None:\n                    continue  # skip oxidation states if they fail\n                basin_results[key] = basin_results[key].tolist()\n            for key in [\n                \"atom_charges\",\n                \"atom_volumes\",\n                \"atom_min_surface_distances\",\n                \"atom_avg_surface_distances\",\n            ]:\n                if atom_results[key] is None:\n                    continue  # skip oxidation states if they fail\n                atom_results[key] = atom_results[key].tolist()\n\n        results[\"atom_results\"] = atom_results\n        results[\"basin_results\"] = basin_results\n\n        return results\n\n    def to_json(self, **kwargs) -&gt; str:\n        \"\"\"\n        Creates a JSON string representation of the results, typically for writing\n        results to file.\n\n        Parameters\n        ----------\n        **kwargs : dict\n            Keyword arguments for the to_dict method.\n\n        Returns\n        -------\n        str\n            A JSON string representation of the BadELF results.\n\n        \"\"\"\n        return json.dumps(self.to_dict(use_json=True, **kwargs))\n\n    def write_json(self, filepath: Path | str = \"bader.json\", **kwargs) -&gt; None:\n        \"\"\"\n        Writes results of the analysis to file in a JSON format.\n\n        Parameters\n        ----------\n        filepath : Path | str, optional\n            The Path to write the results to. The default is \"bader.json\".\n        **kwargs : dict\n            keyword arguments for the to_dict method.\n\n        \"\"\"\n        filepath = Path(filepath)\n        with open(filepath, \"w\") as json_file:\n            json.dump(self.to_dict(use_json=True, **kwargs), json_file, indent=4)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.atom_avg_surface_distances","title":"<code>atom_avg_surface_distances</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The avg distance from each atom to the edges of its basin</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.atom_charges","title":"<code>atom_charges</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The charge assigned to each atom</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.atom_edges","title":"<code>atom_edges</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool_]</code> <p>A mask with the same shape as the input grids that is True at points on atom edges.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.atom_labels","title":"<code>atom_labels</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>A 3D array of the same shape as the reference grid with entries representing the atoms the voxel belongs to.</p> <p>Note that for some methods (e.g. weight) some voxels have fractional assignments for each basin and this will not represent exactly how charges are assigned.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.atom_min_surface_distances","title":"<code>atom_min_surface_distances</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The distance from each atom to the nearest point on the atoms surface.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.atom_volumes","title":"<code>atom_volumes</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The volume assigned to each atom</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_atom_dists","title":"<code>basin_atom_dists</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The distance from each attractor to the nearest atom</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_atoms","title":"<code>basin_atoms</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The atom index of each basin is assigned to.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_avg_surface_distances","title":"<code>basin_avg_surface_distances</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The avg distance from each basin maxima to the edges of its basin</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_charges","title":"<code>basin_charges</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The charges assigned to each attractor.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_edges","title":"<code>basin_edges</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool_]</code> <p>A mask with the same shape as the input grids that is True at points on basin edges.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_labels","title":"<code>basin_labels</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>A 3D array of the same shape as the reference grid with entries representing the basin the voxel belongs to. Note that for some methods (e.g. weight) the voxels have weights for each basin. These will be stored in the basin_weights property.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_maxima_charge_values","title":"<code>basin_maxima_charge_values</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The charge data value at each maximum. If the maximum is off grid, this value will be interpolated.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_maxima_frac","title":"<code>basin_maxima_frac</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The fractional coordinates of each attractor.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_maxima_ref_values","title":"<code>basin_maxima_ref_values</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The reference data value at each maximum. If the maximum is off grid, this value will be interpolated.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_maxima_vox","title":"<code>basin_maxima_vox</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[int]</code> <p>The voxel coordinates of each attractor. There may be more of these than the fractional coordinates, as some maxima sit exactly between several voxels.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_min_surface_distances","title":"<code>basin_min_surface_distances</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The distance from each basin maxima to the nearest point on the basins surface</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_tol","title":"<code>basin_tol</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The value below which a basin will not be considered significant. This is used to avoid writing out data that is likely not valuable. The default is 0.001.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_volumes","title":"<code>basin_volumes</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The volume assigned to each attractor.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.charge_grid","title":"<code>charge_grid</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>Grid</code> <p>A Grid object with the charge density that will be integrated.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.method","title":"<code>method</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The algorithm to use for generating bader basins. If None, defaults to neargrid.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.num_vacuum","title":"<code>num_vacuum</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The number of vacuum points in the array</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.reference_grid","title":"<code>reference_grid</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>Grid</code> <p>A grid object whose values will be used to construct the basins.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.significant_basins","title":"<code>significant_basins</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool]</code> <p>A 1D mask with an entry for each basin that is True where basins are significant.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.species","title":"<code>species</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list[str]</code> <p>The species of each atom/dummy atom in the electride structure. Covalent and metallic features are not included.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.structure","title":"<code>structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The pymatgen structure basins are assigned to.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.total_electron_number","title":"<code>total_electron_number</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total number of electrons in the system calculated from the atom charges and vacuum charge. If this does not match the true total electron number within reasonable floating point error, there is a major problem.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.total_volume","title":"<code>total_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total volume integrated in the system. This should match the volume of the structure. If it does not there may be a serious problem.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.use_reference_vacuum","title":"<code>use_reference_vacuum</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to use the reference file to determine regions of vacuum (low charge density). This should generally be set to True unless the ELF is being used as the reference. The default is True.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.vacuum_charge","title":"<code>vacuum_charge</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The charge assigned to the vacuum.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.vacuum_mask","title":"<code>vacuum_mask</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool]</code> <p>A mask representing the voxels that belong to the vacuum.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.vacuum_tol","title":"<code>vacuum_tol</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The value below which a point will be considered part of the vacuum. The default is 0.001.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.vacuum_volume","title":"<code>vacuum_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total volume assigned to the vacuum.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.all_methods","title":"<code>all_methods()</code>  <code>staticmethod</code>","text":"<p>Returns:</p> Type Description <code>list[str]</code> <p>A list of the available methods.</p> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>@staticmethod\ndef all_methods() -&gt; list[str]:\n    \"\"\"\n\n    Returns\n    -------\n    list[str]\n        A list of the available methods.\n\n    \"\"\"\n\n    return [i.value for i in Method]\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.copy","title":"<code>copy()</code>","text":"<p>Returns:</p> Type Description <code>Self</code> <p>A deep copy of this Bader object.</p> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"\n\n    Returns\n    -------\n    Self\n        A deep copy of this Bader object.\n\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.from_cube","title":"<code>from_cube(charge_filename, reference_filename=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a Bader class object from .cube files.</p> <p>Parameters:</p> Name Type Description Default <code>charge_filename</code> <code>Path | str</code> <p>The path to the .cube file that will be used for summing charge.</p> required <code>reference_filename</code> <code>Path | None | str</code> <p>The path to .cube file that will be used for partitioning. If None, the charge file will be used for partitioning.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the Bader class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A Bader class object.</p> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>@classmethod\ndef from_cube(\n    cls,\n    charge_filename: Path | str,\n    reference_filename: Path | None | str = None,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Creates a Bader class object from .cube files.\n\n    Parameters\n    ----------\n    charge_filename : Path | str, optional\n        The path to the .cube file that will be used for summing charge.\n    reference_filename : Path | None | str, optional\n        The path to .cube file that will be used for partitioning.\n        If None, the charge file will be used for partitioning.\n    **kwargs : dict\n        Keyword arguments to pass to the Bader class.\n\n    Returns\n    -------\n    Self\n        A Bader class object.\n\n    \"\"\"\n    charge_grid = Grid.from_cube(charge_filename)\n    if reference_filename is None:\n        reference_grid = None\n    else:\n        reference_grid = Grid.from_cube(reference_filename)\n    return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.from_dynamic","title":"<code>from_dynamic(charge_filename, reference_filename=None, format=None, total_only=True, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a Bader class object from VASP or .cube files. If no format is provided the method will automatically try and determine the file type from the name</p> <p>Parameters:</p> Name Type Description Default <code>charge_filename</code> <code>Path | str</code> <p>The path to the file containing the charge density that will be integrated.</p> required <code>reference_filename</code> <code>Path | None | str</code> <p>The path to the file that will be used for partitioning. If None, the charge file will be used for partitioning.</p> <code>None</code> <code>format</code> <code>Literal['vasp', 'cube', None]</code> <p>The format of the grids to read in. If None, the formats will be guessed from the file names.</p> <code>None</code> <code>total_only</code> <code>bool</code> <p>If true, only the first set of data in the file will be read. This increases speed and reduced memory usage as the other data is typically not used. This is only used if the file format is determined to be VASP, as cube files are assumed to contain only one set of data. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the Bader class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A Bader class object.</p> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>@classmethod\ndef from_dynamic(\n    cls,\n    charge_filename: Path | str,\n    reference_filename: Path | None | str = None,\n    format: Literal[\"vasp\", \"cube\", None] = None,\n    total_only: bool = True,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Creates a Bader class object from VASP or .cube files. If no format is\n    provided the method will automatically try and determine the file type\n    from the name\n\n    Parameters\n    ----------\n    charge_filename : Path | str\n        The path to the file containing the charge density that will be\n        integrated.\n    reference_filename : Path | None | str, optional\n        The path to the file that will be used for partitioning.\n        If None, the charge file will be used for partitioning.\n    format : Literal[\"vasp\", \"cube\", None], optional\n        The format of the grids to read in. If None, the formats will be\n        guessed from the file names.\n    total_only: bool\n        If true, only the first set of data in the file will be read. This\n        increases speed and reduced memory usage as the other data is typically\n        not used. This is only used if the file format is determined to be\n        VASP, as cube files are assumed to contain only one set of data.\n        Defaults to True.\n    **kwargs : dict\n        Keyword arguments to pass to the Bader class.\n\n    Returns\n    -------\n    Self\n        A Bader class object.\n\n    \"\"\"\n\n    charge_grid = Grid.from_dynamic(\n        charge_filename, format=format, total_only=total_only\n    )\n    if reference_filename is None:\n        reference_grid = None\n    else:\n        reference_grid = Grid.from_dynamic(\n            reference_filename, format=format, total_only=total_only\n        )\n    return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.from_vasp","title":"<code>from_vasp(charge_filename='CHGCAR', reference_filename=None, total_only=True, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a Bader class object from VASP files.</p> <p>Parameters:</p> Name Type Description Default <code>charge_filename</code> <code>Path | str</code> <p>The path to the CHGCAR like file that will be used for summing charge. The default is \"CHGCAR\".</p> <code>'CHGCAR'</code> <code>reference_filename</code> <code>Path | None | str</code> <p>The path to CHGCAR like file that will be used for partitioning. If None, the charge file will be used for partitioning.</p> <code>None</code> <code>total_only</code> <code>bool</code> <p>If true, only the first set of data in the file will be read. This increases speed and reduced memory usage as the other data is typically not used. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the Bader class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A Bader class object.</p> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>@classmethod\ndef from_vasp(\n    cls,\n    charge_filename: Path | str = \"CHGCAR\",\n    reference_filename: Path | None | str = None,\n    total_only: bool = True,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Creates a Bader class object from VASP files.\n\n    Parameters\n    ----------\n    charge_filename : Path | str, optional\n        The path to the CHGCAR like file that will be used for summing charge.\n        The default is \"CHGCAR\".\n    reference_filename : Path | None | str, optional\n        The path to CHGCAR like file that will be used for partitioning.\n        If None, the charge file will be used for partitioning.\n    total_only: bool\n        If true, only the first set of data in the file will be read. This\n        increases speed and reduced memory usage as the other data is typically\n        not used.\n        Defaults to True.\n    **kwargs : dict\n        Keyword arguments to pass to the Bader class.\n\n    Returns\n    -------\n    Self\n        A Bader class object.\n\n    \"\"\"\n    charge_grid = Grid.from_vasp(charge_filename, total_only=total_only)\n    if reference_filename is None:\n        reference_grid = None\n    else:\n        reference_grid = Grid.from_vasp(reference_filename, total_only=total_only)\n\n    return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.get_atom_results_dataframe","title":"<code>get_atom_results_dataframe()</code>","text":"<p>Collects a summary of results for the atoms in a pandas DataFrame.</p> <p>Returns:</p> Name Type Description <code>atoms_df</code> <code>DataFrame</code> <p>A table summarizing the atomic basins.</p> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def get_atom_results_dataframe(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Collects a summary of results for the atoms in a pandas DataFrame.\n\n    Returns\n    -------\n    atoms_df : pd.DataFrame\n        A table summarizing the atomic basins.\n\n    \"\"\"\n    # Get atom results summary\n    atom_frac_coords = self.structure.frac_coords\n    atoms_df = pd.DataFrame(\n        {\n            \"label\": self.structure.labels,\n            \"x\": atom_frac_coords[:, 0],\n            \"y\": atom_frac_coords[:, 1],\n            \"z\": atom_frac_coords[:, 2],\n            \"charge\": self.atom_charges,\n            \"volume\": self.atom_volumes,\n            \"surface_dist\": self.atom_min_surface_distances,\n        }\n    )\n    return atoms_df\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.get_basin_results_dataframe","title":"<code>get_basin_results_dataframe()</code>","text":"<p>Collects a summary of results for the basins in a pandas DataFrame.</p> <p>Returns:</p> Name Type Description <code>basin_df</code> <code>DataFrame</code> <p>A table summarizing the basins.</p> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def get_basin_results_dataframe(self):\n    \"\"\"\n    Collects a summary of results for the basins in a pandas DataFrame.\n\n    Returns\n    -------\n    basin_df : pd.DataFrame\n        A table summarizing the basins.\n\n    \"\"\"\n    subset = self.significant_basins\n    basin_frac_coords = self.basin_maxima_frac[subset]\n    basin_df = pd.DataFrame(\n        {\n            \"atoms\": np.array(self.structure.labels)[self.basin_atoms[subset]],\n            \"x\": basin_frac_coords[:, 0],\n            \"y\": basin_frac_coords[:, 1],\n            \"z\": basin_frac_coords[:, 2],\n            \"charge\": self.basin_charges[subset],\n            \"volume\": self.basin_volumes[subset],\n            \"surface_dist\": self.basin_min_surface_distances[subset],\n            \"atom_dist\": self.basin_atom_dists[subset],\n        }\n    )\n    return basin_df\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.get_oxidation_from_potcar","title":"<code>get_oxidation_from_potcar(potcar_path='POTCAR')</code>","text":"<p>Calculates the oxidation state of each atom from the provided POTCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>potcar_path</code> <code>Path</code> <p>The path to the POTCAR to calculate oxidation states from. The default is \"POTCAR\".</p> <code>'POTCAR'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>The oxidation state of each atom in the structure.</p> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def get_oxidation_from_potcar(self, potcar_path: Path = \"POTCAR\"):\n    \"\"\"\n    Calculates the oxidation state of each atom from the provided POTCAR\n    file.\n\n    Parameters\n    ----------\n    potcar_path : Path, optional\n        The path to the POTCAR to calculate oxidation states from. The default is \"POTCAR\".\n\n    Returns\n    -------\n    NDArray\n        The oxidation state of each atom in the structure.\n\n    \"\"\"\n    # convert to path\n    potcar_path = Path(potcar_path)\n    if not potcar_path.exists():\n        logging.warning(\n            \"No POTCAR file found in the requested directory. Oxidation states cannot be calculated\"\n        )\n        return\n    # load\n    with warnings.catch_warnings(record=True):\n        potcars = Potcar.from_file(potcar_path)\n    nelectron_data = {}\n    # the result is a list because there can be multiple element potcars\n    # in the file (e.g. for NaCl, POTCAR = POTCAR_Na + POTCAR_Cl)\n    for potcar in potcars:\n        nelectron_data.update({potcar.element: potcar.nelectrons})\n    # calculate oxidation states\n    oxi_state_data = []\n    for site, site_charge in zip(self.structure, self.atom_charges):\n        element_str = site.specie.name\n        oxi_state = nelectron_data[element_str] - site_charge\n        oxi_state_data.append(oxi_state)\n\n    return np.array(oxi_state_data)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.run_atom_assignment","title":"<code>run_atom_assignment()</code>","text":"<p>Assigns bader basins to this Bader objects structure.</p> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def run_atom_assignment(self):\n    \"\"\"\n    Assigns bader basins to this Bader objects structure.\n\n    \"\"\"\n    # ensure bader has run (otherwise our time will include the bader time)\n    self.basin_maxima_frac\n\n    # Default structure\n    structure = self.structure\n\n    t0 = time.time()\n    logging.info(\"Assigning Atom Properties\")\n    # get basin assignments for this bader objects structure\n    atom_labels, atom_charges, atom_volumes, basin_atoms, basin_atom_dists = (\n        self.assign_basins_to_structure(structure)\n    )\n\n    # Store everything\n    self._basin_atoms = basin_atoms\n    self._basin_atom_dists = basin_atom_dists\n    self._atom_labels = atom_labels\n    self._atom_charges = atom_charges\n    self._atom_volumes = atom_volumes\n    logging.info(\"Atom Assignment Finished\")\n    t1 = time.time()\n    logging.info(f\"Time: {round(t1-t0, 2)}\")\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.run_bader","title":"<code>run_bader()</code>","text":"<p>Runs the entire Bader process and saves results to class variables.</p> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def run_bader(self) -&gt; None:\n    \"\"\"\n    Runs the entire Bader process and saves results to class variables.\n\n    \"\"\"\n    t0 = time.time()\n    logging.info(f\"Beginning Bader Algorithm Using '{self.method.name}' Method\")\n    # Normalize the method name to a module and class name\n    module_name = self.method.replace(\n        \"-\", \"_\"\n    )  # 'pseudo-neargrid' -&gt; 'pseudo_neargrid'\n    class_name = (\n        \"\".join(part.capitalize() for part in module_name.split(\"_\")) + \"Method\"\n    )\n\n    # import method\n    mod = importlib.import_module(f\"baderkit.core.bader.methods.{module_name}\")\n    Method = getattr(mod, class_name)\n\n    # Instantiate and run the selected method\n    method = Method(\n        charge_grid=self.charge_grid,\n        reference_grid=self.reference_grid,\n        vacuum_mask=self.vacuum_mask,\n        num_vacuum=self.num_vacuum,\n    )\n    if self._use_overdetermined:\n        method._use_overdetermined = True\n    results = method.run()\n\n    for key, value in results.items():\n        setattr(self, f\"_{key}\", value)\n    t1 = time.time()\n    logging.info(\"Bader Algorithm Complete\")\n    logging.info(f\"Time: {round(t1-t0,2)}\")\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.to_dict","title":"<code>to_dict(potcar_path='POTCAR', use_json=True)</code>","text":"<p>Gets a dictionary summary of the Bader analysis.</p> <p>Parameters:</p> Name Type Description Default <code>potcar_path</code> <code>Path | str</code> <p>The Path to a POTCAR file. This must be provided for oxidation states to be calculated, and they will be None otherwise. The default is \"POTCAR\".</p> <code>'POTCAR'</code> <code>use_json</code> <code>bool</code> <p>Convert all entries to JSONable data types. The default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A summary of the BadELF analysis in dictionary form.</p> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def to_dict(\n    self,\n    potcar_path: Path | str = \"POTCAR\",\n    use_json: bool = True,\n) -&gt; dict:\n    \"\"\"\n\n    Gets a dictionary summary of the Bader analysis.\n\n    Parameters\n    ----------\n    potcar_path : Path | str, optional\n        The Path to a POTCAR file. This must be provided for oxidation states\n        to be calculated, and they will be None otherwise. The default is \"POTCAR\".\n    use_json : bool, optional\n        Convert all entries to JSONable data types. The default is True.\n\n    Returns\n    -------\n    dict\n        A summary of the BadELF analysis in dictionary form.\n\n    \"\"\"\n    # get charges first to ensure good logging\n    self.atom_charges\n    results = {}\n    # collect method kwargs\n    method_kwargs = {\n        \"method\": self.method,\n        \"vacuum_tol\": self.vacuum_tol,\n        \"basin_tol\": self.basin_tol,\n    }\n    results[\"method_kwargs\"] = method_kwargs\n    results[\"oxidation_states\"] = self.get_oxidation_from_potcar(potcar_path)\n\n    # split into basin and atom sections\n    atom_results = {}\n    for result in [\n        \"species\",\n        \"atom_charges\",\n        \"atom_volumes\",\n        \"atom_min_surface_distances\",\n        \"atom_avg_surface_distances\",\n    ]:\n        atom_results[result] = getattr(self, result, None)\n\n    basin_results = {}\n    for result in [\n        \"basin_atoms\",\n        \"basin_atom_dists\",\n        \"basin_charges\",\n        \"basin_volumes\",\n        \"basin_maxima_frac\",\n        \"basin_maxima_charge_values\",\n        \"basin_maxima_ref_values\",\n        \"basin_maxima_vox\",\n        \"significant_basins\",\n        \"basin_min_surface_distances\",\n        \"basin_avg_surface_distances\",\n    ]:\n        basin_results[result] = getattr(self, result, None)\n\n    for result in [\n        \"structure\",\n        \"vacuum_charge\",\n        \"vacuum_volume\",\n        \"num_vacuum\",\n        \"total_electron_number\",\n        \"total_volume\",\n    ]:\n        results[result] = getattr(self, result, None)\n\n    if use_json:\n        # get serializable versions of each attribute\n        results[\"structure\"] = results[\"structure\"].to(fmt=\"POSCAR\")\n        for key in [\n            \"basin_maxima_frac\",\n            \"basin_maxima_charge_values\",\n            \"basin_maxima_ref_values\",\n            \"basin_maxima_vox\",\n            \"basin_charges\",\n            \"basin_volumes\",\n            \"significant_basins\",\n            \"basin_min_surface_distances\",\n            \"basin_avg_surface_distances\",\n            \"basin_atoms\",\n            \"basin_atom_dists\",\n        ]:\n            if basin_results[key] is None:\n                continue  # skip oxidation states if they fail\n            basin_results[key] = basin_results[key].tolist()\n        for key in [\n            \"atom_charges\",\n            \"atom_volumes\",\n            \"atom_min_surface_distances\",\n            \"atom_avg_surface_distances\",\n        ]:\n            if atom_results[key] is None:\n                continue  # skip oxidation states if they fail\n            atom_results[key] = atom_results[key].tolist()\n\n    results[\"atom_results\"] = atom_results\n    results[\"basin_results\"] = basin_results\n\n    return results\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.to_json","title":"<code>to_json(**kwargs)</code>","text":"<p>Creates a JSON string representation of the results, typically for writing results to file.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Keyword arguments for the to_dict method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the BadELF results.</p> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def to_json(self, **kwargs) -&gt; str:\n    \"\"\"\n    Creates a JSON string representation of the results, typically for writing\n    results to file.\n\n    Parameters\n    ----------\n    **kwargs : dict\n        Keyword arguments for the to_dict method.\n\n    Returns\n    -------\n    str\n        A JSON string representation of the BadELF results.\n\n    \"\"\"\n    return json.dumps(self.to_dict(use_json=True, **kwargs))\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_all_atom_volumes","title":"<code>write_all_atom_volumes(directory=None, write_reference=False, prefix_override=None, output_format=None, **writer_kwargs)</code>","text":"<p>Writes all atomic basins to vasp-like files. Points belonging to the atom will have values from the charge or reference grid, and all other points will be 0.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>False</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def write_all_atom_volumes(\n    self,\n    directory: str | Path = None,\n    write_reference: bool = False,\n    prefix_override: str = None,\n    output_format: str | Format = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes all atomic basins to vasp-like files. Points belonging to the atom\n    will have values from the charge or reference grid, and all other points\n    will be 0.\n\n    Parameters\n    ----------\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    \"\"\"\n    atom_indices = np.array(range(len(self.structure)))\n    self.write_atom_volumes(\n        atom_indices=atom_indices,\n        directory=directory,\n        write_reference=write_reference,\n        prefix_override=prefix_override,\n        output_format=output_format,\n        **writer_kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_all_basin_volumes","title":"<code>write_all_basin_volumes(directory=None, write_reference=False, prefix_override=None, output_format=None, **writer_kwargs)</code>","text":"<p>Writes all bader basins to vasp-like files. Points belonging to the basin will have values from the charge or reference grid, and all other points will be 0.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>False</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def write_all_basin_volumes(\n    self,\n    directory: str | Path = None,\n    write_reference: bool = False,\n    prefix_override: str = None,\n    output_format: str | Format = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes all bader basins to vasp-like files. Points belonging to the basin\n    will have values from the charge or reference grid, and all other points\n    will be 0.\n\n    Parameters\n    ----------\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    \"\"\"\n    basin_indices = np.where(self.significant_basins)[0]\n    self.write_basin_volumes(\n        basin_indices=basin_indices,\n        directory=directory,\n        write_reference=write_reference,\n        prefix_override=prefix_override,\n        output_format=output_format,\n        **writer_kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_atom_tsv","title":"<code>write_atom_tsv(filepath='bader_atoms.tsv')</code>","text":"<p>Writes a summary of atom results to .tsv files.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | Path</code> <p>The Path to write the results to. The default is \"bader_atoms.tsv\".</p> <code>'bader_atoms.tsv'</code> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def write_atom_tsv(self, filepath: Path | str = \"bader_atoms.tsv\"):\n    \"\"\"\n    Writes a summary of atom results to .tsv files.\n\n    Parameters\n    ----------\n    filepath : str | Path\n        The Path to write the results to. The default is \"bader_atoms.tsv\".\n\n\n    \"\"\"\n    filepath = Path(filepath)\n\n    # Get atom results summary\n    atoms_df = self.get_atom_results_dataframe()\n    formatted_atoms_df = atoms_df.copy()\n    numeric_cols = formatted_atoms_df.select_dtypes(include=\"number\").columns\n    formatted_atoms_df[numeric_cols] = formatted_atoms_df[numeric_cols].map(\n        lambda x: f\"{x:.5f}\"\n    )\n\n    # Determine max width per column including header\n    col_widths = {\n        col: max(len(col), formatted_atoms_df[col].map(len).max())\n        for col in atoms_df.columns\n    }\n\n    # Note what we're writing in log\n    logging.info(f\"Writing Atom Summary to {filepath}\")\n\n    # write output summaries\n    with open(filepath, \"w\") as f:\n        # Write header\n        header = \"\\t\".join(\n            f\"{col:&lt;{col_widths[col]}}\" for col in formatted_atoms_df.columns\n        )\n        f.write(header + \"\\n\")\n\n        # Write rows\n        for _, row in formatted_atoms_df.iterrows():\n            line = \"\\t\".join(\n                f\"{val:&lt;{col_widths[col]}}\" for col, val in row.items()\n            )\n            f.write(line + \"\\n\")\n        # write vacuum summary to atom file\n        f.write(\"\\n\")\n        f.write(f\"Vacuum Charge:\\t\\t{self.vacuum_charge:.5f}\\n\")\n        f.write(f\"Vacuum Volume:\\t\\t{self.vacuum_volume:.5f}\\n\")\n        f.write(f\"Total Electrons:\\t{self.total_electron_number:.5f}\\n\")\n        f.write(f\"Total Volume:\\t{self.total_volume:.5f}\\n\")\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_atom_volumes","title":"<code>write_atom_volumes(atom_indices, directory=None, write_reference=False, prefix_override=None, output_format=None, **writer_kwargs)</code>","text":"<p>Writes atomic basins to vasp-like files. Points belonging to the atom will have values from the charge or reference grid, and all other points will be 0.</p> <p>Parameters:</p> Name Type Description Default <code>atom_indices</code> <code>NDArray</code> <p>The list of atom indices to write</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>False</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def write_atom_volumes(\n    self,\n    atom_indices: NDArray,\n    directory: str | Path = None,\n    write_reference: bool = False,\n    prefix_override: str = None,\n    output_format: str | Format = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes atomic basins to vasp-like files. Points belonging to the atom\n    will have values from the charge or reference grid, and all other points\n    will be 0.\n\n    Parameters\n    ----------\n    atom_indices : NDArray\n        The list of atom indices to write\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    \"\"\"\n    # get the data to use\n    if write_reference:\n        data_array = self.reference_grid.total\n        data_type = self.reference_grid.data_type\n    else:\n        data_array = self.charge_grid.total\n        data_type = self.charge_grid.data_type\n\n    if directory is None:\n        directory = Path(\".\")\n    for atom_index in atom_indices:\n        # get a mask everywhere but the requested basin\n        mask = self.atom_labels != atom_index\n        # copy data to avoid overwriting. Set data off of basin to 0\n        data_array_copy = data_array.copy()\n        data_array_copy[mask] = 0.0\n        grid = Grid(\n            structure=self.structure,\n            data={\"total\": data_array_copy},\n            data_type=data_type,\n        )\n\n        # get prefix\n        if prefix_override is None:\n            prefix_override = grid.data_type.prefix\n\n        file_path = directory / f\"{prefix_override}_a{atom_index}\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_atom_volumes_sum","title":"<code>write_atom_volumes_sum(atom_indices, directory=None, write_reference=False, prefix_override=None, output_format=None, **writer_kwargs)</code>","text":"<p>Writes the union of the provided atom basins to vasp-like files. Points belonging to the atoms will have values from the charge or reference grid, and all other points will be 0.</p> <p>Parameters:</p> Name Type Description Default <code>atom_indices</code> <code>NDArray</code> <p>The list of atom indices to sum and write</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>False</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def write_atom_volumes_sum(\n    self,\n    atom_indices: NDArray,\n    directory: str | Path = None,\n    write_reference: bool = False,\n    prefix_override: str = None,\n    output_format: str | Format = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes the union of the provided atom basins to vasp-like files.\n    Points belonging to the atoms will have values from the charge or\n    reference grid, and all other points will be 0.\n\n    Parameters\n    ----------\n    atom_indices : NDArray\n        The list of atom indices to sum and write\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    \"\"\"\n    # get the data to use\n    if write_reference:\n        data_array = self.reference_grid.total\n        data_type = self.reference_grid.data_type\n    else:\n        data_array = self.charge_grid.total\n        data_type = self.charge_grid.data_type\n\n    if directory is None:\n        directory = Path(\".\")\n    mask = np.isin(self.atom_labels, atom_indices)\n    data_array_copy = data_array.copy()\n    data_array_copy[~mask] = 0.0\n    grid = Grid(\n        structure=self.structure,\n        data={\"total\": data_array_copy},\n        data_type=data_type,\n    )\n\n    # get prefix\n    if prefix_override is None:\n        prefix_override = grid.data_type.prefix\n\n    file_path = directory / f\"{prefix_override}_asum\"\n    # write file\n    grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_basin_tsv","title":"<code>write_basin_tsv(filepath='bader_basins.tsv')</code>","text":"<p>Writes a summary of basin results to .tsv files.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | Path</code> <p>The Path to write the results to. The default is \"bader_basins.tsv\".</p> <code>'bader_basins.tsv'</code> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def write_basin_tsv(self, filepath: Path | str = \"bader_basins.tsv\"):\n    \"\"\"\n    Writes a summary of basin results to .tsv files.\n\n    Parameters\n    ----------\n    filepath : str | Path\n        The Path to write the results to. The default is \"bader_basins.tsv\".\n\n    \"\"\"\n    filepath = Path(filepath)\n\n    # Get basin results summary\n    basin_df = self.get_basin_results_dataframe()\n    formatted_basin_df = basin_df.copy()\n    numeric_cols = formatted_basin_df.select_dtypes(include=\"number\").columns\n    formatted_basin_df[numeric_cols] = formatted_basin_df[numeric_cols].map(\n        lambda x: f\"{x:.5f}\"\n    )\n\n    # Determine max width per column including header\n    col_widths = {\n        col: max(len(col), formatted_basin_df[col].map(len).max())\n        for col in basin_df.columns\n    }\n\n    # Write to file with aligned columns using tab as separator\n\n    # Note what we're writing in log\n\n    logging.info(f\"Writing Basin Summary to {filepath}\")\n\n    # write output summaries\n    with open(filepath, \"w\") as f:\n        # Write header\n        header = \"\\t\".join(f\"{col:&lt;{col_widths[col]}}\" for col in basin_df.columns)\n        f.write(header + \"\\n\")\n\n        # Write rows\n        for _, row in formatted_basin_df.iterrows():\n            line = \"\\t\".join(\n                f\"{val:&lt;{col_widths[col]}}\" for col, val in row.items()\n            )\n            f.write(line + \"\\n\")\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_basin_volumes","title":"<code>write_basin_volumes(basin_indices, directory=None, write_reference=False, prefix_override=None, output_format=None, **writer_kwargs)</code>","text":"<p>Writes bader basins to vasp-like files. Points belonging to the basin will have values from the charge or reference grid, and all other points will be 0.</p> <p>Parameters:</p> Name Type Description Default <code>basin_indices</code> <code>NDArray</code> <p>The list of basin indices to write</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>False</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def write_basin_volumes(\n    self,\n    basin_indices: NDArray,\n    directory: str | Path = None,\n    write_reference: bool = False,\n    prefix_override: str = None,\n    output_format: str | Format = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes bader basins to vasp-like files. Points belonging to the basin\n    will have values from the charge or reference grid, and all other points\n    will be 0.\n\n    Parameters\n    ----------\n    basin_indices : NDArray\n        The list of basin indices to write\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    \"\"\"\n    # get the data to use\n    if write_reference:\n        data_array = self.reference_grid.total\n        data_type = self.reference_grid.data_type\n    else:\n        data_array = self.charge_grid.total\n        data_type = self.charge_grid.data_type\n\n    if directory is None:\n        directory = Path(\".\")\n    for basin in basin_indices:\n        # get a mask everywhere but the requested basin\n        mask = self.basin_labels != basin\n        # copy data to avoid overwriting. Set data off of basin to 0\n        data_array_copy = data_array.copy()\n        data_array_copy[mask] = 0.0\n        grid = Grid(\n            structure=self.structure,\n            data={\"total\": data_array_copy},\n            data_type=data_type,\n        )\n        # get prefix\n        if prefix_override is None:\n            prefix_override = grid.data_type.prefix\n\n        file_path = directory / f\"{prefix_override}_b{basin}\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_basin_volumes_sum","title":"<code>write_basin_volumes_sum(basin_indices, directory=None, write_reference=False, prefix_override=None, output_format=None, **writer_kwargs)</code>","text":"<p>Writes the union of the provided bader basins to vasp-like files. Points belonging to the basins will have values from the charge or reference grid, and all other points will be 0.</p> <p>Parameters:</p> Name Type Description Default <code>basin_indices</code> <code>NDArray</code> <p>The list of basin indices to sum and write</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>False</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def write_basin_volumes_sum(\n    self,\n    basin_indices: NDArray,\n    directory: str | Path = None,\n    write_reference: bool = False,\n    prefix_override: str = None,\n    output_format: str | Format = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes the union of the provided bader basins to vasp-like files.\n    Points belonging to the basins will have values from the charge or\n    reference grid, and all other points will be 0.\n\n    Parameters\n    ----------\n    basin_indices : NDArray\n        The list of basin indices to sum and write\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    \"\"\"\n    # get the data to use\n    if write_reference:\n        data_array = self.reference_grid.total\n        data_type = self.reference_grid.data_type\n    else:\n        data_array = self.charge_grid.total\n        data_type = self.charge_grid.data_type\n\n    if directory is None:\n        directory = Path(\".\")\n    # create a mask including each of the requested basins\n    mask = np.isin(self.basin_labels, basin_indices)\n    # copy data to avoid overwriting. Set data off of basin to 0\n    data_array_copy = data_array.copy()\n    data_array_copy[~mask] = 0.0\n    grid = Grid(\n        structure=self.structure,\n        data={\"total\": data_array_copy},\n        data_type=data_type,\n    )\n    # get prefix\n    if prefix_override is None:\n        prefix_override = grid.data_type.prefix\n\n    file_path = directory / f\"{prefix_override}_bsum\"\n\n    # write file\n    grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_json","title":"<code>write_json(filepath='bader.json', **kwargs)</code>","text":"<p>Writes results of the analysis to file in a JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Path | str</code> <p>The Path to write the results to. The default is \"bader.json\".</p> <code>'bader.json'</code> <code>**kwargs</code> <code>dict</code> <p>keyword arguments for the to_dict method.</p> <code>{}</code> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def write_json(self, filepath: Path | str = \"bader.json\", **kwargs) -&gt; None:\n    \"\"\"\n    Writes results of the analysis to file in a JSON format.\n\n    Parameters\n    ----------\n    filepath : Path | str, optional\n        The Path to write the results to. The default is \"bader.json\".\n    **kwargs : dict\n        keyword arguments for the to_dict method.\n\n    \"\"\"\n    filepath = Path(filepath)\n    with open(filepath, \"w\") as json_file:\n        json.dump(self.to_dict(use_json=True, **kwargs), json_file, indent=4)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_species_volume","title":"<code>write_species_volume(species, directory=None, write_reference=True, prefix_override=None, output_format=None)</code>","text":"<p>Writes the charge density or reference file for all atoms of the given species to a single file.</p> <p>Parameters:</p> Name Type Description Default <code>species</code> <code>str</code> <p>The species to write.</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the result to. The default is None.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. The default is True.</p> <code>True</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> Source code in <code>src/baderkit/core/bader/bader.py</code> <pre><code>def write_species_volume(\n    self,\n    species: str,\n    directory: str | Path = None,\n    write_reference: bool = True,\n    prefix_override: str = None,\n    output_format: str | Format = None,\n):\n    \"\"\"\n    Writes the charge density or reference file for all atoms of the given\n    species to a single file.\n\n    Parameters\n    ----------\n    species : str, optional\n        The species to write.\n    directory : str | Path, optional\n        The directory to write the result to. The default is None.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        The default is True.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    \"\"\"\n    if directory is None:\n        directory = Path(\".\")\n\n    # Get voxel assignments and data\n    voxel_assignment_array = self.atom_labels\n    if write_reference:\n        grid = self.reference_grid.copy()\n    else:\n        grid = self.charge_grid.copy()\n\n    # add dummy atoms if desired\n    indices = self.structure.indices_from_symbol(species)\n\n    # Get mask where the grid belongs to requested species\n    mask = np.isin(voxel_assignment_array, indices, invert=True)\n    grid.total[mask] = 0\n    if grid.diff is not None:\n        grid.diff[mask] = 0\n\n    # get prefix\n    if prefix_override is None:\n        prefix_override = grid.data_type.prefix\n\n    file_path = directory / f\"{prefix_override}_{species}\"\n    # write file\n    grid.write(filename=file_path, output_format=output_format)\n</code></pre>"},{"location":"api_reference/core/grid/","title":"Grid","text":"<p>               Bases: <code>VolumetricData</code></p> <p>A representation of the charge density, ELF, or other volumetric data. This class is a wraparound for Pymatgen's VolumetricData class with additional properties and methods.</p> See Also <p>:class:<code>~pymatgen.io.vasp.outputs.VolumetricData</code>     The parent class that provides basic volumetric data handling.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>The crystal structure associated with the volumetric data. Represents the lattice and atomic coordinates using the <code>Structure</code> class.</p> required <code>data</code> <code>dict[str, NDArray[float]]</code> <p>A dictionary containing the volumetric data. Keys include: - <code>\"total\"</code>: A 3D NumPy array representing the total spin density. If the     data is ELF, represents the spin up ELF for spin-polarized calculations     and the total ELF otherwise. - <code>\"diff\"</code> (optional): A 3D NumPy array representing the spin-difference   density (spin up - spin down). If the data is ELF, represents the   spin down ELF.</p> required <code>data_aug</code> <code>NDArray[float]</code> <p>Any extra information associated with volumetric data (typically augmentation charges)</p> <code>None</code> <code>source_format</code> <code>Format</code> <p>The file format this grid was created from, 'vasp', 'cube', 'hdf5', or None.</p> <code>None</code> <code>data_type</code> <code>DataType</code> <p>The type of data stored in the Grid object, either 'charge' or 'elf'. If None, the data type will be guessed from the data range.</p> <code>charge</code> <code>distance_matrix</code> <code>NDArray[float]</code> <p>A pre-computed distance matrix if available. Useful so pass distance_matrices between sums, short-circuiting an otherwise expensive operation.</p> <code>None</code> <code>sig_figs</code> <code>int</code> <p>The number of sig figs the data has. If None, this will be guessed.</p> <code>None</code> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>class Grid(VolumetricData):\n    \"\"\"\n    A representation of the charge density, ELF, or other volumetric data.\n    This class is a wraparound for Pymatgen's VolumetricData class with additional\n    properties and methods.\n\n    See Also\n    --------\n    :class:`~pymatgen.io.vasp.outputs.VolumetricData`\n        The parent class that provides basic volumetric data handling.\n\n    Parameters\n    ----------\n    structure : Structure\n        The crystal structure associated with the volumetric data.\n        Represents the lattice and atomic coordinates using the `Structure` class.\n    data : (dict[str, NDArray[float]])\n        A dictionary containing the volumetric data. Keys include:\n        - `\"total\"`: A 3D NumPy array representing the total spin density. If the\n            data is ELF, represents the spin up ELF for spin-polarized calculations\n            and the total ELF otherwise.\n        - `\"diff\"` (optional): A 3D NumPy array representing the spin-difference\n          density (spin up - spin down). If the data is ELF, represents the\n          spin down ELF.\n    data_aug : NDArray[float], optional\n        Any extra information associated with volumetric data\n        (typically augmentation charges)\n    source_format : Format, optional\n        The file format this grid was created from, 'vasp', 'cube', 'hdf5', or None.\n    data_type : DataType, optional\n        The type of data stored in the Grid object, either 'charge' or 'elf'. If\n        None, the data type will be guessed from the data range.\n    distance_matrix : NDArray[float], optional\n        A pre-computed distance matrix if available.\n        Useful so pass distance_matrices between sums,\n        short-circuiting an otherwise expensive operation.\n    sig_figs : int, optional\n        The number of sig figs the data has. If None, this will be guessed.\n    \"\"\"\n\n    def __init__(\n        self,\n        structure: Structure,\n        data: dict,\n        data_aug: dict = None,\n        source_format: Format = None,\n        data_type: DataType = DataType.charge,\n        distance_matrix: NDArray[float] = None,\n        sig_figs: int = None,\n        **kwargs,\n    ):\n        # The following is copied directly from pymatgen, but replaces their\n        # creation of a RegularGridInterpolator to avoid some overhead\n        structure = Structure.from_dict(\n            structure.as_dict()\n        )  # convert to baderkit structure\n\n        self.structure = structure\n\n        self.is_spin_polarized = len(data) &gt;= 2\n        self.is_soc = len(data) &gt;= 4\n        # convert data to numpy arrays in case they were jsanitized as lists\n        self.data = {k: np.array(v) for k, v in data.items()}\n        self.dim = self.data[\"total\"].shape\n        self.data_aug = data_aug or {}\n        self.ngridpts = self.dim[0] * self.dim[1] * self.dim[2]\n        # lazy init the spin data since this is not always needed.\n        self._spin_data: dict[Spin, float] = {}\n        self._distance_matrix = distance_matrix or {}\n        self.xpoints = np.linspace(0.0, 1.0, num=self.dim[0])\n        self.ypoints = np.linspace(0.0, 1.0, num=self.dim[1])\n        self.zpoints = np.linspace(0.0, 1.0, num=self.dim[2])\n        self.name = \"VolumetricData\"\n\n        # The rest of this is new for BaderKit methods\n        if source_format is None:\n            source_format = Format.vasp\n        self.source_format = Format(source_format)\n\n        if sig_figs is None:\n            sig_figs = infer_significant_figures(self.data[\"total\"])\n        self.sig_figs = sig_figs\n\n        # custom interpolator setting\n        self._cubic_spline_coeffs = None\n\n        if data_type is None:\n            # attempt to guess data type from data range\n            if self.total.max() &lt;= 1 and self.total.min() &gt;= 0:\n                data_type = DataType.elf\n            else:\n                data_type = DataType.charge\n            logging.info(f\"Data type set as {data_type.value} from data range\")\n        self.data_type = data_type\n\n        # assign cached properties\n        self._reset_cache()\n\n    def _reset_cache(self):\n        self._grid_indices = None\n        self._flat_grid_indices = None\n        self._point_dists = None\n        self._max_point_dist = None\n        self._grid_neighbor_transforms = None\n        self._maxima_mask = None\n        self._minima_mask = None\n\n    @property\n    def total(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            For charge densities, returns the total charge (spin-up + spin-down).\n            For ELF returns the spin-up or single spin ELF.\n\n        \"\"\"\n        return self.data[\"total\"]\n\n    @total.setter\n    def total(self, new_total: NDArray[float]):\n        self.data[\"total\"] = new_total\n        # reset cache\n        self._reset_cache()\n\n    @property\n    def diff(self) -&gt; NDArray[float] | None:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            For charge densities, returns the magnetized charge (spin-up - spin-down).\n            For ELF returns the spin-down ELF. If the file was not from a spin\n            polarized calculation, this will be None.\n\n        \"\"\"\n        return self.data.get(\"diff\")\n\n    @diff.setter\n    def diff(self, new_diff):\n        self.data[\"diff\"] = new_diff\n        # reset cache\n        self._reset_cache()\n\n    @property\n    def shape(self) -&gt; NDArray[int]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[int]\n            The number of points along each axis of the grid.\n\n        \"\"\"\n        return np.array(self.total.shape)\n\n    @property\n    def matrix(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            A 3x3 matrix defining the a, b, and c sides of the unit cell. Each\n            row is the corresponding lattice vector in cartesian space.\n\n        \"\"\"\n        return self.structure.lattice.matrix\n\n    @property\n    def grid_indices(self) -&gt; NDArray[int]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[int]\n            The indices for all points on the grid. Uses 'C' ordering.\n\n        \"\"\"\n        if self._grid_indices is None:\n            self._grid_indices = np.indices(self.shape).reshape(3, -1).T\n        return self._grid_indices\n\n    @property\n    def flat_grid_indices(self) -&gt; NDArray[int]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[int]\n            An array of the same shape as the grid where each entry is the index\n            of that voxel if you were to flatten/ravel the grid. Uses 'C' ordering.\n\n        \"\"\"\n        if self._flat_grid_indices is None:\n            self._flat_grid_indices = np.arange(\n                np.prod(self.shape), dtype=np.int64\n            ).reshape(self.shape)\n        return self._flat_grid_indices\n\n    @property\n    def cubic_spline_coeffs(self) -&gt; NDArray[float]:\n        if self._cubic_spline_coeffs is None:\n            self._cubic_spline_coeffs = spline_filter(\n                self.total, order=3, mode=\"grid-wrap\"\n            )\n\n        return self._cubic_spline_coeffs\n\n    # TODO: Do this with numba to reduce memory and probably increase speed\n    @property\n    def point_dists(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The distance from each point to the origin in cartesian coordinates.\n\n        \"\"\"\n        if self._point_dists is None:\n            cart_coords = self.grid_to_cart(self.grid_indices)\n            a, b, c = self.matrix\n            corners = [\n                np.array([0, 0, 0]),\n                a,\n                b,\n                c,\n                a + b,\n                a + c,\n                b + c,\n                a + b + c,\n            ]\n            distances = []\n            for corner in corners:\n                voxel_distances = np.linalg.norm(cart_coords - corner, axis=1).round(6)\n                distances.append(voxel_distances)\n            min_distances = np.min(np.column_stack(distances), axis=1)\n            self._point_dists = min_distances.reshape(self.shape)\n        return self._point_dists\n\n    @property\n    def point_volume(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The volume of a single point in the grid.\n\n        \"\"\"\n        volume = self.structure.volume\n        return volume / self.ngridpts\n\n    @property\n    def max_point_dist(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The maximum distance from the center of a point to one of its corners. This\n            assumes the voxel is the same shape as the lattice.\n\n        \"\"\"\n        if self._max_point_dist is None:\n            # We need to find the coordinates that make up a single voxel. This\n            # is just the cartesian coordinates of the unit cell divided by\n            # its grid size\n            a, b, c = self.matrix\n            end = [0, 0, 0]\n            vox_a = [x / self.shape[0] for x in a]\n            vox_b = [x / self.shape[1] for x in b]\n            vox_c = [x / self.shape[2] for x in c]\n            # We want the three other vertices on the other side of the voxel. These\n            # can be found by adding the vectors in a cycle (e.g. a+b, b+c, c+a)\n            vox_a1 = [x + x1 for x, x1 in zip(vox_a, vox_b)]\n            vox_b1 = [x + x1 for x, x1 in zip(vox_b, vox_c)]\n            vox_c1 = [x + x1 for x, x1 in zip(vox_c, vox_a)]\n            # The final vertex can be found by adding the last unsummed vector to any\n            # of these\n            end1 = [x + x1 for x, x1 in zip(vox_a1, vox_c)]\n            # The center of the voxel sits exactly between the two ends\n            center = [(x + x1) / 2 for x, x1 in zip(end, end1)]\n            # Shift each point here so that the origin is the center of the\n            # voxel.\n            voxel_vertices = []\n            for vector in [\n                center,\n                end,\n                vox_a,\n                vox_b,\n                vox_c,\n                vox_a1,\n                vox_b1,\n                vox_c1,\n                end,\n            ]:\n                new_vector = [(x - x1) for x, x1 in zip(vector, center)]\n                voxel_vertices.append(new_vector)\n\n            # Now we need to find the maximum distance from the center of the voxel\n            # to one of its edges. This should be at one of the vertices.\n            # We can't say for sure which one is the largest distance so we find all\n            # of their distances and return the maximum\n            self._max_point_dist = max(\n                [np.linalg.norm(vector) for vector in voxel_vertices]\n            )\n        return self._max_point_dist\n\n    @cached_property\n    def point_neighbor_voronoi_transforms(\n        self,\n    ) -&gt; tuple[NDArray, NDArray, NDArray, NDArray]:\n        \"\"\"\n\n        Returns\n        -------\n        tuple[NDArray, NDArray, NDArray, NDArray]\n            The transformations, neighbor distances, areas, and vertices of the\n            voronoi surface between any point and its neighbors in the grid.\n            This is used in the 'weight' method for Bader analysis.\n\n        \"\"\"\n        # I go out to 2 voxels away here. I think 1 would probably be fine, but\n        # this doesn't take much more time and I'm certain this will capture the\n        # full voronoi cell.\n        voxel_positions = np.array(list(itertools.product([-2, -1, 0, 1, 2], repeat=3)))\n        center = math.floor(len(voxel_positions) / 2)\n        cart_positions = self.grid_to_cart(voxel_positions)\n        voronoi = Voronoi(cart_positions)\n        site_neighbors = []\n        facet_vertices = []\n        facet_areas = []\n\n        def facet_area(vertices):\n            # You can use a 2D or 3D area formula for a polygon\n            # Here we assume the vertices are in a 2D plane for simplicity\n            # For 3D, a more complicated approach (e.g., convex hull or triangulation) is needed\n            p0 = np.array(vertices[0])\n            area = 0\n            for i in range(1, len(vertices) - 1):\n                p1 = np.array(vertices[i])\n                p2 = np.array(vertices[i + 1])\n                area += np.linalg.norm(np.cross(p1 - p0, p2 - p0)) / 2.0\n            return area\n\n        for i, neighbor_pair in enumerate(voronoi.ridge_points):\n            if center in neighbor_pair:\n                neighbor = [i for i in neighbor_pair if i != center][0]\n                vertex_indices = voronoi.ridge_vertices[i]\n                vertices = voronoi.vertices[vertex_indices]\n                area = facet_area(vertices)\n                site_neighbors.append(neighbor)\n                facet_vertices.append(vertices)\n                facet_areas.append(area)\n        transforms = voxel_positions[np.array(site_neighbors)]\n        cart_transforms = cart_positions[np.array(site_neighbors)]\n        transform_dists = np.linalg.norm(cart_transforms, axis=1)\n        return transforms, transform_dists, np.array(facet_areas), facet_vertices\n\n    @cached_property\n    def point_neighbor_transforms(self) -&gt; (NDArray[int], NDArray[float]):\n        \"\"\"\n\n        Returns\n        -------\n        (NDArray[int], NDArray[float])\n            A tuple where the first entry is a 26x3 array of transformations in\n            from any point to its neighbors and the second is the\n            distance to each of these neighbors in cartesian space.\n\n        \"\"\"\n        neighbors = np.array(\n            [i for i in itertools.product([-1, 0, 1], repeat=3) if i != (0, 0, 0)]\n        ).astype(np.int64)\n        cart_coords = self.grid_to_cart(neighbors)\n        dists = np.linalg.norm(cart_coords, axis=1)\n\n        return neighbors, dists\n\n    @cached_property\n    def point_neighbor_face_tranforms(self) -&gt; (NDArray[int], NDArray[float]):\n        \"\"\"\n\n        Returns\n        -------\n        (NDArray[int], NDArray[float])\n            A tuple where the first entry is a 6x3 array of transformations in\n            voxel space from any voxel to its face sharing neighbors and the\n            second is the distance to each of these neighbors in cartesian space.\n\n        \"\"\"\n        all_neighbors, all_dists = self.point_neighbor_transforms\n        faces = []\n        dists = []\n        for i in range(len(all_neighbors)):\n            if np.sum(np.abs(all_neighbors[i])) == 1:\n                faces.append(all_neighbors[i])\n                dists.append(all_dists[i])\n        return np.array(faces).astype(int), np.array(dists)\n\n    @property\n    def grid_neighbor_transforms(self) -&gt; list:\n        \"\"\"\n        The transforms for translating a grid index to neighboring unit\n        cells.\n\n        Returns\n        -------\n        list\n            A list of voxel grid_neighbor_transforms unique to the grid dimensions.\n\n        \"\"\"\n        if self._grid_neighbor_transforms is None:\n            a, b, c = self.shape\n            grid_neighbor_transforms = [\n                (t, u, v)\n                for t, u, v in itertools.product([-a, 0, a], [-b, 0, b], [-c, 0, c])\n            ]\n            # sort grid_neighbor_transforms. There may be a better way of sorting them. I\n            # noticed that generally the correct site was found most commonly\n            # for the original site and generally was found at grid_neighbor_transforms that\n            # were either all negative/0 or positive/0\n            grid_neighbor_transforms_sorted = []\n            for item in grid_neighbor_transforms:\n                if all(val &lt;= 0 for val in item):\n                    grid_neighbor_transforms_sorted.append(item)\n                elif all(val &gt;= 0 for val in item):\n                    grid_neighbor_transforms_sorted.append(item)\n            for item in grid_neighbor_transforms:\n                if item not in grid_neighbor_transforms_sorted:\n                    grid_neighbor_transforms_sorted.append(item)\n            grid_neighbor_transforms_sorted.insert(\n                0, grid_neighbor_transforms_sorted.pop(7)\n            )\n            self._grid_neighbor_transforms = grid_neighbor_transforms_sorted\n        return self._grid_neighbor_transforms\n\n    @property\n    def grid_resolution(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The number of voxels per unit volume.\n\n        \"\"\"\n        volume = self.structure.volume\n        number_of_voxels = self.ngridpts\n        return number_of_voxels / volume\n\n    @property\n    def maxima_mask(self) -&gt; NDArray[bool]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[bool]\n            A mask with the same dimensions as the data that is True at local\n            maxima. Adjacent points with the same value will both be labeled as\n            True.\n        \"\"\"\n        if self._maxima_mask is None:\n            # avoid circular import\n            from baderkit.core.methods.shared_numba import get_maxima\n\n            self._maxima_mask = get_maxima(\n                self.total,\n                neighbor_transforms=self.point_neighbor_transforms[0],\n                vacuum_mask=np.zeros_like(self.total, dtype=np.bool_),\n            )\n        return self._maxima_mask\n\n    @property\n    def minima_mask(self) -&gt; NDArray[bool]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[bool]\n            A mask with the same dimensions as the data that is True at local\n            minima. Adjacent points with the same value will both be labeled as\n            True.\n        \"\"\"\n        if self._minima_mask is None:\n            # avoid circular import\n            from baderkit.core.methods.shared_numba import get_maxima\n\n            self._minima_mask = get_maxima(\n                self.total,\n                neighbor_transforms=self.point_neighbor_transforms[0],\n                vacuum_mask=np.zeros_like(self.total, dtype=np.bool_),\n                use_minima=True,\n            )\n        return self._minima_mask\n\n    def value_at(\n        self,\n        x: float,\n        y: float,\n        z: float,\n        method: str = \"cubic\",\n    ):\n        \"\"\"Get a data value from self.data at a given point (x, y, z) in terms\n        of fractional lattice parameters. Will be interpolated using the\n        provided method.\n\n        Parameters\n        ----------\n        x : float\n            Fraction of lattice vector a.\n        y: float\n            Fraction of lattice vector b.\n        z: float\n            Fraction of lattice vector c.\n        method : float\n            The method to use for interpolation. nearest, linear, or cubic. The\n            cubic method will calculate and store spline coefficients in an\n            array the same size as the grid, which increases memory usage\n\n        Returns\n        -------\n        float\n            Value from self.data (potentially interpolated) corresponding to\n            the point (x, y, z).\n        \"\"\"\n        if method == \"cubic\":\n            data = self.cubic_spline_coeffs\n        else:\n            data = self.total\n\n        interpolator = Interpolator(\n            data=data,\n            method=method,\n        )\n        # interpolate value\n        return interpolator([x, y, z])[0]\n\n    def values_at(\n        self,\n        frac_coords: NDArray[float],\n        method: str = \"cubic\",\n    ) -&gt; list[float]:\n        \"\"\"\n        Interpolates the value of the data at each fractional coordinate in a\n        given list or array.\n\n        Parameters\n        ----------\n        frac_coords : NDArray\n            The fractional coordinates to interpolate values at with shape\n            N, 3.\n        method : float\n            The method to use for interpolation. nearest, linear, or cubic. The\n            cubic method will calculate and store spline coefficients in an\n            array the same size as the grid, which increases memory usage\n\n        Returns\n        -------\n        list[float]\n            The interpolated value at each fractional coordinate.\n\n        \"\"\"\n        if method == \"cubic\":\n            data = self.cubic_spline_coeffs\n        else:\n            data = self.total\n\n        interpolator = Interpolator(data=data, method=method)\n        # interpolate values\n        return interpolator(frac_coords)\n\n    def linear_slice(\n        self, p1: NDArray[float], p2: NDArray[float], n: int = 100, method=\"cubic\"\n    ):\n        \"\"\"\n        Interpolates the data between two fractional coordinates.\n\n        Parameters\n        ----------\n        p1 : NDArray[float]\n            The fractional coordinates of the first point\n        p2 : NDArray[float]\n            The fractional coordinates of the second point\n        n : int, optional\n            The number of points to collect along the line\n        method : float\n            The method to use for interpolation. nearest, linear, or cubic. The\n            cubic method will calculate and store spline coefficients in an\n            array the same size as the grid, which increases memory usage\n\n        Returns:\n            List of n data points (mostly interpolated) representing a linear slice of the\n            data from point p1 to point p2.\n        \"\"\"\n        if type(p1) not in {list, np.ndarray}:\n            raise TypeError(\n                f\"type of p1 should be list or np.ndarray, got {type(p1).__name__}\"\n            )\n        if len(p1) != 3:\n            raise ValueError(f\"length of p1 should be 3, got {len(p1)}\")\n        if type(p2) not in {list, np.ndarray}:\n            raise TypeError(\n                f\"type of p2 should be list or np.ndarray, got {type(p2).__name__}\"\n            )\n        if len(p2) != 3:\n            raise ValueError(f\"length of p2 should be 3, got {len(p2)}\")\n\n        x_pts = np.linspace(p1[0], p2[0], num=n)\n        y_pts = np.linspace(p1[1], p2[1], num=n)\n        z_pts = np.linspace(p1[2], p2[2], num=n)\n        frac_coords = np.column_stack((x_pts, y_pts, z_pts))\n        return self.values_at(frac_coords, method)\n\n    def cubic_slice(self, point: NDArray, neighbor_size: int = 1) -&gt; NDArray:\n        \"\"\"\n        Gets a box around a given point taking into account wrapping at cell\n        boundaries.\n\n        Parameters\n        ----------\n        point : NDArray\n            The grid indices of the point to get a box around.\n        neighbor_size : int, optional\n            The size of the box on either side of the point. The default is 1.\n\n        Returns\n        -------\n        NDArray\n            A slice of the grid taken around the provided point.\n\n        \"\"\"\n\n        slices = []\n        for dim, c in zip(self.shape, point):\n            idx = np.arange(c - neighbor_size, c + 2) % dim\n            idx = idx.astype(int)\n            slices.append(idx)\n        return self.total[np.ix_(slices[0], slices[1], slices[2])]\n\n    @staticmethod\n    def _tile_data(data: NDArray, shape: NDArray):\n        # stack data n-times for each shape n\n        for i, n in enumerate(shape):\n            data = np.concatenate([data for j in range(n)], axis=i)\n        return data\n\n    def make_supercell(self, scaling_matrix: int | NDArray = 2) -&gt; Self:\n        \"\"\"\n        Duplicates data to make a supercell\n\n        Parameters\n        ----------\n        scaling_matrix : int | NDArray, optional\n            A scaling matrix for transforming the lattice and grid data. Two\n            options are possible:\n\n                1. A sequence of three scaling factors. E.g., [2, 1, 1] specifies\n                that the supercell should have dimensions 2a x b x c.\n\n                2. An integer, which simply scales all lattice vectors by the\n                same factor.\n\n            Note that a full 3x3 scaling matrix like that used in PyMatGen's Structure\n            make_supercell method is not currently supported.\n\n        Returns\n        -------\n        NDArray\n            A new array with the data duplicated as requested\n        \"\"\"\n\n        # convert to array for consistency\n        scaling_matrix = np.array(scaling_matrix)\n\n        # if an int is provided, convert to a 1d scaling matrix\n        if scaling_matrix.ndim == 0:\n            scaling_matrix = np.array(\n                [scaling_matrix, scaling_matrix, scaling_matrix], dtype=int\n            )\n\n        x, y, z = scaling_matrix\n        # duplicate data\n        self.total = self._tile_data(self.total, scaling_matrix)\n        if self.diff:\n            new_diff = self._tile_data(self.diff, scaling_matrix)\n            self.diff = new_diff\n\n        # duplicate structure\n        self.structure.make_supercell(scaling_matrix=scaling_matrix)\n\n        return self\n\n    # def get_points_in_radius(\n    #     self,\n    #     point: NDArray,\n    #     radius: float,\n    # ) -&gt; NDArray[int]:\n    #     \"\"\"\n    #     Gets the indices of the points in a radius around a point\n\n    #     Parameters\n    #     ----------\n    #     radius : float\n    #         The radius in cartesian distance units to find indices around the\n    #         point.\n    #     point : NDArray\n    #         The indices of the point to perform the operation on.\n\n    #     Returns\n    #     -------\n    #     NDArray[int]\n    #         The point indices in the sphere around the provided point.\n\n    #     \"\"\"\n    #     point = np.array(point)\n    #     # Get the distance from each point to the origin\n    #     point_distances = self.point_dists\n\n    #     # Get the indices that are within the radius\n    #     sphere_indices = np.where(point_distances &lt;= radius)\n    #     sphere_indices = np.column_stack(sphere_indices)\n\n    #     # Get indices relative to the point\n    #     sphere_indices = sphere_indices + point\n    #     # adjust points to wrap around grid\n    #     # line = [[round(float(a % b), 12) for a, b in zip(position, grid_data.shape)]]\n    #     new_x = (sphere_indices[:, 0] % self.shape[0]).astype(int)\n    #     new_y = (sphere_indices[:, 1] % self.shape[1]).astype(int)\n    #     new_z = (sphere_indices[:, 2] % self.shape[2]).astype(int)\n    #     sphere_indices = np.column_stack([new_x, new_y, new_z])\n    #     # return new_x, new_y, new_z\n    #     return sphere_indices\n\n    # def get_transformations_in_radius(self, radius: float) -&gt; NDArray[int]:\n    #     \"\"\"\n    #     Gets the transformations required to move from a point to the points\n    #     surrounding it within the provided radius\n\n    #     Parameters\n    #     ----------\n    #     radius : float\n    #         The radius in cartesian distance units around the voxel.\n\n    #     Returns\n    #     -------\n    #     NDArray[int]\n    #         An array of transformations to add to a point to get to each of the\n    #         points within the radius surrounding it.\n\n    #     \"\"\"\n    #     # Get voxels around origin\n    #     voxel_distances = self.point_dists\n    #     # sphere_grid = np.where(voxel_distances &lt;= radius, True, False)\n    #     # eroded_grid = binary_erosion(sphere_grid)\n    #     # shell_indices = np.where(sphere_grid!=eroded_grid)\n    #     shell_indices = np.where(voxel_distances &lt;= radius)\n    #     # Now we want to translate these indices to next to the corner so that\n    #     # we can use them as transformations to move a voxel to the edge\n    #     final_shell_indices = []\n    #     for a, x in zip(self.shape, shell_indices):\n    #         new_x = x - a\n    #         abs_new_x = np.abs(new_x)\n    #         new_x_filter = abs_new_x &lt; x\n    #         final_x = np.where(new_x_filter, new_x, x)\n    #         final_shell_indices.append(final_x)\n\n    #     return np.column_stack(final_shell_indices)\n\n    def get_radial_neighbor_transforms(self, r: float) -&gt; tuple:\n        \"\"\"\n        Gets the transformations from each grid point to its neighbors within a\n        radius r. transforms are sorted by distance\n\n        Parameters\n        ----------\n        r : float\n            The radius to get transforms within\n\n        Returns\n        -------\n        tuple\n            Two arrays. The first is the transforms to each neighbor in the radius.\n            The second is the distance to each neighbor in the radius.\n\n        \"\"\"\n\n        nx, ny, nz = self.shape\n\n        transforms, dists = get_transforms_in_radius(\n            r=r, nx=nx, ny=ny, nz=nz, lattice_matrix=self.matrix\n        )\n        return transforms, dists\n\n    def copy(self) -&gt; Self:\n        \"\"\"\n        Convenience method to get a copy of the current Grid.\n\n        Returns\n        -------\n        Self\n            A copy of the Grid.\n\n        \"\"\"\n        return Grid(\n            structure=self.structure.copy(),\n            data=self.data.copy(),\n            data_aug=self.data_aug.copy(),\n            source_format=self.source_format,\n            data_type=self.data_type,\n            distance_matrix=self._distance_matrix.copy(),\n        )\n\n    def regrid(\n        self,\n        desired_resolution: int = 1200,\n        new_shape: np.array = None,\n        order: int = 3,\n    ) -&gt; Self:\n        \"\"\"\n        Returns a new grid resized using scipy's ndimage.zoom method\n\n        Parameters\n        ----------\n        desired_resolution : int, optional\n            The desired resolution in voxels/A^3. The default is 1200.\n        new_shape : np.array, optional\n            The new array shape. Takes precedence over desired_resolution. The default is None.\n        order : int, optional\n            The order of spline interpolation to use. The default is 3.\n\n        Returns\n        -------\n        Self\n            A new Grid object near the desired resolution.\n        \"\"\"\n\n        # get the original grid size and lattice volume.\n        shape = self.shape\n        volume = self.structure.volume\n\n        if new_shape is None:\n            # calculate how much the number of voxels along each unit cell must be\n            # multiplied to reach the desired resolution.\n            scale_factor = ((desired_resolution * volume) / shape.prod()) ** (1 / 3)\n\n            # calculate the new grid shape. round up to the nearest integer for each\n            # side\n            new_shape = np.around(shape * scale_factor).astype(np.int32)\n\n        # get the factor to zoom by\n        zoom_factor = new_shape / shape\n\n        # zoom each piece of data\n        new_data = {}\n        for key, data in self.data.items():\n            new_data[key] = zoom(\n                data, zoom_factor, order=order, mode=\"grid-wrap\", grid_mode=True\n            )\n\n        # TODO: Add augment data?\n        return Grid(structure=self.structure, data=new_data)\n\n    def split_to_spin(self) -&gt; tuple[Self, Self]:\n        \"\"\"\n        Splits the grid to two Grid objects representing the spin up and spin down contributions\n\n        Returns\n        -------\n        tuple[Self, Self]\n            The spin-up and spin-down Grid objects.\n\n        \"\"\"\n\n        # first check if the grid has spin parts\n        assert (\n            self.is_spin_polarized\n        ), \"Only one set of data detected. The grid cannot be split into spin up and spin down\"\n        assert not self.is_soc\n\n        # Now we get the separate data parts. If the data is ELF, the parts are\n        # stored as total=spin up and diff = spin down\n        if self.data_type == \"elf\":\n            logging.info(\n                \"Splitting Grid using ELFCAR conventions (spin-up in 'total', spin-down in 'diff')\"\n            )\n            spin_up_data = self.total.copy()\n            spin_down_data = self.diff.copy()\n        elif self.data_type == \"charge\":\n            logging.info(\n                \"Splitting Grid using CHGCAR conventions (spin-up + spin-down in 'total', spin-up - spin-down in 'diff')\"\n            )\n            spin_data = self.spin_data\n            # pymatgen uses some custom class as keys here\n            for key in spin_data.keys():\n                if key.value == 1:\n                    spin_up_data = spin_data[key].copy()\n                elif key.value == -1:\n                    spin_down_data = spin_data[key].copy()\n\n        # convert to dicts\n        spin_up_data = {\"total\": spin_up_data}\n        spin_down_data = {\"total\": spin_down_data}\n\n        # get augment data\n        aug_up_data = (\n            {\"total\": self.data_aug[\"total\"]} if \"total\" in self.data_aug else {}\n        )\n        aug_down_data = (\n            {\"total\": self.data_aug[\"diff\"]} if \"diff\" in self.data_aug else {}\n        )\n\n        spin_up_grid = Grid(\n            structure=self.structure.copy(),\n            data=spin_up_data,\n            data_aug=aug_up_data,\n            data_type=self.data_type,\n            source_format=self.source_format,\n        )\n        spin_down_grid = Grid(\n            structure=self.structure.copy(),\n            data=spin_down_data,\n            data_aug=aug_down_data,\n            data_type=self.data_type,\n            source_format=self.source_format,\n        )\n\n        return spin_up_grid, spin_down_grid\n\n    @staticmethod\n    def label(input: NDArray, structure: NDArray = np.ones([3, 3, 3])) -&gt; NDArray[int]:\n        \"\"\"\n        Uses scipy's ndimage package to label an array, and corrects for\n        periodic boundaries\n\n        Parameters\n        ----------\n        input : NDArray\n            The array to label.\n        structure : NDArray, optional\n            The structureing elemetn defining feature connections.\n            The default is np.ones([3, 3, 3]).\n\n        Returns\n        -------\n        NDArray[int]\n            An array of the same shape as the original with labels for each unique\n            feature.\n\n        \"\"\"\n\n        if structure is not None:\n            labeled_array, _ = label(input, structure)\n            if len(np.unique(labeled_array)) == 1:\n                # there is one feature or no features\n                return labeled_array\n            # Features connected through opposite sides of the unit cell should\n            # have the same label, but they don't currently. To handle this, we\n            # pad our featured grid, re-label it, and check if the new labels\n            # contain multiple of our previous labels.\n            padded_featured_grid = np.pad(labeled_array, 1, \"wrap\")\n            relabeled_array, label_num = label(padded_featured_grid, structure)\n        else:\n            labeled_array, _ = label(input)\n            padded_featured_grid = np.pad(labeled_array, 1, \"wrap\")\n            relabeled_array, label_num = label(padded_featured_grid)\n\n        # We want to keep track of which features are connected to each other\n        unique_connections = [[] for i in range(len(np.unique(labeled_array)))]\n\n        for i in np.unique(relabeled_array):\n            # for i in range(label_num):\n            # Get the list of features that are in this super feature\n            mask = relabeled_array == i\n            connected_features = list(np.unique(padded_featured_grid[mask]))\n            # Iterate over these features. If they exist in a connection that we\n            # already have, we want to extend the connection to include any other\n            # features in this super feature\n            for j in connected_features:\n\n                unique_connections[j].extend([k for k in connected_features if k != j])\n\n                unique_connections[j] = list(np.unique(unique_connections[j]))\n\n        # create set/list to keep track of which features have already been connected\n        # to others and the full list of connections\n        already_connected = set()\n        reduced_connections = []\n\n        # loop over each shared connection\n        for i in range(len(unique_connections)):\n            if i in already_connected:\n                # we've already done these connections, so we skip\n                continue\n            # create sets of connections to compare with as we add more\n            connections = set()\n            new_connections = set(unique_connections[i])\n            while connections != new_connections:\n                # loop over the connections we've found so far. As we go, add\n                # any features we encounter to our set.\n                connections = new_connections.copy()\n                for j in connections:\n                    already_connected.add(j)\n                    new_connections.update(unique_connections[j])\n\n            # If we found any connections, append them to our list of reduced connections\n            if connections:\n                reduced_connections.append(sorted(new_connections))\n\n        # For each set of connections in our reduced set, relabel all values to\n        # the lowest one.\n        for connections in reduced_connections:\n            connected_features = np.unique(connections)\n            lowest_idx = connected_features[0]\n            for higher_idx in connected_features[1:]:\n                labeled_array = np.where(\n                    labeled_array == higher_idx, lowest_idx, labeled_array\n                )\n\n        # Now we reduce the feature labels so that they start at 0\n        for i, j in enumerate(np.unique(labeled_array)):\n            labeled_array = np.where(labeled_array == j, i, labeled_array)\n\n        return labeled_array\n\n    def linear_add(self, other: Self, scale_factor=1.0) -&gt; Self:\n        \"\"\"\n        Method to do a linear sum of volumetric objects. Used by + and -\n        operators as well. Returns a VolumetricData object containing the\n        linear sum.\n\n        Parameters\n        ----------\n        other : Grid\n            Another Grid object\n        scale_factor : float\n            Factor to scale the other data by\n\n        Returns\n        -------\n            Grid corresponding to self + scale_factor * other.\n        \"\"\"\n        if self.structure != other.structure:\n            logging.warn(\n                \"Structures are different. Make sure you know what you are doing...\",\n                stacklevel=2,\n            )\n        if list(self.data) != list(other.data):\n            raise ValueError(\n                \"Data have different keys! Maybe one is spin-polarized and the other is not?\"\n            )\n\n        # To add checks\n        data = {}\n        for k in self.data:\n            data[k] = self.data[k] + scale_factor * other.data[k]\n\n        new = deepcopy(self)\n        new.data = data.copy()\n        new.data_aug = {}  # TODO: Can this be added somehow?\n        return new\n\n    ###########################################################################\n    # The following is a series of methods that are useful for converting between\n    # voxel coordinates, fractional coordinates, and cartesian coordinates.\n    # Voxel coordinates go from 0 to grid_size-1. Fractional coordinates go\n    # from 0 to 1. Cartesian coordinates convert to real space based on the\n    # crystal lattice.\n    ###########################################################################\n    def get_voxel_coords_from_index(self, site: int) -&gt; NDArray[int]:\n        \"\"\"\n        Takes in an atom's site index and returns the equivalent voxel grid index.\n\n        Parameters\n        ----------\n        site : int\n            The index of the site to find the grid index for.\n\n        Returns\n        -------\n        NDArray[int]\n            A voxel grid index.\n\n        \"\"\"\n        return self.frac_to_grid(self.structure[site].frac_coords)\n\n    def get_voxel_coords_from_neigh_CrystalNN(self, neigh) -&gt; NDArray[int]:\n        \"\"\"\n        Gets the voxel grid index from a neighbor atom object from CrystalNN or\n        VoronoiNN\n\n        Parameters\n        ----------\n        neigh :\n            A neighbor type object from pymatgen.\n\n        Returns\n        -------\n        NDArray[int]\n            A voxel grid index as an array.\n\n        \"\"\"\n        grid_size = self.shape\n        frac = neigh[\"site\"].frac_coords\n        voxel_coords = [a * b for a, b in zip(grid_size, frac)]\n        # voxel positions go from 1 to (grid_size + 0.9999)\n        return np.array(voxel_coords)\n\n    def get_voxel_coords_from_neigh(self, neigh: dict) -&gt; NDArray[int]:\n        \"\"\"\n        Gets the voxel grid index from a neighbor atom object from the pymatgen\n        structure.get_neighbors class.\n\n        Parameters\n        ----------\n        neigh : dict\n            A neighbor dictionary from pymatgens structure.get_neighbors\n            method.\n\n        Returns\n        -------\n        NDArray[int]\n            A voxel grid index as an array.\n\n        \"\"\"\n\n        grid_size = self.shape\n        frac_coords = neigh.frac_coords\n        voxel_coords = [a * b for a, b in zip(grid_size, frac_coords)]\n        # voxel positions go from 1 to (grid_size + 0.9999)\n        return np.array(voxel_coords)\n\n    def cart_to_frac(self, cart_coords: NDArray | list) -&gt; NDArray[float]:\n        \"\"\"\n        Takes in a cartesian coordinate and returns the fractional coordinates.\n\n        Parameters\n        ----------\n        cart_coords : NDArray | list\n            An Nx3 Array or 1D array of length 3.\n\n        Returns\n        -------\n        NDArray[float]\n            Fractional coordinates as an Nx3 Array.\n\n        \"\"\"\n        inverse_matrix = np.linalg.inv(self.matrix)\n\n        return cart_coords @ inverse_matrix\n\n    def cart_to_grid(self, cart_coords: NDArray | list) -&gt; NDArray[int]:\n        \"\"\"\n        Takes in a cartesian coordinate and returns the voxel coordinates.\n\n        Parameters\n        ----------\n        cart_coords : NDArray | list\n            An Nx3 Array or 1D array of length 3.\n\n        Returns\n        -------\n        NDArray[int]\n            Voxel coordinates as an Nx3 Array.\n\n        \"\"\"\n        frac_coords = self.cart_to_frac(cart_coords)\n        voxel_coords = self.frac_to_grid(frac_coords)\n        return voxel_coords\n\n    def frac_to_cart(self, frac_coords: NDArray) -&gt; NDArray[float]:\n        \"\"\"\n        Takes in a fractional coordinate and returns the cartesian coordinates.\n\n        Parameters\n        ----------\n        frac_coords : NDArray | list\n            An Nx3 Array or 1D array of length 3.\n\n        Returns\n        -------\n        NDArray[float]\n            Cartesian coordinates as an Nx3 Array.\n\n        \"\"\"\n\n        return frac_coords @ self.matrix\n\n    def grid_to_frac(self, vox_coords: NDArray) -&gt; NDArray[float]:\n        \"\"\"\n        Takes in a voxel coordinates and returns the fractional coordinates.\n\n        Parameters\n        ----------\n        vox_coords : NDArray | list\n            An Nx3 Array or 1D array of length 3.\n\n        Returns\n        -------\n        NDArray[float]\n            Fractional coordinates as an Nx3 Array.\n\n        \"\"\"\n\n        return vox_coords / self.shape\n\n    def frac_to_grid(self, frac_coords: NDArray) -&gt; NDArray[int]:\n        \"\"\"\n        Takes in a fractional coordinates and returns the voxel coordinates.\n\n        Parameters\n        ----------\n        frac_coords : NDArray | list\n            An Nx3 Array or 1D array of length 3.\n\n        Returns\n        -------\n        NDArray[int]\n            Voxel coordinates as an Nx3 Array.\n\n        \"\"\"\n        return frac_coords * self.shape\n\n    def grid_to_cart(self, vox_coords: NDArray) -&gt; NDArray[float]:\n        \"\"\"\n        Takes in a voxel coordinates and returns the cartesian coordinates.\n\n        Parameters\n        ----------\n        vox_coords : NDArray | list\n            An Nx3 Array or 1D array of length 3.\n\n        Returns\n        -------\n        NDArray[float]\n            Cartesian coordinates as an Nx3 Array.\n\n        \"\"\"\n        frac_coords = self.grid_to_frac(vox_coords)\n        return self.frac_to_cart(frac_coords)\n\n    ###########################################################################\n    # Functions for loading from files or strings\n    ###########################################################################\n\n    @classmethod\n    def from_vasp(\n        cls,\n        grid_file: str | Path,\n        data_type: str | DataType = None,\n        total_only: bool = True,\n        poscar_file: str | Path = None,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Create a grid instance using a CHGCAR or ELFCAR file.\n\n        Parameters\n        ----------\n        grid_file : str | Path\n            The file the instance should be made from. Should be a VASP\n            CHGCAR or ELFCAR type file.\n        data_type: str | DataType\n            The type of data loaded from the file, either charge or elf. If\n            None, the type will be guessed from the data range.\n            Defaults to None.\n        total_only: bool\n            If true, only the first set of data in the file will be read. This\n            increases speed and reduced memory usage for methods that do not\n            use the spin data.\n            Defaults to True.\n        poscar_file: str | Path\n            The POSCAR file to override the grids structure with. This is useful\n            if the POSCAR contains more precise atom positions.\n\n        Returns\n        -------\n        Self\n            Grid from the specified file.\n\n        \"\"\"\n        logging.info(f\"Loading {grid_file}\")\n        t0 = time.time()\n        # get structure and data from file\n        grid_file = Path(grid_file)\n        # check that file exists\n        assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n        structure, data, data_aug, sig_figs = read_vasp(\n            grid_file, total_only=total_only\n        )\n        if poscar_file is not None:\n            structure = Structure.from_file(poscar_file)\n        t1 = time.time()\n        logging.info(f\"Time: {round(t1-t0,2)}\")\n        return cls(\n            structure=structure,\n            data=data,\n            data_aug=data_aug,\n            data_type=data_type,\n            source_format=Format.vasp,\n            sig_figs=sig_figs,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_cube(\n        cls,\n        grid_file: str | Path,\n        data_type: str | DataType = None,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Create a grid instance using a gaussian cube file.\n\n        Parameters\n        ----------\n        grid_file : str | Path\n            The file the instance should be made from. Should be a gaussian\n            cube file.\n        data_type: str | DataType\n            The type of data loaded from the file, either charge or elf. If\n            None, the type will be guessed from the data range.\n            Defaults to None.\n\n        Returns\n        -------\n        Self\n            Grid from the specified file.\n\n        \"\"\"\n        logging.info(f\"Loading {grid_file}\")\n        t0 = time.time()\n        # make sure path is a Path object\n        grid_file = Path(grid_file)\n        # check that file exists\n        assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n        structure, data, ion_charges, origin, sig_figs = read_cube(grid_file)\n        # TODO: Also save the ion charges/origin for writing later\n        t1 = time.time()\n        logging.info(f\"Time: {round(t1-t0,2)}\")\n        return cls(\n            structure=structure,\n            data=data,\n            data_type=data_type,\n            source_format=Format.cube,\n            sig_figs=sig_figs,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_vasp_pymatgen(\n        cls,\n        grid_file: str | Path,\n        data_type: str | DataType = None,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Create a grid instance using a CHGCAR or ELFCAR file. Uses pymatgen's\n        parse_file method which is often surprisingly slow.\n\n        Parameters\n        ----------\n        grid_file : str | Path\n            The file the instance should be made from. Should be a VASP\n            CHGCAR or ELFCAR type file.\n        data_type: str | DataType\n            The type of data loaded from the file, either charge or elf. If\n            None, the type will be guessed from the data range.\n            Defaults to None.\n\n        Returns\n        -------\n        Self\n            Grid from the specified file.\n\n        \"\"\"\n        logging.info(f\"Loading {grid_file}\")\n        t0 = time.time()\n        # make sure path is a Path object\n        grid_file = Path(grid_file)\n        # check that file exists\n        assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n        # Create string to add structure to.\n        poscar, data, data_aug = cls.parse_file(grid_file)\n        t1 = time.time()\n        logging.info(f\"Time: {round(t1-t0,2)}\")\n        return cls(\n            structure=poscar.structure,\n            data=data,\n            data_aug=data_aug,\n            source_format=Format.vasp,\n            data_type=data_type,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_hdf5(\n        cls,\n        grid_file: str | Path,\n        data_type: str | DataType = None,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Create a grid instance using an hdf5 file.\n\n        Parameters\n        ----------\n        grid_file : str | Path\n            The file the instance should be made from. Should be a binary hdf5\n            file.\n        data_type: str | DataType\n            The type of data loaded from the file, either charge or elf. If\n            None, the type will be guessed from the data range.\n            Defaults to None.\n\n        Returns\n        -------\n        Self\n            Grid from the specified file.\n\n        \"\"\"\n        try:\n            import h5py\n        except:\n            raise ImportError(\"\"\"\n                The `h5py` package is required to read/write to the hdf5 format.\n                Please install with `conda install h5py` or `pip install h5py`.\n                \"\"\")\n\n        logging.info(f\"Loading {grid_file}\")\n        t0 = time.time()\n        # make sure path is a Path object\n        grid_file = Path(grid_file)\n\n        # check that file exists\n        assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n        # load the file\n        pymatgen_grid = super().from_hdf5(filename=grid_file)\n        t1 = time.time()\n        logging.info(f\"Time: {round(t1-t0,2)}\")\n        return cls(\n            structure=pymatgen_grid.structure,\n            data=pymatgen_grid.data,\n            data_aug=pymatgen_grid.data_aug,\n            source_format=Format.hdf5,\n            data_type=data_type,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_dynamic(\n        cls,\n        grid_file: str | Path,\n        format: str | Format = None,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Create a grid instance using a VASP or .cube file. If no format is provided\n        the format is guesed by the name of the file.\n\n        Parameters\n        ----------\n        grid_file : str | Path\n            The file the instance should be made from.\n        format : Format, optional\n            The format of the provided file. If None, a guess will be made based\n            on the name of the file. Setting this is identical to calling the\n            from methods for the corresponding file type. The default is None.\n\n        Returns\n        -------\n        Self\n            Grid from the specified file.\n\n        \"\"\"\n        grid_file = Path(grid_file)\n\n        # check that file exists\n        assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n\n        if format is None:\n            # guess format from file\n            format = detect_format(grid_file)\n\n        # make sure format is an available option\n        assert (\n            format in Format\n        ), \"Invalid provided format '{format}'. Options are: {[i.value for i in Format]}\"\n\n        # get the reading method corresponding to this output format\n        method_name = format.reader\n\n        # load from file\n        return getattr(cls, method_name)(grid_file, **kwargs)\n\n    def write_vasp(\n        self,\n        filename: Path | str,\n        vasp4_compatible: bool = False,\n    ):\n        \"\"\"\n        Writes the Grid to a VASP-like file at the provided path.\n\n        Parameters\n        ----------\n        filename : Path | str\n            The name of the file to write to.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        filename = Path(filename)\n        logging.info(f\"Writing {filename.name}\")\n        write_vasp_file(filename=filename, grid=self, vasp4_compatible=vasp4_compatible)\n\n    def write_cube(\n        self,\n        filename: Path | str,\n        **kwargs,\n    ):\n        \"\"\"\n        Writes the Grid to a Gaussian cube-like file at the provided path.\n\n        Parameters\n        ----------\n        filename : Path | str\n            The name of the file to write to.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        filename = Path(filename)\n        logging.info(f\"Writing {filename.name}\")\n        write_cube_file(\n            filename=filename,\n            grid=self,\n            **kwargs,\n        )\n\n    def to_hdf5(\n        self,\n        filename: Path | str,\n        **kwargs,\n    ):\n        try:\n            import h5py\n        except:\n            raise ImportError(\"\"\"\n                The `h5py` package is required to read/write to the hdf5 format.\n                Please install with `conda install h5py` or `pip install h5py`.\n                \"\"\")\n        filename = Path(filename)\n        logging.info(f\"Writing {filename.name}\")\n        super().to_hdf5(filename)\n\n    def write(\n        self,\n        filename: Path | str,\n        output_format: Format | str = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Writes the Grid to the requested format file at the provided path. If no\n        format is provided, uses this Grid objects stored format.\n\n        Parameters\n        ----------\n        filename : Path | str\n            The name of the file to write to.\n        output_format : Format | str\n            The format to write with. If None, writes to source format stored in\n            this Grid objects metadata.\n            Defaults to None.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # If no provided format, get from metadata\n        if output_format is None:\n            output_format = self.source_format\n        # Make sure format is a Format object not a string\n        output_format = Format(output_format)\n        # get the writing method corresponding to this output format\n        method_name = output_format.writer\n        # write the grid\n        getattr(self, method_name)(filename, **kwargs)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.diff","title":"<code>diff</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>For charge densities, returns the magnetized charge (spin-up - spin-down). For ELF returns the spin-down ELF. If the file was not from a spin polarized calculation, this will be None.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.flat_grid_indices","title":"<code>flat_grid_indices</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[int]</code> <p>An array of the same shape as the grid where each entry is the index of that voxel if you were to flatten/ravel the grid. Uses 'C' ordering.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.grid_indices","title":"<code>grid_indices</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[int]</code> <p>The indices for all points on the grid. Uses 'C' ordering.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.grid_neighbor_transforms","title":"<code>grid_neighbor_transforms</code>  <code>property</code>","text":"<p>The transforms for translating a grid index to neighboring unit cells.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of voxel grid_neighbor_transforms unique to the grid dimensions.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.grid_resolution","title":"<code>grid_resolution</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The number of voxels per unit volume.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.matrix","title":"<code>matrix</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>A 3x3 matrix defining the a, b, and c sides of the unit cell. Each row is the corresponding lattice vector in cartesian space.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.max_point_dist","title":"<code>max_point_dist</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The maximum distance from the center of a point to one of its corners. This assumes the voxel is the same shape as the lattice.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.maxima_mask","title":"<code>maxima_mask</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool]</code> <p>A mask with the same dimensions as the data that is True at local maxima. Adjacent points with the same value will both be labeled as True.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.minima_mask","title":"<code>minima_mask</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool]</code> <p>A mask with the same dimensions as the data that is True at local minima. Adjacent points with the same value will both be labeled as True.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.point_dists","title":"<code>point_dists</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The distance from each point to the origin in cartesian coordinates.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.point_neighbor_face_tranforms","title":"<code>point_neighbor_face_tranforms</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>(NDArray[int], NDArray[float])</code> <p>A tuple where the first entry is a 6x3 array of transformations in voxel space from any voxel to its face sharing neighbors and the second is the distance to each of these neighbors in cartesian space.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.point_neighbor_transforms","title":"<code>point_neighbor_transforms</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>(NDArray[int], NDArray[float])</code> <p>A tuple where the first entry is a 26x3 array of transformations in from any point to its neighbors and the second is the distance to each of these neighbors in cartesian space.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.point_neighbor_voronoi_transforms","title":"<code>point_neighbor_voronoi_transforms</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>tuple[NDArray, NDArray, NDArray, NDArray]</code> <p>The transformations, neighbor distances, areas, and vertices of the voronoi surface between any point and its neighbors in the grid. This is used in the 'weight' method for Bader analysis.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.point_volume","title":"<code>point_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The volume of a single point in the grid.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[int]</code> <p>The number of points along each axis of the grid.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.total","title":"<code>total</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>For charge densities, returns the total charge (spin-up + spin-down). For ELF returns the spin-up or single spin ELF.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.cart_to_frac","title":"<code>cart_to_frac(cart_coords)</code>","text":"<p>Takes in a cartesian coordinate and returns the fractional coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>cart_coords</code> <code>NDArray | list</code> <p>An Nx3 Array or 1D array of length 3.</p> required <p>Returns:</p> Type Description <code>NDArray[float]</code> <p>Fractional coordinates as an Nx3 Array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def cart_to_frac(self, cart_coords: NDArray | list) -&gt; NDArray[float]:\n    \"\"\"\n    Takes in a cartesian coordinate and returns the fractional coordinates.\n\n    Parameters\n    ----------\n    cart_coords : NDArray | list\n        An Nx3 Array or 1D array of length 3.\n\n    Returns\n    -------\n    NDArray[float]\n        Fractional coordinates as an Nx3 Array.\n\n    \"\"\"\n    inverse_matrix = np.linalg.inv(self.matrix)\n\n    return cart_coords @ inverse_matrix\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.cart_to_grid","title":"<code>cart_to_grid(cart_coords)</code>","text":"<p>Takes in a cartesian coordinate and returns the voxel coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>cart_coords</code> <code>NDArray | list</code> <p>An Nx3 Array or 1D array of length 3.</p> required <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>Voxel coordinates as an Nx3 Array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def cart_to_grid(self, cart_coords: NDArray | list) -&gt; NDArray[int]:\n    \"\"\"\n    Takes in a cartesian coordinate and returns the voxel coordinates.\n\n    Parameters\n    ----------\n    cart_coords : NDArray | list\n        An Nx3 Array or 1D array of length 3.\n\n    Returns\n    -------\n    NDArray[int]\n        Voxel coordinates as an Nx3 Array.\n\n    \"\"\"\n    frac_coords = self.cart_to_frac(cart_coords)\n    voxel_coords = self.frac_to_grid(frac_coords)\n    return voxel_coords\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.copy","title":"<code>copy()</code>","text":"<p>Convenience method to get a copy of the current Grid.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the Grid.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"\n    Convenience method to get a copy of the current Grid.\n\n    Returns\n    -------\n    Self\n        A copy of the Grid.\n\n    \"\"\"\n    return Grid(\n        structure=self.structure.copy(),\n        data=self.data.copy(),\n        data_aug=self.data_aug.copy(),\n        source_format=self.source_format,\n        data_type=self.data_type,\n        distance_matrix=self._distance_matrix.copy(),\n    )\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.cubic_slice","title":"<code>cubic_slice(point, neighbor_size=1)</code>","text":"<p>Gets a box around a given point taking into account wrapping at cell boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>NDArray</code> <p>The grid indices of the point to get a box around.</p> required <code>neighbor_size</code> <code>int</code> <p>The size of the box on either side of the point. The default is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>A slice of the grid taken around the provided point.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def cubic_slice(self, point: NDArray, neighbor_size: int = 1) -&gt; NDArray:\n    \"\"\"\n    Gets a box around a given point taking into account wrapping at cell\n    boundaries.\n\n    Parameters\n    ----------\n    point : NDArray\n        The grid indices of the point to get a box around.\n    neighbor_size : int, optional\n        The size of the box on either side of the point. The default is 1.\n\n    Returns\n    -------\n    NDArray\n        A slice of the grid taken around the provided point.\n\n    \"\"\"\n\n    slices = []\n    for dim, c in zip(self.shape, point):\n        idx = np.arange(c - neighbor_size, c + 2) % dim\n        idx = idx.astype(int)\n        slices.append(idx)\n    return self.total[np.ix_(slices[0], slices[1], slices[2])]\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.frac_to_cart","title":"<code>frac_to_cart(frac_coords)</code>","text":"<p>Takes in a fractional coordinate and returns the cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>frac_coords</code> <code>NDArray | list</code> <p>An Nx3 Array or 1D array of length 3.</p> required <p>Returns:</p> Type Description <code>NDArray[float]</code> <p>Cartesian coordinates as an Nx3 Array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def frac_to_cart(self, frac_coords: NDArray) -&gt; NDArray[float]:\n    \"\"\"\n    Takes in a fractional coordinate and returns the cartesian coordinates.\n\n    Parameters\n    ----------\n    frac_coords : NDArray | list\n        An Nx3 Array or 1D array of length 3.\n\n    Returns\n    -------\n    NDArray[float]\n        Cartesian coordinates as an Nx3 Array.\n\n    \"\"\"\n\n    return frac_coords @ self.matrix\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.frac_to_grid","title":"<code>frac_to_grid(frac_coords)</code>","text":"<p>Takes in a fractional coordinates and returns the voxel coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>frac_coords</code> <code>NDArray | list</code> <p>An Nx3 Array or 1D array of length 3.</p> required <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>Voxel coordinates as an Nx3 Array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def frac_to_grid(self, frac_coords: NDArray) -&gt; NDArray[int]:\n    \"\"\"\n    Takes in a fractional coordinates and returns the voxel coordinates.\n\n    Parameters\n    ----------\n    frac_coords : NDArray | list\n        An Nx3 Array or 1D array of length 3.\n\n    Returns\n    -------\n    NDArray[int]\n        Voxel coordinates as an Nx3 Array.\n\n    \"\"\"\n    return frac_coords * self.shape\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.from_cube","title":"<code>from_cube(grid_file, data_type=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a grid instance using a gaussian cube file.</p> <p>Parameters:</p> Name Type Description Default <code>grid_file</code> <code>str | Path</code> <p>The file the instance should be made from. Should be a gaussian cube file.</p> required <code>data_type</code> <code>str | DataType</code> <p>The type of data loaded from the file, either charge or elf. If None, the type will be guessed from the data range. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>Grid from the specified file.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@classmethod\ndef from_cube(\n    cls,\n    grid_file: str | Path,\n    data_type: str | DataType = None,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Create a grid instance using a gaussian cube file.\n\n    Parameters\n    ----------\n    grid_file : str | Path\n        The file the instance should be made from. Should be a gaussian\n        cube file.\n    data_type: str | DataType\n        The type of data loaded from the file, either charge or elf. If\n        None, the type will be guessed from the data range.\n        Defaults to None.\n\n    Returns\n    -------\n    Self\n        Grid from the specified file.\n\n    \"\"\"\n    logging.info(f\"Loading {grid_file}\")\n    t0 = time.time()\n    # make sure path is a Path object\n    grid_file = Path(grid_file)\n    # check that file exists\n    assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n    structure, data, ion_charges, origin, sig_figs = read_cube(grid_file)\n    # TODO: Also save the ion charges/origin for writing later\n    t1 = time.time()\n    logging.info(f\"Time: {round(t1-t0,2)}\")\n    return cls(\n        structure=structure,\n        data=data,\n        data_type=data_type,\n        source_format=Format.cube,\n        sig_figs=sig_figs,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.from_dynamic","title":"<code>from_dynamic(grid_file, format=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a grid instance using a VASP or .cube file. If no format is provided the format is guesed by the name of the file.</p> <p>Parameters:</p> Name Type Description Default <code>grid_file</code> <code>str | Path</code> <p>The file the instance should be made from.</p> required <code>format</code> <code>Format</code> <p>The format of the provided file. If None, a guess will be made based on the name of the file. Setting this is identical to calling the from methods for the corresponding file type. The default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>Grid from the specified file.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@classmethod\ndef from_dynamic(\n    cls,\n    grid_file: str | Path,\n    format: str | Format = None,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Create a grid instance using a VASP or .cube file. If no format is provided\n    the format is guesed by the name of the file.\n\n    Parameters\n    ----------\n    grid_file : str | Path\n        The file the instance should be made from.\n    format : Format, optional\n        The format of the provided file. If None, a guess will be made based\n        on the name of the file. Setting this is identical to calling the\n        from methods for the corresponding file type. The default is None.\n\n    Returns\n    -------\n    Self\n        Grid from the specified file.\n\n    \"\"\"\n    grid_file = Path(grid_file)\n\n    # check that file exists\n    assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n\n    if format is None:\n        # guess format from file\n        format = detect_format(grid_file)\n\n    # make sure format is an available option\n    assert (\n        format in Format\n    ), \"Invalid provided format '{format}'. Options are: {[i.value for i in Format]}\"\n\n    # get the reading method corresponding to this output format\n    method_name = format.reader\n\n    # load from file\n    return getattr(cls, method_name)(grid_file, **kwargs)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.from_hdf5","title":"<code>from_hdf5(grid_file, data_type=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a grid instance using an hdf5 file.</p> <p>Parameters:</p> Name Type Description Default <code>grid_file</code> <code>str | Path</code> <p>The file the instance should be made from. Should be a binary hdf5 file.</p> required <code>data_type</code> <code>str | DataType</code> <p>The type of data loaded from the file, either charge or elf. If None, the type will be guessed from the data range. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>Grid from the specified file.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@classmethod\ndef from_hdf5(\n    cls,\n    grid_file: str | Path,\n    data_type: str | DataType = None,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Create a grid instance using an hdf5 file.\n\n    Parameters\n    ----------\n    grid_file : str | Path\n        The file the instance should be made from. Should be a binary hdf5\n        file.\n    data_type: str | DataType\n        The type of data loaded from the file, either charge or elf. If\n        None, the type will be guessed from the data range.\n        Defaults to None.\n\n    Returns\n    -------\n    Self\n        Grid from the specified file.\n\n    \"\"\"\n    try:\n        import h5py\n    except:\n        raise ImportError(\"\"\"\n            The `h5py` package is required to read/write to the hdf5 format.\n            Please install with `conda install h5py` or `pip install h5py`.\n            \"\"\")\n\n    logging.info(f\"Loading {grid_file}\")\n    t0 = time.time()\n    # make sure path is a Path object\n    grid_file = Path(grid_file)\n\n    # check that file exists\n    assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n    # load the file\n    pymatgen_grid = super().from_hdf5(filename=grid_file)\n    t1 = time.time()\n    logging.info(f\"Time: {round(t1-t0,2)}\")\n    return cls(\n        structure=pymatgen_grid.structure,\n        data=pymatgen_grid.data,\n        data_aug=pymatgen_grid.data_aug,\n        source_format=Format.hdf5,\n        data_type=data_type,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.from_vasp","title":"<code>from_vasp(grid_file, data_type=None, total_only=True, poscar_file=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a grid instance using a CHGCAR or ELFCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>grid_file</code> <code>str | Path</code> <p>The file the instance should be made from. Should be a VASP CHGCAR or ELFCAR type file.</p> required <code>data_type</code> <code>str | DataType</code> <p>The type of data loaded from the file, either charge or elf. If None, the type will be guessed from the data range. Defaults to None.</p> <code>None</code> <code>total_only</code> <code>bool</code> <p>If true, only the first set of data in the file will be read. This increases speed and reduced memory usage for methods that do not use the spin data. Defaults to True.</p> <code>True</code> <code>poscar_file</code> <code>str | Path</code> <p>The POSCAR file to override the grids structure with. This is useful if the POSCAR contains more precise atom positions.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>Grid from the specified file.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@classmethod\ndef from_vasp(\n    cls,\n    grid_file: str | Path,\n    data_type: str | DataType = None,\n    total_only: bool = True,\n    poscar_file: str | Path = None,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Create a grid instance using a CHGCAR or ELFCAR file.\n\n    Parameters\n    ----------\n    grid_file : str | Path\n        The file the instance should be made from. Should be a VASP\n        CHGCAR or ELFCAR type file.\n    data_type: str | DataType\n        The type of data loaded from the file, either charge or elf. If\n        None, the type will be guessed from the data range.\n        Defaults to None.\n    total_only: bool\n        If true, only the first set of data in the file will be read. This\n        increases speed and reduced memory usage for methods that do not\n        use the spin data.\n        Defaults to True.\n    poscar_file: str | Path\n        The POSCAR file to override the grids structure with. This is useful\n        if the POSCAR contains more precise atom positions.\n\n    Returns\n    -------\n    Self\n        Grid from the specified file.\n\n    \"\"\"\n    logging.info(f\"Loading {grid_file}\")\n    t0 = time.time()\n    # get structure and data from file\n    grid_file = Path(grid_file)\n    # check that file exists\n    assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n    structure, data, data_aug, sig_figs = read_vasp(\n        grid_file, total_only=total_only\n    )\n    if poscar_file is not None:\n        structure = Structure.from_file(poscar_file)\n    t1 = time.time()\n    logging.info(f\"Time: {round(t1-t0,2)}\")\n    return cls(\n        structure=structure,\n        data=data,\n        data_aug=data_aug,\n        data_type=data_type,\n        source_format=Format.vasp,\n        sig_figs=sig_figs,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.from_vasp_pymatgen","title":"<code>from_vasp_pymatgen(grid_file, data_type=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a grid instance using a CHGCAR or ELFCAR file. Uses pymatgen's parse_file method which is often surprisingly slow.</p> <p>Parameters:</p> Name Type Description Default <code>grid_file</code> <code>str | Path</code> <p>The file the instance should be made from. Should be a VASP CHGCAR or ELFCAR type file.</p> required <code>data_type</code> <code>str | DataType</code> <p>The type of data loaded from the file, either charge or elf. If None, the type will be guessed from the data range. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>Grid from the specified file.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@classmethod\ndef from_vasp_pymatgen(\n    cls,\n    grid_file: str | Path,\n    data_type: str | DataType = None,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Create a grid instance using a CHGCAR or ELFCAR file. Uses pymatgen's\n    parse_file method which is often surprisingly slow.\n\n    Parameters\n    ----------\n    grid_file : str | Path\n        The file the instance should be made from. Should be a VASP\n        CHGCAR or ELFCAR type file.\n    data_type: str | DataType\n        The type of data loaded from the file, either charge or elf. If\n        None, the type will be guessed from the data range.\n        Defaults to None.\n\n    Returns\n    -------\n    Self\n        Grid from the specified file.\n\n    \"\"\"\n    logging.info(f\"Loading {grid_file}\")\n    t0 = time.time()\n    # make sure path is a Path object\n    grid_file = Path(grid_file)\n    # check that file exists\n    assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n    # Create string to add structure to.\n    poscar, data, data_aug = cls.parse_file(grid_file)\n    t1 = time.time()\n    logging.info(f\"Time: {round(t1-t0,2)}\")\n    return cls(\n        structure=poscar.structure,\n        data=data,\n        data_aug=data_aug,\n        source_format=Format.vasp,\n        data_type=data_type,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.get_radial_neighbor_transforms","title":"<code>get_radial_neighbor_transforms(r)</code>","text":"<p>Gets the transformations from each grid point to its neighbors within a radius r. transforms are sorted by distance</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>float</code> <p>The radius to get transforms within</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Two arrays. The first is the transforms to each neighbor in the radius. The second is the distance to each neighbor in the radius.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def get_radial_neighbor_transforms(self, r: float) -&gt; tuple:\n    \"\"\"\n    Gets the transformations from each grid point to its neighbors within a\n    radius r. transforms are sorted by distance\n\n    Parameters\n    ----------\n    r : float\n        The radius to get transforms within\n\n    Returns\n    -------\n    tuple\n        Two arrays. The first is the transforms to each neighbor in the radius.\n        The second is the distance to each neighbor in the radius.\n\n    \"\"\"\n\n    nx, ny, nz = self.shape\n\n    transforms, dists = get_transforms_in_radius(\n        r=r, nx=nx, ny=ny, nz=nz, lattice_matrix=self.matrix\n    )\n    return transforms, dists\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.get_voxel_coords_from_index","title":"<code>get_voxel_coords_from_index(site)</code>","text":"<p>Takes in an atom's site index and returns the equivalent voxel grid index.</p> <p>Parameters:</p> Name Type Description Default <code>site</code> <code>int</code> <p>The index of the site to find the grid index for.</p> required <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>A voxel grid index.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def get_voxel_coords_from_index(self, site: int) -&gt; NDArray[int]:\n    \"\"\"\n    Takes in an atom's site index and returns the equivalent voxel grid index.\n\n    Parameters\n    ----------\n    site : int\n        The index of the site to find the grid index for.\n\n    Returns\n    -------\n    NDArray[int]\n        A voxel grid index.\n\n    \"\"\"\n    return self.frac_to_grid(self.structure[site].frac_coords)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.get_voxel_coords_from_neigh","title":"<code>get_voxel_coords_from_neigh(neigh)</code>","text":"<p>Gets the voxel grid index from a neighbor atom object from the pymatgen structure.get_neighbors class.</p> <p>Parameters:</p> Name Type Description Default <code>neigh</code> <code>dict</code> <p>A neighbor dictionary from pymatgens structure.get_neighbors method.</p> required <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>A voxel grid index as an array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def get_voxel_coords_from_neigh(self, neigh: dict) -&gt; NDArray[int]:\n    \"\"\"\n    Gets the voxel grid index from a neighbor atom object from the pymatgen\n    structure.get_neighbors class.\n\n    Parameters\n    ----------\n    neigh : dict\n        A neighbor dictionary from pymatgens structure.get_neighbors\n        method.\n\n    Returns\n    -------\n    NDArray[int]\n        A voxel grid index as an array.\n\n    \"\"\"\n\n    grid_size = self.shape\n    frac_coords = neigh.frac_coords\n    voxel_coords = [a * b for a, b in zip(grid_size, frac_coords)]\n    # voxel positions go from 1 to (grid_size + 0.9999)\n    return np.array(voxel_coords)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.get_voxel_coords_from_neigh_CrystalNN","title":"<code>get_voxel_coords_from_neigh_CrystalNN(neigh)</code>","text":"<p>Gets the voxel grid index from a neighbor atom object from CrystalNN or VoronoiNN</p> <p>Parameters:</p> Name Type Description Default <code>neigh</code> <p>A neighbor type object from pymatgen.</p> required <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>A voxel grid index as an array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def get_voxel_coords_from_neigh_CrystalNN(self, neigh) -&gt; NDArray[int]:\n    \"\"\"\n    Gets the voxel grid index from a neighbor atom object from CrystalNN or\n    VoronoiNN\n\n    Parameters\n    ----------\n    neigh :\n        A neighbor type object from pymatgen.\n\n    Returns\n    -------\n    NDArray[int]\n        A voxel grid index as an array.\n\n    \"\"\"\n    grid_size = self.shape\n    frac = neigh[\"site\"].frac_coords\n    voxel_coords = [a * b for a, b in zip(grid_size, frac)]\n    # voxel positions go from 1 to (grid_size + 0.9999)\n    return np.array(voxel_coords)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.grid_to_cart","title":"<code>grid_to_cart(vox_coords)</code>","text":"<p>Takes in a voxel coordinates and returns the cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>vox_coords</code> <code>NDArray | list</code> <p>An Nx3 Array or 1D array of length 3.</p> required <p>Returns:</p> Type Description <code>NDArray[float]</code> <p>Cartesian coordinates as an Nx3 Array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def grid_to_cart(self, vox_coords: NDArray) -&gt; NDArray[float]:\n    \"\"\"\n    Takes in a voxel coordinates and returns the cartesian coordinates.\n\n    Parameters\n    ----------\n    vox_coords : NDArray | list\n        An Nx3 Array or 1D array of length 3.\n\n    Returns\n    -------\n    NDArray[float]\n        Cartesian coordinates as an Nx3 Array.\n\n    \"\"\"\n    frac_coords = self.grid_to_frac(vox_coords)\n    return self.frac_to_cart(frac_coords)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.grid_to_frac","title":"<code>grid_to_frac(vox_coords)</code>","text":"<p>Takes in a voxel coordinates and returns the fractional coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>vox_coords</code> <code>NDArray | list</code> <p>An Nx3 Array or 1D array of length 3.</p> required <p>Returns:</p> Type Description <code>NDArray[float]</code> <p>Fractional coordinates as an Nx3 Array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def grid_to_frac(self, vox_coords: NDArray) -&gt; NDArray[float]:\n    \"\"\"\n    Takes in a voxel coordinates and returns the fractional coordinates.\n\n    Parameters\n    ----------\n    vox_coords : NDArray | list\n        An Nx3 Array or 1D array of length 3.\n\n    Returns\n    -------\n    NDArray[float]\n        Fractional coordinates as an Nx3 Array.\n\n    \"\"\"\n\n    return vox_coords / self.shape\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.label","title":"<code>label(input, structure=np.ones([3, 3, 3]))</code>  <code>staticmethod</code>","text":"<p>Uses scipy's ndimage package to label an array, and corrects for periodic boundaries</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>NDArray</code> <p>The array to label.</p> required <code>structure</code> <code>NDArray</code> <p>The structureing elemetn defining feature connections. The default is np.ones([3, 3, 3]).</p> <code>ones([3, 3, 3])</code> <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>An array of the same shape as the original with labels for each unique feature.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@staticmethod\ndef label(input: NDArray, structure: NDArray = np.ones([3, 3, 3])) -&gt; NDArray[int]:\n    \"\"\"\n    Uses scipy's ndimage package to label an array, and corrects for\n    periodic boundaries\n\n    Parameters\n    ----------\n    input : NDArray\n        The array to label.\n    structure : NDArray, optional\n        The structureing elemetn defining feature connections.\n        The default is np.ones([3, 3, 3]).\n\n    Returns\n    -------\n    NDArray[int]\n        An array of the same shape as the original with labels for each unique\n        feature.\n\n    \"\"\"\n\n    if structure is not None:\n        labeled_array, _ = label(input, structure)\n        if len(np.unique(labeled_array)) == 1:\n            # there is one feature or no features\n            return labeled_array\n        # Features connected through opposite sides of the unit cell should\n        # have the same label, but they don't currently. To handle this, we\n        # pad our featured grid, re-label it, and check if the new labels\n        # contain multiple of our previous labels.\n        padded_featured_grid = np.pad(labeled_array, 1, \"wrap\")\n        relabeled_array, label_num = label(padded_featured_grid, structure)\n    else:\n        labeled_array, _ = label(input)\n        padded_featured_grid = np.pad(labeled_array, 1, \"wrap\")\n        relabeled_array, label_num = label(padded_featured_grid)\n\n    # We want to keep track of which features are connected to each other\n    unique_connections = [[] for i in range(len(np.unique(labeled_array)))]\n\n    for i in np.unique(relabeled_array):\n        # for i in range(label_num):\n        # Get the list of features that are in this super feature\n        mask = relabeled_array == i\n        connected_features = list(np.unique(padded_featured_grid[mask]))\n        # Iterate over these features. If they exist in a connection that we\n        # already have, we want to extend the connection to include any other\n        # features in this super feature\n        for j in connected_features:\n\n            unique_connections[j].extend([k for k in connected_features if k != j])\n\n            unique_connections[j] = list(np.unique(unique_connections[j]))\n\n    # create set/list to keep track of which features have already been connected\n    # to others and the full list of connections\n    already_connected = set()\n    reduced_connections = []\n\n    # loop over each shared connection\n    for i in range(len(unique_connections)):\n        if i in already_connected:\n            # we've already done these connections, so we skip\n            continue\n        # create sets of connections to compare with as we add more\n        connections = set()\n        new_connections = set(unique_connections[i])\n        while connections != new_connections:\n            # loop over the connections we've found so far. As we go, add\n            # any features we encounter to our set.\n            connections = new_connections.copy()\n            for j in connections:\n                already_connected.add(j)\n                new_connections.update(unique_connections[j])\n\n        # If we found any connections, append them to our list of reduced connections\n        if connections:\n            reduced_connections.append(sorted(new_connections))\n\n    # For each set of connections in our reduced set, relabel all values to\n    # the lowest one.\n    for connections in reduced_connections:\n        connected_features = np.unique(connections)\n        lowest_idx = connected_features[0]\n        for higher_idx in connected_features[1:]:\n            labeled_array = np.where(\n                labeled_array == higher_idx, lowest_idx, labeled_array\n            )\n\n    # Now we reduce the feature labels so that they start at 0\n    for i, j in enumerate(np.unique(labeled_array)):\n        labeled_array = np.where(labeled_array == j, i, labeled_array)\n\n    return labeled_array\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.linear_add","title":"<code>linear_add(other, scale_factor=1.0)</code>","text":"<p>Method to do a linear sum of volumetric objects. Used by + and - operators as well. Returns a VolumetricData object containing the linear sum.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Grid</code> <p>Another Grid object</p> required <code>scale_factor</code> <code>float</code> <p>Factor to scale the other data by</p> <code>1.0</code> <p>Returns:</p> Type Description <code>    Grid corresponding to self + scale_factor * other.</code> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def linear_add(self, other: Self, scale_factor=1.0) -&gt; Self:\n    \"\"\"\n    Method to do a linear sum of volumetric objects. Used by + and -\n    operators as well. Returns a VolumetricData object containing the\n    linear sum.\n\n    Parameters\n    ----------\n    other : Grid\n        Another Grid object\n    scale_factor : float\n        Factor to scale the other data by\n\n    Returns\n    -------\n        Grid corresponding to self + scale_factor * other.\n    \"\"\"\n    if self.structure != other.structure:\n        logging.warn(\n            \"Structures are different. Make sure you know what you are doing...\",\n            stacklevel=2,\n        )\n    if list(self.data) != list(other.data):\n        raise ValueError(\n            \"Data have different keys! Maybe one is spin-polarized and the other is not?\"\n        )\n\n    # To add checks\n    data = {}\n    for k in self.data:\n        data[k] = self.data[k] + scale_factor * other.data[k]\n\n    new = deepcopy(self)\n    new.data = data.copy()\n    new.data_aug = {}  # TODO: Can this be added somehow?\n    return new\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.linear_slice","title":"<code>linear_slice(p1, p2, n=100, method='cubic')</code>","text":"<p>Interpolates the data between two fractional coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>NDArray[float]</code> <p>The fractional coordinates of the first point</p> required <code>p2</code> <code>NDArray[float]</code> <p>The fractional coordinates of the second point</p> required <code>n</code> <code>int</code> <p>The number of points to collect along the line</p> <code>100</code> <code>method</code> <code>float</code> <p>The method to use for interpolation. nearest, linear, or cubic. The cubic method will calculate and store spline coefficients in an array the same size as the grid, which increases memory usage</p> <code>'cubic'</code> <code>Returns</code> <p>List of n data points (mostly interpolated) representing a linear slice of the data from point p1 to point p2.</p> required Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def linear_slice(\n    self, p1: NDArray[float], p2: NDArray[float], n: int = 100, method=\"cubic\"\n):\n    \"\"\"\n    Interpolates the data between two fractional coordinates.\n\n    Parameters\n    ----------\n    p1 : NDArray[float]\n        The fractional coordinates of the first point\n    p2 : NDArray[float]\n        The fractional coordinates of the second point\n    n : int, optional\n        The number of points to collect along the line\n    method : float\n        The method to use for interpolation. nearest, linear, or cubic. The\n        cubic method will calculate and store spline coefficients in an\n        array the same size as the grid, which increases memory usage\n\n    Returns:\n        List of n data points (mostly interpolated) representing a linear slice of the\n        data from point p1 to point p2.\n    \"\"\"\n    if type(p1) not in {list, np.ndarray}:\n        raise TypeError(\n            f\"type of p1 should be list or np.ndarray, got {type(p1).__name__}\"\n        )\n    if len(p1) != 3:\n        raise ValueError(f\"length of p1 should be 3, got {len(p1)}\")\n    if type(p2) not in {list, np.ndarray}:\n        raise TypeError(\n            f\"type of p2 should be list or np.ndarray, got {type(p2).__name__}\"\n        )\n    if len(p2) != 3:\n        raise ValueError(f\"length of p2 should be 3, got {len(p2)}\")\n\n    x_pts = np.linspace(p1[0], p2[0], num=n)\n    y_pts = np.linspace(p1[1], p2[1], num=n)\n    z_pts = np.linspace(p1[2], p2[2], num=n)\n    frac_coords = np.column_stack((x_pts, y_pts, z_pts))\n    return self.values_at(frac_coords, method)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.make_supercell","title":"<code>make_supercell(scaling_matrix=2)</code>","text":"<p>Duplicates data to make a supercell</p> <p>Parameters:</p> Name Type Description Default <code>scaling_matrix</code> <code>int | NDArray</code> <p>A scaling matrix for transforming the lattice and grid data. Two options are possible:</p> <pre><code>1. A sequence of three scaling factors. E.g., [2, 1, 1] specifies\nthat the supercell should have dimensions 2a x b x c.\n\n2. An integer, which simply scales all lattice vectors by the\nsame factor.\n</code></pre> <p>Note that a full 3x3 scaling matrix like that used in PyMatGen's Structure make_supercell method is not currently supported.</p> <code>2</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>A new array with the data duplicated as requested</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def make_supercell(self, scaling_matrix: int | NDArray = 2) -&gt; Self:\n    \"\"\"\n    Duplicates data to make a supercell\n\n    Parameters\n    ----------\n    scaling_matrix : int | NDArray, optional\n        A scaling matrix for transforming the lattice and grid data. Two\n        options are possible:\n\n            1. A sequence of three scaling factors. E.g., [2, 1, 1] specifies\n            that the supercell should have dimensions 2a x b x c.\n\n            2. An integer, which simply scales all lattice vectors by the\n            same factor.\n\n        Note that a full 3x3 scaling matrix like that used in PyMatGen's Structure\n        make_supercell method is not currently supported.\n\n    Returns\n    -------\n    NDArray\n        A new array with the data duplicated as requested\n    \"\"\"\n\n    # convert to array for consistency\n    scaling_matrix = np.array(scaling_matrix)\n\n    # if an int is provided, convert to a 1d scaling matrix\n    if scaling_matrix.ndim == 0:\n        scaling_matrix = np.array(\n            [scaling_matrix, scaling_matrix, scaling_matrix], dtype=int\n        )\n\n    x, y, z = scaling_matrix\n    # duplicate data\n    self.total = self._tile_data(self.total, scaling_matrix)\n    if self.diff:\n        new_diff = self._tile_data(self.diff, scaling_matrix)\n        self.diff = new_diff\n\n    # duplicate structure\n    self.structure.make_supercell(scaling_matrix=scaling_matrix)\n\n    return self\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.regrid","title":"<code>regrid(desired_resolution=1200, new_shape=None, order=3)</code>","text":"<p>Returns a new grid resized using scipy's ndimage.zoom method</p> <p>Parameters:</p> Name Type Description Default <code>desired_resolution</code> <code>int</code> <p>The desired resolution in voxels/A^3. The default is 1200.</p> <code>1200</code> <code>new_shape</code> <code>array</code> <p>The new array shape. Takes precedence over desired_resolution. The default is None.</p> <code>None</code> <code>order</code> <code>int</code> <p>The order of spline interpolation to use. The default is 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Grid object near the desired resolution.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def regrid(\n    self,\n    desired_resolution: int = 1200,\n    new_shape: np.array = None,\n    order: int = 3,\n) -&gt; Self:\n    \"\"\"\n    Returns a new grid resized using scipy's ndimage.zoom method\n\n    Parameters\n    ----------\n    desired_resolution : int, optional\n        The desired resolution in voxels/A^3. The default is 1200.\n    new_shape : np.array, optional\n        The new array shape. Takes precedence over desired_resolution. The default is None.\n    order : int, optional\n        The order of spline interpolation to use. The default is 3.\n\n    Returns\n    -------\n    Self\n        A new Grid object near the desired resolution.\n    \"\"\"\n\n    # get the original grid size and lattice volume.\n    shape = self.shape\n    volume = self.structure.volume\n\n    if new_shape is None:\n        # calculate how much the number of voxels along each unit cell must be\n        # multiplied to reach the desired resolution.\n        scale_factor = ((desired_resolution * volume) / shape.prod()) ** (1 / 3)\n\n        # calculate the new grid shape. round up to the nearest integer for each\n        # side\n        new_shape = np.around(shape * scale_factor).astype(np.int32)\n\n    # get the factor to zoom by\n    zoom_factor = new_shape / shape\n\n    # zoom each piece of data\n    new_data = {}\n    for key, data in self.data.items():\n        new_data[key] = zoom(\n            data, zoom_factor, order=order, mode=\"grid-wrap\", grid_mode=True\n        )\n\n    # TODO: Add augment data?\n    return Grid(structure=self.structure, data=new_data)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.split_to_spin","title":"<code>split_to_spin()</code>","text":"<p>Splits the grid to two Grid objects representing the spin up and spin down contributions</p> <p>Returns:</p> Type Description <code>tuple[Self, Self]</code> <p>The spin-up and spin-down Grid objects.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def split_to_spin(self) -&gt; tuple[Self, Self]:\n    \"\"\"\n    Splits the grid to two Grid objects representing the spin up and spin down contributions\n\n    Returns\n    -------\n    tuple[Self, Self]\n        The spin-up and spin-down Grid objects.\n\n    \"\"\"\n\n    # first check if the grid has spin parts\n    assert (\n        self.is_spin_polarized\n    ), \"Only one set of data detected. The grid cannot be split into spin up and spin down\"\n    assert not self.is_soc\n\n    # Now we get the separate data parts. If the data is ELF, the parts are\n    # stored as total=spin up and diff = spin down\n    if self.data_type == \"elf\":\n        logging.info(\n            \"Splitting Grid using ELFCAR conventions (spin-up in 'total', spin-down in 'diff')\"\n        )\n        spin_up_data = self.total.copy()\n        spin_down_data = self.diff.copy()\n    elif self.data_type == \"charge\":\n        logging.info(\n            \"Splitting Grid using CHGCAR conventions (spin-up + spin-down in 'total', spin-up - spin-down in 'diff')\"\n        )\n        spin_data = self.spin_data\n        # pymatgen uses some custom class as keys here\n        for key in spin_data.keys():\n            if key.value == 1:\n                spin_up_data = spin_data[key].copy()\n            elif key.value == -1:\n                spin_down_data = spin_data[key].copy()\n\n    # convert to dicts\n    spin_up_data = {\"total\": spin_up_data}\n    spin_down_data = {\"total\": spin_down_data}\n\n    # get augment data\n    aug_up_data = (\n        {\"total\": self.data_aug[\"total\"]} if \"total\" in self.data_aug else {}\n    )\n    aug_down_data = (\n        {\"total\": self.data_aug[\"diff\"]} if \"diff\" in self.data_aug else {}\n    )\n\n    spin_up_grid = Grid(\n        structure=self.structure.copy(),\n        data=spin_up_data,\n        data_aug=aug_up_data,\n        data_type=self.data_type,\n        source_format=self.source_format,\n    )\n    spin_down_grid = Grid(\n        structure=self.structure.copy(),\n        data=spin_down_data,\n        data_aug=aug_down_data,\n        data_type=self.data_type,\n        source_format=self.source_format,\n    )\n\n    return spin_up_grid, spin_down_grid\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.value_at","title":"<code>value_at(x, y, z, method='cubic')</code>","text":"<p>Get a data value from self.data at a given point (x, y, z) in terms of fractional lattice parameters. Will be interpolated using the provided method.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Fraction of lattice vector a.</p> required <code>y</code> <code>float</code> <p>Fraction of lattice vector b.</p> required <code>z</code> <code>float</code> <p>Fraction of lattice vector c.</p> required <code>method</code> <code>float</code> <p>The method to use for interpolation. nearest, linear, or cubic. The cubic method will calculate and store spline coefficients in an array the same size as the grid, which increases memory usage</p> <code>'cubic'</code> <p>Returns:</p> Type Description <code>float</code> <p>Value from self.data (potentially interpolated) corresponding to the point (x, y, z).</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def value_at(\n    self,\n    x: float,\n    y: float,\n    z: float,\n    method: str = \"cubic\",\n):\n    \"\"\"Get a data value from self.data at a given point (x, y, z) in terms\n    of fractional lattice parameters. Will be interpolated using the\n    provided method.\n\n    Parameters\n    ----------\n    x : float\n        Fraction of lattice vector a.\n    y: float\n        Fraction of lattice vector b.\n    z: float\n        Fraction of lattice vector c.\n    method : float\n        The method to use for interpolation. nearest, linear, or cubic. The\n        cubic method will calculate and store spline coefficients in an\n        array the same size as the grid, which increases memory usage\n\n    Returns\n    -------\n    float\n        Value from self.data (potentially interpolated) corresponding to\n        the point (x, y, z).\n    \"\"\"\n    if method == \"cubic\":\n        data = self.cubic_spline_coeffs\n    else:\n        data = self.total\n\n    interpolator = Interpolator(\n        data=data,\n        method=method,\n    )\n    # interpolate value\n    return interpolator([x, y, z])[0]\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.values_at","title":"<code>values_at(frac_coords, method='cubic')</code>","text":"<p>Interpolates the value of the data at each fractional coordinate in a given list or array.</p> <p>Parameters:</p> Name Type Description Default <code>frac_coords</code> <code>NDArray</code> <p>The fractional coordinates to interpolate values at with shape N, 3.</p> required <code>method</code> <code>float</code> <p>The method to use for interpolation. nearest, linear, or cubic. The cubic method will calculate and store spline coefficients in an array the same size as the grid, which increases memory usage</p> <code>'cubic'</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>The interpolated value at each fractional coordinate.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def values_at(\n    self,\n    frac_coords: NDArray[float],\n    method: str = \"cubic\",\n) -&gt; list[float]:\n    \"\"\"\n    Interpolates the value of the data at each fractional coordinate in a\n    given list or array.\n\n    Parameters\n    ----------\n    frac_coords : NDArray\n        The fractional coordinates to interpolate values at with shape\n        N, 3.\n    method : float\n        The method to use for interpolation. nearest, linear, or cubic. The\n        cubic method will calculate and store spline coefficients in an\n        array the same size as the grid, which increases memory usage\n\n    Returns\n    -------\n    list[float]\n        The interpolated value at each fractional coordinate.\n\n    \"\"\"\n    if method == \"cubic\":\n        data = self.cubic_spline_coeffs\n    else:\n        data = self.total\n\n    interpolator = Interpolator(data=data, method=method)\n    # interpolate values\n    return interpolator(frac_coords)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.write","title":"<code>write(filename, output_format=None, **kwargs)</code>","text":"<p>Writes the Grid to the requested format file at the provided path. If no format is provided, uses this Grid objects stored format.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path | str</code> <p>The name of the file to write to.</p> required <code>output_format</code> <code>Format | str</code> <p>The format to write with. If None, writes to source format stored in this Grid objects metadata. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def write(\n    self,\n    filename: Path | str,\n    output_format: Format | str = None,\n    **kwargs,\n):\n    \"\"\"\n    Writes the Grid to the requested format file at the provided path. If no\n    format is provided, uses this Grid objects stored format.\n\n    Parameters\n    ----------\n    filename : Path | str\n        The name of the file to write to.\n    output_format : Format | str\n        The format to write with. If None, writes to source format stored in\n        this Grid objects metadata.\n        Defaults to None.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # If no provided format, get from metadata\n    if output_format is None:\n        output_format = self.source_format\n    # Make sure format is a Format object not a string\n    output_format = Format(output_format)\n    # get the writing method corresponding to this output format\n    method_name = output_format.writer\n    # write the grid\n    getattr(self, method_name)(filename, **kwargs)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.write_cube","title":"<code>write_cube(filename, **kwargs)</code>","text":"<p>Writes the Grid to a Gaussian cube-like file at the provided path.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path | str</code> <p>The name of the file to write to.</p> required <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def write_cube(\n    self,\n    filename: Path | str,\n    **kwargs,\n):\n    \"\"\"\n    Writes the Grid to a Gaussian cube-like file at the provided path.\n\n    Parameters\n    ----------\n    filename : Path | str\n        The name of the file to write to.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    filename = Path(filename)\n    logging.info(f\"Writing {filename.name}\")\n    write_cube_file(\n        filename=filename,\n        grid=self,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.write_vasp","title":"<code>write_vasp(filename, vasp4_compatible=False)</code>","text":"<p>Writes the Grid to a VASP-like file at the provided path.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path | str</code> <p>The name of the file to write to.</p> required <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def write_vasp(\n    self,\n    filename: Path | str,\n    vasp4_compatible: bool = False,\n):\n    \"\"\"\n    Writes the Grid to a VASP-like file at the provided path.\n\n    Parameters\n    ----------\n    filename : Path | str\n        The name of the file to write to.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    filename = Path(filename)\n    logging.info(f\"Writing {filename.name}\")\n    write_vasp_file(filename=filename, grid=self, vasp4_compatible=vasp4_compatible)\n</code></pre>"},{"location":"api_reference/core/labeler/","title":"ElfLabeler","text":"<p>Labels chemical features present in the ELF and collects various properties e.g charge, volume, elf value, etc. This is originally designed for analyzing electride materials, but could be quite useful for bond analysis as well.</p> <p>This class is designed only for single spin or total spin charge densities and ELF. For spin-dependent systems, use the SpinElfLabeler instead.</p> <p>Parameters:</p> Name Type Description Default <code>charge_grid</code> <code>Grid</code> <p>The charge density grid used for integrating charge.</p> required <code>reference_grid</code> <code>Grid</code> <p>The ELF grid used to partition volumes.</p> required <code>ignore_low_pseudopotentials</code> <code>bool</code> <p>Whether or not to ignore errors associated with the use of pseudopotentials with limited valence electrons. The default is False.</p> <code>False</code> <code>shared_shell_ratio</code> <code>float</code> <p>The ratio used to determine if shallow nodes surrounding an atom should be considered as a single shell feature.</p> <p>Highly symmetric features such as atom shells will often split into smaller features at a high isosurface value very close to the maximum value in these smaller features. This ratio refers to the range of values the ELF feature exists as a single feature divided by the highest ELF value in the feature.</p> <p>As covalency increases, this ratio will decrease as the small features grow and eventually form large covalent features that align along a bond. Thus, this parameter is in some ways a cutoff for considering a feature a covalent bond versus an ionic shell. The default is 0.75.</p> <code>0.75</code> <code>covalent_molecule_ratio</code> <code>float</code> <p>The ratio used to determine if an ELF feature belongs to one or multiple atomic shell systems.</p> <p>The covalent-ionic spectrum can be visualized in the ELF by comparing the ELF values at which Shell-like features form and fully surround atoms. \"Fully surround\" in this case means there is a void space within the shell that is not the same surface as the outside of the shell. In ionic bonds, the outermost shells will fully surround a single atom at a relatively high ELF value and will not connect to other features to surround additional atoms until considerably lower ELF values. In contrast, homogenous covalent bonds will never fully surround 1 atom, instead surrounding at least two when they first form a shell-like shape. Heterogenous covalent bonds sit somewhere between the two, surrounding a single atom for a small range of values before connecting to a feature surrounding additional atoms.</p> <p>The ratio here is the range of ELF values where the feature belongs to a parent feature surrounding multiple atoms divided by the range of values where it belongs to a parent feature surrounding only 1 atoms. This ratio can be fairly low even for slight EN differences, though it is usually significantly lower in clear ionic cases. The default is 0.2.</p> <code>0.2</code> <code>combine_shells</code> <code>bool</code> <p>Whether or not to combine the Bader basins making up a shell into a single feature. This is likely a more reasonable chemical perspective and reduces differences that arise from the inability of a regular cartesian grid to represent spherical shells. The default is True.</p> <code>True</code> <code>min_covalent_charge</code> <code>float</code> <p>The minimum charge that a feature must have to be considered covalent. This exists primarily to distinguish between highly covalent features and metallic features. The default is 0.6.</p> <code>0.6</code> <code>min_covalent_angle</code> <code>float</code> <p>The minimum angle between the two atoms and potential covalent feature for the feature to be considered a covalent bond. For example, most single covalent bonds sit exactly along the bond with an angle of 180. Triple bonds and metallic bonds with covalent-like behavior may form ring like shapes due to digeneracy with maxima slightly of the bond, decreasing this angle. The default is 135.</p> <code>135</code> <code>max_metal_depth</code> <code>float</code> <p>The maximum depth a feature can have and be considered metallic. Features between multiple atoms with a depth lower than this value will be marked as metallic. The default is 0.1.</p> <code>0.1</code> <code>min_electride_elf_value</code> <code>float</code> <p>The minimum ELF value for a feature to be considered an electride rather than a multi-centered bond. The default is 0.5.</p> <code>0.5</code> <code>min_electride_depth</code> <code>float</code> <p>The minimum range of ELF values a feature must exist distinctly to be considered an electride rather than a multi-centered bond. The default is 0.2.</p> <code>0.2</code> <code>min_electride_charge</code> <code>float</code> <p>The minimum charge a feature must have to be considered an electride rather than a multi-centered bond. The default is 0.5.</p> <code>0.5</code> <code>min_electride_volume</code> <code>float</code> <p>The minimum volume a feature must have to be considered an electride rather than a multi-centered bond. The default is 10.</p> <code>10</code> <code>min_electride_dist_beyond_atom</code> <code>float</code> <p>The minimum distance beyond the atoms radius that an electride must sit to be considered an electride rather than a multi-centered bond. The radius is calculated as the minimum in the ELF between two atoms. If a covalent or metallic bond is present, the maximum is used instead. The default is 0.3.</p> <code>0.3</code> <code>crystalnn_kwargs</code> <code>dict</code> <p>The keyword arguments used to create the CrystalNN object used for nearest neighbor calculations. This is only important for calculating charges on atoms when splitting covalent/metallic features to their nearest neighbors.</p> <code>{'distance_cutoffs': None, 'x_diff_weight': 0.0, 'porous_adjustment': False}</code> <code>vacuum_tol</code> <code>float | bool</code> <p>The tolerance for considering a region to be part of the vacuum. The tolerance is compared to the charge density, not the ELF. The default is 0.001.</p> <code>0.001</code> <code>shallow_reducible_cutoff</code> <code>float</code> <p>The cutoff for removing shallow reducible domains. If the ratio of a domains depth to its parents depth is below this value, it will be removed. This is primarily to handle small differences due to voxelation. The default of 0.05 is usually sufficient.</p> <code>0.05</code> <code>shallow_irreducible_cutoff</code> <code>float</code> <p>The cutoff for combining shallow irreducible domains. If all children of a reducible node have depths significantly lower than its own, they will be combined into a single irreducible domain.. This is primarily to handle small differences due to voxelation or very small/shallow basins. The default of 0.1 is usually sufficient.</p> <code>0.1</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the Bader class.</p> <code>{}</code> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>class ElfLabeler:\n    \"\"\"\n    Labels chemical features present in the ELF and collects various properties\n    e.g charge, volume, elf value, etc.\n    This is originally designed for analyzing electride materials, but could be\n    quite useful for bond analysis as well.\n\n    This class is designed only for single spin or total spin charge densities\n    and ELF. For spin-dependent systems, use the SpinElfLabeler instead.\n\n    Parameters\n    ----------\n    charge_grid : Grid\n        The charge density grid used for integrating charge.\n    reference_grid : Grid\n        The ELF grid used to partition volumes.\n    ignore_low_pseudopotentials : bool, optional\n        Whether or not to ignore errors associated with the use of pseudopotentials\n        with limited valence electrons. The default is False.\n    shared_shell_ratio : float, optional\n        The ratio used to determine if shallow nodes surrounding an atom should\n        be considered as a single shell feature.\n\n        Highly symmetric features such\n        as atom shells will often split into smaller features at a high isosurface\n        value very close to the maximum value in these smaller features. This\n        ratio refers to the range of values the ELF feature exists as a\n        single feature divided by the highest ELF value in the feature.\n\n        As covalency increases, this ratio will decrease as the small features\n        grow and eventually form large covalent features that align along a bond.\n        Thus, this parameter is in some ways a cutoff for considering a\n        feature a covalent bond versus an ionic shell. The default is 0.75.\n    covalent_molecule_ratio : float, optional\n        The ratio used to determine if an ELF feature belongs to one or multiple\n        atomic shell systems.\n\n        The covalent-ionic spectrum can be visualized in the ELF by comparing\n        the ELF values at which Shell-like features form and fully surround\n        atoms. \"Fully surround\" in this case means there is a void space\n        within the shell that is not the same surface as the outside of the shell.\n        In ionic bonds, the outermost shells will fully surround a single atom\n        at a relatively high ELF value and will not connect to other features\n        to surround additional atoms until considerably lower ELF values.\n        In contrast, homogenous covalent bonds will never fully surround 1 atom,\n        instead surrounding at least two when they first form a shell-like\n        shape. Heterogenous covalent bonds sit somewhere between the two,\n        surrounding a single atom for a small range of values before connecting\n        to a feature surrounding additional atoms.\n\n        The ratio here is the range of ELF values where the feature belongs\n        to a parent feature surrounding multiple atoms divided by the range of values\n        where it belongs to a parent feature surrounding only 1 atoms. This\n        ratio can be fairly low even for slight EN differences, though it is\n        usually significantly lower in clear ionic cases.\n        The default is 0.2.\n    combine_shells : bool, optional\n        Whether or not to combine the Bader basins making up a shell into a\n        single feature. This is likely a more reasonable chemical perspective\n        and reduces differences that arise from the inability of a regular\n        cartesian grid to represent spherical shells. The default is True.\n    min_covalent_charge : float, optional\n        The minimum charge that a feature must have to be considered covalent.\n        This exists primarily to distinguish between highly covalent features\n        and metallic features. The default is 0.6.\n    min_covalent_angle : float, optional\n        The minimum angle between the two atoms and potential covalent feature for\n        the feature to be considered a covalent bond. For example, most single\n        covalent bonds sit exactly along the bond with an angle of 180. Triple\n        bonds and metallic bonds with covalent-like behavior may form ring\n        like shapes due to digeneracy with maxima slightly of the bond, decreasing\n        this angle. The default is 135.\n    max_metal_depth : float, optional\n        The maximum depth a feature can have and be considered metallic. Features\n        between multiple atoms with a depth lower than this value will be marked\n        as metallic. The default is 0.1.\n    min_electride_elf_value : float, optional\n        The minimum ELF value for a feature to be considered an electride rather\n        than a multi-centered bond. The default is 0.5.\n    min_electride_depth : float, optional\n        The minimum range of ELF values a feature must exist distinctly to\n        be considered an electride rather than a multi-centered bond. The default is 0.2.\n    min_electride_charge : float, optional\n        The minimum charge a feature must have to be considered an electride\n        rather than a multi-centered bond. The default is 0.5.\n    min_electride_volume : float, optional\n        The minimum volume a feature must have to be considered an electride\n        rather than a multi-centered bond. The default is 10.\n    min_electride_dist_beyond_atom : float, optional\n        The minimum distance beyond the atoms radius that an electride must\n        sit to be considered an electride rather than a multi-centered bond. The radius\n        is calculated as the minimum in the ELF between two atoms. If a covalent\n        or metallic bond is present, the maximum is used instead. The default is 0.3.\n    crystalnn_kwargs : dict, optional\n        The keyword arguments used to create the CrystalNN object used for\n        nearest neighbor calculations. This is only important for calculating\n        charges on atoms when splitting covalent/metallic features to their\n        nearest neighbors.\n    vacuum_tol : float | bool, optional\n        The tolerance for considering a region to be part of the vacuum. The\n        tolerance is compared to the charge density, not the ELF. The default\n        is 0.001.\n    shallow_reducible_cutoff : float, optional\n        The cutoff for removing shallow reducible domains. If the ratio of a\n        domains depth to its parents depth is below this value, it will be\n        removed. This is primarily to handle small differences due to voxelation.\n        The default of 0.05 is usually sufficient.\n    shallow_irreducible_cutoff : float, optional\n        The cutoff for combining shallow irreducible domains. If all children of\n        a reducible node have depths significantly lower than its own, they will\n        be combined into a single irreducible domain.. This is primarily to handle\n        small differences due to voxelation or very small/shallow basins.\n        The default of 0.1 is usually sufficient.\n    **kwargs : dict\n        Keyword arguments to pass to the Bader class.\n\n    \"\"\"\n\n    _labeled_covalent = False\n    _labeled_multi = False\n    spin_system = \"total\"\n\n    def __init__(\n        self,\n        charge_grid: Grid,\n        reference_grid: Grid,\n        ignore_low_pseudopotentials: bool = False,\n        shared_shell_ratio: float = 0.75,\n        covalent_molecule_ratio: float = 0.2,\n        combine_shells: bool = True,\n        min_covalent_charge: float = 0.6,\n        min_covalent_angle: float = 135,\n        max_metal_depth: float = 0.1,\n        min_electride_elf_value: float = 0.5,\n        min_electride_depth: float = 0.2,\n        min_electride_charge: float = 0.5,\n        min_electride_volume: float = 10,\n        min_electride_dist_beyond_atom: float = 0.3,\n        crystalnn_kwargs: dict = {\n            \"distance_cutoffs\": None,\n            \"x_diff_weight\": 0.0,\n            \"porous_adjustment\": False,\n        },\n        vacuum_tol=1.0e-03,\n        shallow_reducible_cutoff: float = 0.05,\n        shallow_irreducible_cutoff: float = 0.1,\n        **kwargs,\n    ):\n\n        # ensure the reference file is ELF\n        if reference_grid.data_type != \"elf\":\n            logging.warning(\n                \"A non-ELF reference file has been detected. Results may not be valid.\"\n            )\n\n        self.charge_grid = charge_grid\n        self.reference_grid = reference_grid\n\n        self.ignore_low_pseudopotentials = ignore_low_pseudopotentials\n        self.crystalnn_kwargs = crystalnn_kwargs\n        self.cnn = CrystalNN(**crystalnn_kwargs)\n        # BUGFIX: We use a separate cnn with very loose rules to find neighbors\n        # that may potentially have the smallest radius. This is intentionally\n        # separate from the cnn used to calculate NNs for features\n        self._radii_cnn = CrystalNN(\n            weighted_cn=True,\n            distance_cutoffs=None,\n            x_diff_weight=0.0,\n            porous_adjustment=False,\n        )\n\n        # define cutoff variables\n        # TODO: These should be hidden variables to allow for setter methods\n        self.shared_shell_ratio = shared_shell_ratio\n        self.covalent_molecule_ratio = covalent_molecule_ratio\n        self.combine_shells = combine_shells\n        self.min_covalent_charge = min_covalent_charge\n        self.min_covalent_angle = min_covalent_angle\n        self.shallow_reducible_cutoff = shallow_reducible_cutoff\n        self.shallow_irreducible_cutoff = shallow_irreducible_cutoff\n\n        # electride cutoffs\n        self.min_electride_elf_value = min_electride_elf_value\n        self.min_electride_charge = min_electride_charge\n        self.min_electride_depth = min_electride_depth\n        self.min_electride_charge = min_electride_charge\n        self.min_electride_volume = min_electride_volume\n        self.min_electride_dist_beyond_atom = min_electride_dist_beyond_atom\n\n        # define properties that will be updated by running the method\n        self._bifurcations = None\n        self._bifurcation_graph = None\n        self._bifurcation_plot = None\n        self._atom_elf_radii = None\n        self._atom_elf_radii_types = None\n        self._atom_elf_radii_e = None\n        self._atom_elf_radii_types_e = None\n        self._atom_nn_elf_radii = None\n        self._atom_nn_elf_radii_e = None\n        self._atom_nn_elf_radii_types = None\n        self._atom_nn_elf_radii_types_e = None\n        self._nearest_neighbor_data = None\n        self._nearest_neighbor_data_e = None\n        self._atom_feature_indices_e = None\n        self._atom_max_values_e = None\n        self._atom_nn_planes = None\n        self._atom_nn_planes_e = None\n\n        self._electrides_per_formula = None\n        self._electrides_per_reduced_formula = None\n\n        # create a bader object\n        self.bader = Bader(\n            charge_grid=charge_grid,\n            reference_grid=reference_grid,\n            vacuum_tol=vacuum_tol,\n            use_reference_vacuum=False,\n            **kwargs,\n        )\n\n    # TODO: Make these reset on a change similar to the Bader class. Add docs\n\n    ###########################################################################\n    # Bifurcation Properties\n    ###########################################################################\n\n    @property\n    def bifurcation_graph(self) -&gt; BifurcationGraph:\n        \"\"\"\n\n        Returns\n        -------\n        BifurcationGraph\n            A BifurcationGraph class representing features and bifurcations in the\n            ELF.\n\n        \"\"\"\n        if self._bifurcation_graph is None:\n            self._get_bifurcation_graph()\n        return self._bifurcation_graph\n\n    @property\n    def bifurcation_plot(self) -&gt; go.Figure:\n        \"\"\"\n\n        Returns\n        -------\n        go.Figure\n            A plotly graph object representing the bifurcation graph.\n\n        \"\"\"\n        if self._bifurcation_plot is None:\n            self._bifurcation_plot = self.bifurcation_graph.get_plot()\n        return self._bifurcation_plot\n\n    ###########################################################################\n    # Structure Properties\n    ###########################################################################\n    @property\n    def structure(self) -&gt; Structure:\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The PyMatGen Structure representing the system.\n\n        \"\"\"\n        return self.reference_grid.structure\n\n    @property\n    def electride_structure(self) -&gt; Structure:\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The system's structure including dummy atoms representing electride\n            sites.\n\n        \"\"\"\n        return self.bifurcation_graph.electride_structure\n\n    @property\n    def labeled_structure(self) -&gt; Structure:\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The system's structure including dummy atoms representing electride\n            sites and covalent/metallic bonds. Features unique to the spin-up/spin-down\n            systems will have xu or xd appended to the species name respectively.\n            Features that exist in both will have nothing appended.\n\n        \"\"\"\n        return self.bifurcation_graph.labeled_structure\n\n    @property\n    def nelectrides(self) -&gt; int:\n        \"\"\"\n\n        Returns\n        -------\n        int\n            The number of electride sites in the structure\n\n        \"\"\"\n        return len(self.electride_structure) - len(self.structure)\n\n    @property\n    def electride_formula(self):\n        \"\"\"\n\n        Returns\n        -------\n        str\n            A string representation of the electride formula, rounding partial charge\n            to the nearest integer.\n\n        \"\"\"\n        return f\"{self.structure.formula} e{round(self.electrides_per_formula)}\"\n\n    @property\n    def electrides_per_formula(self):\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The number of electride electrons for the full structure formula.\n\n        \"\"\"\n        if self._electrides_per_formula is None:\n            electrides_per_unit = 0\n            for i, node in enumerate(self.bifurcation_graph.irreducible_nodes):\n                if node.feature_type in FeatureType.bare_types:\n                    electrides_per_unit += self.feature_charges[i]\n            self._electrides_per_formula = electrides_per_unit\n        return round(self._electrides_per_formula, 10)\n\n    @property\n    def electrides_per_reduced_formula(self):\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The number of electrons in the reduced formula of the structure.\n\n        \"\"\"\n        if self._electrides_per_reduced_formula is None:\n            (\n                _,\n                formula_reduction_factor,\n            ) = self.structure.composition.get_reduced_composition_and_factor()\n            self._electrides_per_reduced_formula = (\n                self.electrides_per_formula / formula_reduction_factor\n            )\n        return round(self._electrides_per_reduced_formula, 10)\n\n    ###########################################################################\n    # Coordination Environment\n    ###########################################################################\n\n    @property\n    def nearest_neighbor_data(self) -&gt; tuple:\n        \"\"\"\n\n        Returns\n        -------\n        tuple\n            The nearest neighbor data for the atoms in the system represented as\n            a tuple of arrays. The arrays represent, in order, the central\n            atoms index, its neighbors index, the fractional coordinates of the\n            neighbor, and the distance between the two sites.\n\n        \"\"\"\n        if self._nearest_neighbor_data is None:\n            # run bifurcation assignment\n            self.bifurcation_graph\n        return self._nearest_neighbor_data\n\n    @property\n    def nearest_neighbor_data_e(self):\n        \"\"\"\n\n        Returns\n        -------\n        tuple\n            The nearest neighbor data for the atoms AND the electrides\n            in the system represented as a tuple of arrays. The arrays represent,\n            in order, the central atoms index, its neighbors index, the fractional\n            coordinates of the neighbor, and the distance between the two sites.\n\n        \"\"\"\n        if self._nearest_neighbor_data_e is None:\n            # run assignment\n            self.atom_nn_elf_radii_e\n        return self._nearest_neighbor_data_e\n\n    ###########################################################################\n    # Atom and Electride quasi-atom Properties\n    ###########################################################################\n\n    @property\n    def atom_elf_radii(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The radius of each atom calculated from the ELF using the closest\n            neighboring atom in the structure.\n\n        \"\"\"\n        if self._atom_elf_radii is None:\n            self._atom_elf_radii, self._atom_elf_radii_types = self._get_atom_elf_radii(\n                self.structure,\n                self.atom_nn_elf_radii,\n                self._atom_nn_elf_radii_types,\n                self.nearest_neighbor_data,\n            )\n\n        return self._atom_elf_radii.round(10)\n\n    @property\n    def atom_elf_radii_types(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The type of radius of each elf radius. Covalent indicates that the\n            bond crosses through some covalent or metallic region, and the radius\n            is placed at the maximum in the ELF in this region. Ionic indicates\n            that the bond does not pass through the covalent/metallic region and\n            the radius is placed at the minimum between the two atoms.\n\n        \"\"\"\n        if self._atom_elf_radii_types is None:\n            # run labeling and radii calc by calling our bifurcation graph\n            self._atom_elf_radii = None\n            self.atom_elf_radii\n        return np.where(self._atom_elf_radii_types, \"covalent\", \"ionic\")\n\n    @property\n    def atom_elf_radii_e(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The radius of each atom and electride site calculated from the ELF\n            using the closest neighboring atom/electride in the structure.\n\n        \"\"\"\n        if self._atom_elf_radii_e is None:\n            # make sure bifurcation graph has been constructed\n            self.bifurcation_graph\n            # calculate elf radii\n            self._atom_elf_radii_e, self._atom_elf_radii_types_e = (\n                self._get_atom_elf_radii(\n                    self.electride_structure,\n                    self.atom_nn_elf_radii_e,\n                    self._atom_nn_elf_radii_types_e,\n                    self.nearest_neighbor_data_e,\n                )\n            )\n        return self._atom_elf_radii_e.round(10)\n\n    @property\n    def atom_elf_radii_types_e(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The type of radius of each atom/electride elf radius. Covalent indicates that the\n            bond crosses through some covalent or metallic region, and the radius\n            is placed at the maximum in the ELF in this region. Ionic indicates\n            that the bond does not pass through the covalent/metallic region and\n            the radius is placed at the minimum between the two atoms.\n\n        \"\"\"\n        if self._atom_elf_radii_types_e is None:\n            # run labeling and radii calc by calling our bifurcation graph\n            self.atom_elf_radii_e\n        return np.where(self._atom_elf_radii_types_e, \"covalent\", \"ionic\")\n\n    @property\n    def atom_nn_elf_radii(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The elf radii for each atom and its neighboring atoms in the same\n            order as the nearest_neighbor_data property.\n\n        \"\"\"\n        if self._atom_nn_elf_radii is None:\n            self.bifurcation_graph\n        return self._atom_nn_elf_radii\n\n    @property\n    def atom_nn_elf_radii_types(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The type of radius for each atom and its neighboring atoms in the same\n            order as the nearest_neighbor_data property.\n\n        \"\"\"\n        if self._atom_nn_elf_radii_types is None:\n            # call radii method\n            self.atom_nn_elf_radii\n        return np.where(self._atom_nn_elf_radii_types, \"covalent\", \"ionic\")\n\n    @property\n    def atom_nn_elf_radii_e(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The elf radii for each atom/electride and its neighboring atoms in the same\n            order as the nearest_neighbor_data_e property.\n\n        \"\"\"\n        if self._atom_nn_elf_radii_e is None:\n            # make sure labeled bifurcation graph exists\n            if self._labeled_covalent is None:\n                self.bifurcation_graph\n            # if there are no electride atoms, just return the results for the base\n            # structure (avoid repeat calc)\n            if len(self.structure) == len(self.electride_structure):\n                self._atom_nn_elf_radii_e = self.atom_nn_elf_radii\n                self._atom_nn_elf_radii_types_e = self._atom_nn_elf_radii_types\n                self._nearest_neighbor_data_e = self.nearest_neighbor_data\n                self._atom_nn_planes_e = self._atom_nn_planes\n            else:\n                (\n                    site_indices,\n                    neigh_indices,\n                    neigh_coords,\n                    radii,\n                    dists,\n                    bond_types,\n                    plane_points,\n                    plane_vectors,\n                ) = self._get_nn_atom_elf_radii(use_electrides=True)\n                self._atom_nn_elf_radii_e = radii\n                self._atom_nn_elf_radii_types_e = bond_types\n                self._nearest_neighbor_data_e = (\n                    site_indices,\n                    neigh_indices,\n                    neigh_coords,\n                    dists,\n                )\n                self._atom_nn_planes_e = (plane_points, plane_vectors)\n\n        return self._atom_nn_elf_radii_e\n\n    @property\n    def atom_nn_elf_radii_types_e(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The type of radius for each atom/electride and its neighboring atoms in the same\n            order as the nearest_neighbor_data property.\n\n        \"\"\"\n        if self._atom_nn_elf_radii_types_e is None:\n            # call radii method\n            self.atom_nn_elf_radii_e\n        return np.where(self._atom_nn_elf_radii_types, \"covalent\", \"ionic\")\n\n    @property\n    def atom_feature_indices_e(self) -&gt; NDArray[np.int64]:\n        \"\"\"\n\n        Returns\n        -------\n        list\n            The feature indices assigned to each atom/electride in the electride\n            structure. Features assigned to multiple atoms are not included.\n\n        \"\"\"\n        # For each atom, a list of feature indices that belong solely to that\n        # atom\n        if self._atom_feature_indices_e is None:\n            atom_features = [[] for i in range(len(self.electride_structure))]\n            # add atom indices\n            for feat_idx, node in enumerate(self.bifurcation_graph.irreducible_nodes):\n                if (\n                    node.coord_number == 1\n                    and node.feature_type not in FeatureType.bare_types\n                ):\n                    atom_features[node.coord_indices_e[0]].append(feat_idx)\n            # add electride indices\n            electride_num = 0\n            for i, node in enumerate(self.bifurcation_graph.irreducible_nodes):\n                if node.feature_type in FeatureType.bare_types:\n                    atom_features[len(self.structure) + electride_num].append(i)\n                    electride_num += 1\n            self._atom_feature_indices_e = atom_features\n        return self._atom_feature_indices_e\n\n    @property\n    def atom_max_values_e(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The maximum value that each atom has an existing feature.\n\n        \"\"\"\n        if self._atom_max_values_e is None:\n            feature_max_values = self.feature_max_values\n            max_values = []\n            for i, feature_indices in enumerate(self.atom_feature_indices_e):\n                max_values.append(np.max(feature_max_values[feature_indices]))\n\n            self._atom_max_values_e = np.array(max_values)\n        return self._atom_max_values_e.round(10)\n\n    ###########################################################################\n    # Vacuum Properties\n    ###########################################################################\n    @property\n    def vacuum_charge(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The charge assigned to the vacuum.\n\n        \"\"\"\n        return self.bader.vacuum_charge\n\n    @property\n    def vacuum_volume(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total volume assigned to the vacuum.\n\n        \"\"\"\n        return self.bader.vacuum_volume\n\n    @property\n    def vacuum_mask(self) -&gt; NDArray[bool]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[bool]\n            A mask representing the voxels that belong to the vacuum.\n\n        \"\"\"\n        return self.bader.vacuum_mask\n\n    @property\n    def num_vacuum(self) -&gt; int:\n        \"\"\"\n\n        Returns\n        -------\n        int\n            The number of vacuum points in the array\n\n        \"\"\"\n        return self.bader.num_vacuum\n\n    @property\n    def total_electron_number(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total number of electrons in the system calculated from the\n            atom charges and vacuum charge. If this does not match the true\n            total electron number within reasonable floating point error,\n            there is a major problem.\n\n        \"\"\"\n\n        return round(self.feature_charges.sum() + self.vacuum_charge, 10)\n\n    @property\n    def total_volume(self):\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total volume integrated in the system. This should match the\n            volume of the structure. If it does not there may be a serious problem.\n\n        \"\"\"\n\n        return round(self.feature_volumes.sum() + self.vacuum_volume, 10)\n\n    ###########################################################################\n    # Feature Properties\n    ###########################################################################\n\n    def _get_feature_properties(self, property_name: str) -&gt; list:\n        \"\"\"\n        Collects the request property for each feature in the BifurcationGraph\n\n        Parameters\n        ----------\n        property_name : str\n            The name of the property to collect\n\n        Returns\n        -------\n        features : list\n            The properties for each feature.\n\n        \"\"\"\n        features = []\n        for node in self.bifurcation_graph.irreducible_nodes:\n            features.append(getattr(node, property_name, None))\n        return features\n\n    @property\n    def feature_types(self) -&gt; list[str]:\n        \"\"\"\n\n        Returns\n        -------\n        list[str]\n            The type of each ELF feature in the system.\n\n        \"\"\"\n        return self._get_feature_properties(\"feature_type\")\n\n    @property\n    def feature_basins(self) -&gt; list[NDArray]:\n        \"\"\"\n\n        Returns\n        -------\n        list[NDArray]\n            The Bader basins associated with each feature. For features with\n            multiple basins, the basins are separated by very shallow minima\n            and are better understood as a single feature.\n\n        \"\"\"\n        return self._get_feature_properties(\"basins\")\n\n    @property\n    def feature_frac_coords(self) -&gt; list[NDArray]:\n        \"\"\"\n\n        Returns\n        -------\n        list[NDArray]\n            The fractional coordinates of the maxima in each Bader basin\n            for each feature in the structure.\n\n        \"\"\"\n        return self._get_feature_properties(\"frac_coords\")\n\n    @property\n    def feature_average_frac_coords(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The average fractional coordinates of the Bader basin maxima for each\n            feature. Note that it is possible for this coordinate to be outside\n            of the feature, particularly for atom shells which form sphere-like\n            shapes.\n\n        \"\"\"\n        return np.array(self._get_feature_properties(\"average_frac_coords\"))\n\n    @property\n    def feature_max_values(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The maximum value at which each feature exists.\n\n        \"\"\"\n        return np.array(self._get_feature_properties(\"max_value\")).round(10)\n\n    @property\n    def feature_min_values(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The minimum value at which each feature exists.\n\n        \"\"\"\n        return np.array(self._get_feature_properties(\"min_value\")).round(10)\n\n    @property\n    def feature_charges(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The charge associated with each feature.\n\n        \"\"\"\n        return np.array(self._get_feature_properties(\"charge\")).round(10)\n\n    @property\n    def feature_volumes(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The volume associated with each feature.\n\n        \"\"\"\n        return np.array(self._get_feature_properties(\"volume\")).round(10)\n\n    @property\n    def feature_coord_atoms(self) -&gt; list:\n        \"\"\"\n\n        Returns\n        -------\n        list\n            The atoms coordinated with each feature.\n\n        \"\"\"\n        return self._get_feature_properties(\"coord_indices\")\n\n    @property\n    def feature_coord_nums(self) -&gt; list:\n        \"\"\"\n\n        Returns\n        -------\n        list\n            The number of atoms coordinated with each feature.\n\n        \"\"\"\n        return np.array(self._get_feature_properties(\"coord_number\"), dtype=np.int64)\n\n    @property\n    def feature_coord_dists(self) -&gt; list:\n        \"\"\"\n\n        Returns\n        -------\n        list\n            The distance to each coordinated atom from each feature.\n\n        \"\"\"\n        return self._get_feature_properties(\"coord_dists\")\n\n    @property\n    def feature_coord_atoms_e(self) -&gt; list:\n        \"\"\"\n\n        Returns\n        -------\n        list\n            The coordinated atoms to each feature, including electrides as quasi-atoms\n\n        \"\"\"\n        return self._get_feature_properties(\"coord_indices_e\")\n\n    @property\n    def feature_coord_nums_e(self) -&gt; list:\n        \"\"\"\n\n        Returns\n        -------\n        list\n            The number of coordinated atoms for each featuree, including\n            electrides as quasi-atoms.\n\n        \"\"\"\n        return np.array(self._get_feature_properties(\"coord_number_e\"), dtype=np.int64)\n\n    @property\n    def feature_coord_atoms_dists_e(self):\n        \"\"\"\n\n        Returns\n        -------\n        list\n            The distance to each coordinated atom/electride from each feature.\n\n        \"\"\"\n        return self._get_feature_properties(\"coord_dists_e\")\n\n    @property\n    def feature_min_surface_dists(self) -&gt; list:\n        \"\"\"\n\n        Returns\n        -------\n        list\n            The minimum distance from the average frac coord of each feature to the\n            partitioning surface.\n\n        \"\"\"\n        return np.array(self._get_feature_properties(\"min_surface_dist\")).round(10)\n\n    @property\n    def feature_avg_surface_dists(self) -&gt; NDArray:\n        \"\"\"\n\n        Returns\n        -------\n        list\n            The average distance from the average frac coord of each feature to the\n            partitioning surface.\n\n        \"\"\"\n        return np.array(self._get_feature_properties(\"avg_surface_dist\")).round(10)\n\n    ###########################################################################\n    # Helpful Methods\n    ###########################################################################\n    def feature_indices_by_type(self, feature_types: list[FeatureType | str]):\n        \"\"\"\n\n        Gets a list of feature indices from a list of types of Features\n        (e.g. bare electron, metallic, covalent)\n\n        Parameters\n        ----------\n        feature_types : list[FeatureType | str]\n            The list of feature types to find indices for.\n\n        Returns\n        -------\n        NDArray\n            A list of feature indices corresponding to all feature types in the\n            provided list. These correspond to the order in which feature properties\n            (e.g. ElfLabeler.feature_charges) appear in.\n\n        \"\"\"\n        return np.array(\n            [i for i, feat in enumerate(self.feature_types) if feat in feature_types],\n            dtype=np.int64,\n        )\n\n    def get_oxidation_and_volumes_from_potcar(\n        self, potcar_path: Path = \"POTCAR\", use_electrides: bool = True, **kwargs\n    ) -&gt; tuple[NDArray]:\n        \"\"\"\n        Calculates the oxidation states, charges, and volumes associated with each\n        atom/electride using the information from a provided POTCAR.\n\n        Parameters\n        ----------\n        potcar_path : Path, optional\n            The path to the POTCAR file. The default is \"POTCAR\".\n        use_electrides : bool, optional\n            Whether or not to treat electrides as quasi atoms. The default is True.\n        **kwargs : dict\n            Any keyword arguments to pass to the 'get_charges_and_volumes' method.\n\n        Returns\n        -------\n        tuple[NDArray]\n            three arrays representing the oxidation states, charges, and volumes\n            respectively.\n\n        \"\"\"\n        charges, volumes = self.get_charges_and_volumes(\n            use_electrides=use_electrides, **kwargs\n        )\n        # convert to path\n        potcar_path = Path(potcar_path)\n        # load\n        with warnings.catch_warnings(record=True):\n            potcars = Potcar.from_file(potcar_path)\n        nelectron_data = {}\n        # the result is a list because there can be multiple element potcars\n        # in the file (e.g. for NaCl, POTCAR = POTCAR_Na + POTCAR_Cl)\n        for potcar in potcars:\n            nelectron_data.update({potcar.element: potcar.nelectrons})\n        # calculate oxidation states\n        if use_electrides:\n            structure = self.electride_structure\n        else:\n            structure = self.structure\n\n        oxi_state_data = []\n        for site, site_charge in zip(structure, charges):\n            element_str = site.specie.symbol\n            val_electrons = nelectron_data.get(element_str, 0.0)\n            oxi_state = val_electrons - site_charge\n            oxi_state_data.append(oxi_state)\n\n        return np.array(oxi_state_data).round(10), charges.round(10), volumes.round(10)\n\n    def get_charges_and_volumes(\n        self,\n        splitting_method: Literal[\n            \"weighted_dist\", \"pauling\", \"equal\", \"dist\", \"nearest\"\n        ] = \"weighted_dist\",\n        use_electrides: bool = True,\n        **kwargs,\n    ) -&gt; tuple[NDArray]:\n        \"\"\"\n        Assign charge from each feature to their associated atoms. For features\n        that have multiple neighbors (e.g. covalent bonds), several options\n        are provided for how to divide the charge to nearby neighbors.\n        If use_electrides is set to True, features with electride like character\n        will be treated as atoms and\n\n        Parameters\n        ----------\n        splitting_method : Literal[\"equal\", \"pauling\", \"dist\", \"weighted_dist\", \"nearest\"], optional\n            The method used to divide charge and volume of shared features\n            betweeen their coordinating atoms.\n\n                'weighted_dist' (default)\n                    Fraction increases with decreasing distance to each atom. The\n                    fraction is further weighted by the radius of each atom\n                    calculated from the ELF\n                'pauling'\n                    Fraction increases with decreasing pauling electronegativity.\n                    If an atom has no recorded EN a value of 2.2 is used which\n                    may be incorrect in many cases.\n                'equal'\n                    Each neighboring atom receives an equal fraction.\n                'dist'\n                    Fraction increases with decreasing distance to the center\n                    of each atom\n                'nearest'\n                    All charge is assigned to the features nearest atom.\n\n        use_electrides : bool, optional\n            If True, features labeled as bare electrons will be treated as electride\n            atoms. They will receive partial charge from other shared features\n            and their charge/volume will be appended after the atoms'.\n\n        Returns\n        -------\n        tuple[NDArray]\n            Two arrays representing the charges and volumes respectively.\n\n        \"\"\"\n        if use_electrides:\n            structure = self.electride_structure\n        else:\n            structure = self.structure\n\n        # create an array to store atom charges and volumes\n        atom_charge = np.zeros(len(structure), dtype=np.float64)\n        atom_volume = np.zeros(len(structure), dtype=np.float64)\n\n        # if using pauling, get all electronegativities\n        if splitting_method == \"pauling\":\n            pauling_ens = np.array([i.specie.X for i in structure])\n            pauling_ens = np.nan_to_num(pauling_ens, nan=2.2)\n\n        electride_num = 0\n        for feature_idx in range(len(self.feature_types)):\n            charge = self.feature_charges[feature_idx]\n            volume = self.feature_volumes[feature_idx]\n\n            if use_electrides:\n                # check if this is an electride feature\n                if self.feature_types[feature_idx] in FeatureType.bare_types:\n                    # assign charge/volume to self\n                    struc_idx = len(self.structure) + electride_num\n                    atom_charge[struc_idx] += charge\n                    atom_volume[struc_idx] += volume\n                    electride_num += 1\n                    continue\n\n                # get coordination with electrides\n                coord_atoms = self.feature_coord_atoms_e[feature_idx]\n            else:\n                # get coordination without electrides\n                coord_atoms = self.feature_coord_atoms[feature_idx]\n            # get unique atoms and counts (correction for small cells)\n            unique_atoms, unique_indices, atom_counts = np.unique(\n                coord_atoms, return_index=True, return_counts=True\n            )\n\n            if len(coord_atoms) == 0:\n                # This shouldn't happen, but could if CrystalNN failed\n                # to find neighbors.\n                logging.warning(\n                    f\"No neighboring atoms found for feature with index {feature_idx}. Feature assigned to nearest atom.\"\n                )\n                # assign all charge/volume to the closest atom\n                nearest = np.argmin(self.feature_coord_dists[feature_idx])\n                atom_charge[nearest] += charge\n                atom_volume[nearest] += volume\n\n            elif len(coord_atoms) == 1:\n                # all methods will add charge and volume to this atom.\n                # assigning it here potentially avoids divide by zeros for\n                # core features\n                atom_charge[coord_atoms[0]] += charge\n                atom_volume[coord_atoms[0]] += volume\n\n            elif splitting_method == \"equal\":\n                # evenly split the feature to each neighboring atom\n                atom_charge[unique_atoms] += (charge / len(coord_atoms)) * atom_counts\n                atom_volume[unique_atoms] += (volume / len(coord_atoms)) * atom_counts\n\n            elif splitting_method == \"pauling\":\n                # get the pauling ens for coordinated atoms\n                ens = pauling_ens[coord_atoms]\n                # normalize to the total en\n                ens /= ens.sum()\n                # get the weights for each unique atom\n                ens = ens[unique_indices]\n                atom_charge[unique_atoms] += charge * ens * atom_counts\n                atom_volume[unique_atoms] += volume * ens * atom_counts\n\n            elif splitting_method == \"dist\":\n                # get the dist to each coordinated atom\n                if use_electrides:\n                    dists = self.feature_coord_atoms_dists_e[feature_idx].copy()\n                else:\n                    dists = self.feature_coord_dists[feature_idx].copy()\n                # invert and normalize\n                dists = 1 / dists\n                dists /= dists.sum()\n                # add for each atom\n                for coord_idx, atom in enumerate(coord_atoms):\n                    atom_charge[atom] += charge * dists[coord_idx]\n                    atom_volume[atom] += volume * dists[coord_idx]\n\n            elif splitting_method == \"weighted_dist\":\n                # get the dist to each coordinated atom and their radii\n                if use_electrides:\n                    dists = self.feature_coord_atoms_dists_e[feature_idx].copy()\n                    atom_radii = self.atom_elf_radii_e[coord_atoms]\n                else:\n                    dists = self.feature_coord_dists[feature_idx].copy()\n                    atom_radii = self.atom_elf_radii[coord_atoms]\n\n                # calculate the weighted contribution to each atom and normalize\n                weight = atom_radii / dists\n                weight /= weight.sum()\n                # add for each atom\n                for coord_idx, atom in enumerate(coord_atoms):\n                    atom_charge[atom] += charge * weight[coord_idx]\n                    atom_volume[atom] += volume * weight[coord_idx]\n\n            elif splitting_method == \"nearest\":\n                # assign all charge/volume to the closest atom\n                nearest = np.argmin(self.feature_coord_dists[feature_idx])\n                atom_charge[nearest] += charge\n                atom_volume[nearest] += volume\n            else:\n                raise ValueError(\n                    f\"'{splitting_method}' is not a valid splitting method\"\n                )\n\n        return atom_charge.round(10), atom_volume.round(10)\n\n    def get_feature_labels(\n        self,\n        included_features: list[str] = FeatureType.valence_types,\n        return_structure: bool = True,\n        return_feat_indices: bool = False,\n        return_charge_volume: bool = False,\n        order_by_type: bool = True,\n    ) -&gt; tuple:\n        \"\"\"\n\n        Assigns each grid point to atoms and features included in the 'included_features'\n        tag. The assignments are represented by an array with the same dimensions\n        as the charge/reference grids with integers representing the atom/feature\n        index in the Structure object including requested feature dummy atoms.\n        By default this method orders requested features so that atoms\n        come first, followed by electrides, and then any other feature types. This\n        is for methods such as BadELF which rely on this ordering scheme.\n\n        Atoms are included by default and it is generally not recommended to include\n        core/shell features. If these are of interest to you, reach out to us\n        on our [github](https://github.com/SWeav02/baderkit)\n\n        Parameters\n        ----------\n        included_features : list[str], optional\n            The features to include in addition to the atoms. The default is FeatureType.valence_types.\n        return_structure : bool, optional\n            Whether or not to return the structure that the index labels correspond\n            to. The default is True.\n        return_feat_indices : bool, optional\n            Whether or not to return the original feature indices in their new\n            order. The default is False.\n        order_by_type : bool, optional\n            Whether or not to reorder the structure prior to assigning to\n            grid points. The default is True.\n        return_charge_volume : bool, optional\n            Whether or not to return the corresponding charge/volume associated\n            with each feature\n\n        Returns\n        -------\n        tuple\n            An array representing grid point assignments. If return_structure or\n            return_feat_indices is set to True, these are returned as well. The\n            returned result is always a tuple, even if only the feature assignments\n            are requested.\n\n        \"\"\"\n\n        # Get the original basin atom assignments\n        basin_atoms = self.bader.basin_atoms.copy()\n\n        # get indices of requested type\n        feature_indices = self.feature_indices_by_type(included_features)\n\n        # reorder features so that electrides are first if requested\n        if order_by_type:\n            bare_feature_indices = []\n            other_feature_indices = []\n            for feat_idx in feature_indices:\n                if self.feature_types[feat_idx] in FeatureType.bare_types:\n                    bare_feature_indices.append(feat_idx)\n                else:\n                    other_feature_indices.append(feat_idx)\n            feature_indices = bare_feature_indices + other_feature_indices\n\n        # reassign basin atoms and get structure\n        feature_structure = self.structure.copy()\n        new_atom_idx = len(self.structure)\n        for sorted_idx, feat_idx in enumerate(feature_indices):\n            # update basin labels\n            basins = self.feature_basins[feat_idx]\n            basin_atoms[basins] = new_atom_idx\n            new_atom_idx += 1\n            # add feature to structure\n            species = self.feature_types[feat_idx].dummy_species\n            coords = self.feature_average_frac_coords[feat_idx]\n            feature_structure.append(species, coords)\n\n        # NOTE: append -1 so that vacuum gets assigned to -1 in the atom_labels\n        # array\n        basin_atoms = np.insert(basin_atoms, len(basin_atoms), -1)\n\n        # reassign labels\n        feature_labels = basin_atoms[self.bader.basin_labels]\n\n        # get requested results\n        if not any((return_structure, return_feat_indices, return_charge_volume)):\n            return feature_labels\n        results = [feature_labels]\n        if return_structure:\n            results.append(feature_structure)\n\n        if return_feat_indices:\n            results.append(feature_indices)\n\n        if return_charge_volume:\n            basin_atoms = basin_atoms[:-1]\n\n            atom_charges = np.bincount(\n                basin_atoms,\n                weights=self.bader.basin_charges,\n                minlength=len(feature_structure),\n            )\n            atom_volumes = np.bincount(\n                basin_atoms,\n                weights=self.bader.basin_volumes,\n                minlength=len(feature_structure),\n            )\n            results.append(atom_charges)\n            results.append(atom_volumes)\n\n        # return labels\n        return tuple(results)\n\n    def get_feature_structure(\n        self,\n        included_features: list[str] = FeatureType.valence_types,\n        return_feat_indices: bool = False,\n        order_by_type: bool = True,\n    ) -&gt; Structure:\n        \"\"\"\n\n        Generates a PyMatGen Structure object with dummy atoms for each requested\n        feature. By default this method orders requested features so that atoms\n        come first, followed by electrides, and then any other feature types.\n\n        Parameters\n        ----------\n        included_features : list[str], optional\n            The features to include in addition to the atoms. The default is FeatureType.valence_types.\n        return_feat_indices : bool, optional\n            Whether or not to return the original feature indices in their new\n            order. The default is False.\n        order_by_type : bool, optional\n            Whether or not to reorder the structure. The default is True.\n\n        Returns\n        -------\n        Structure\n            DESCRIPTION.\n\n        \"\"\"\n        # get indices of requested type\n        feature_indices = self.feature_indices_by_type(included_features)\n\n        # reorder features so that electrides are first if requested\n        if order_by_type:\n            bare_feature_indices = []\n            other_feature_indices = []\n            for feat_idx in feature_indices:\n                if self.feature_types[feat_idx] in FeatureType.bare_types:\n                    bare_feature_indices.append(feat_idx)\n                else:\n                    other_feature_indices.append(feat_idx)\n            feature_indices = bare_feature_indices + other_feature_indices\n\n        # get structure from indices\n        structure = self.get_feature_structure_by_index(feature_indices)\n\n        if return_feat_indices:\n            return structure, feature_indices\n\n        return structure\n\n    def get_feature_structure_by_index(self, feature_indices: list[int]) -&gt; Structure:\n        \"\"\"\n\n        Generates a PyMatGen Structure object with dummy atoms for each requested\n        feature. This method does not reorder features.\n\n        Parameters\n        ----------\n        feature_indices : list[int]\n            The indices of features to include.\n\n        Returns\n        -------\n        structure : Structure\n            The system's PyMatGen Structure including dummy atoms representing\n            requested features.\n\n        \"\"\"\n\n        # Create a new structure without oxidation states\n        structure = self.structure.copy()\n        structure.remove_oxidation_states()\n\n        # add each feature\n        for feat_idx in feature_indices:\n            structure.append(\n                self.feature_types[feat_idx].dummy_species,\n                self.feature_average_frac_coords[feat_idx],\n            )\n\n        return structure\n\n    ###########################################################################\n    # Hidden Utility Methods\n    ###########################################################################\n\n    def _get_nn_atom_elf_radii(\n        self,\n        use_electrides: bool = False,\n    ) -&gt; tuple:\n        \"\"\"\n\n        Calculate the ELF radius for all atom neighbor pairs that result in partitioning\n        planes lying on the voronoi surface\n\n        Parameters\n        ----------\n        use_electrides : bool, optional\n            Whether or not to treat electrides as quasi-atoms. The default is False.\n\n        Returns\n        -------\n        tuple\n            The radius for each atom/neighbor pair and their bond type (0=ionic, 1=covalent)\n\n        \"\"\"\n        if not self._labeled_covalent:\n            raise Exception(\"Covalent features must be labeled for reliable radii.\")\n        # get appropriate structure and neighbor data\n        if use_electrides:\n            structure = self.electride_structure\n            # we don't treat electride atoms as metals in this case, as we are\n            # treating them like quasi atoms\n            covalent_types = [\n                i for i in FeatureType.valence_types if i not in FeatureType.bare_types\n            ]\n        else:\n            structure = self.structure\n            # we do treat electride atoms as metals/covalent features\n            covalent_types = FeatureType.valence_types\n\n        # Get a labeled structure including covalent, metallic, and bare\n        # electron features\n        included_types = FeatureType.valence_types.copy()\n        feature_labels, feature_structure = self.get_feature_labels(\n            included_features=included_types\n        )\n        covalent_symbols = np.unique([i.dummy_species for i in covalent_types])\n        # Calculate all radii on the voronoi surface\n        radii_tools = ElfRadiiTools(\n            grid=self.reference_grid,\n            feature_labels=feature_labels,\n            feature_structure=feature_structure,\n            override_structure=structure,\n            covalent_symbols=covalent_symbols,\n        )\n        return radii_tools.get_voronoi_radii()\n        # return radii_tools.get_crystalnn_radii()\n\n    @staticmethod\n    def _get_atom_elf_radii(structure, all_radii, all_radii_types, nn_data) -&gt; tuple:\n        \"\"\"\n        Gets the smallest radius for each atom from the provided data.\n\n        Parameters\n        ----------\n        structure : Structure\n            The structure corresponding to the atoms to find radii for.\n        all_radii : NDArray\n            All radii between all atoms and their nearest neighbors.\n        all_radii_types : NDArray\n            All radii types for all atom/neighbor pairs.\n        nn_data : NDArray\n            Four arrays representing the coordination environment of the provided\n            structure.\n\n        Returns\n        -------\n        tuple\n            The radii and radius types for each atom (0=ionic, 1=covalent)\n\n        \"\"\"\n        # NOTE: This is the smallest radius of each atom which is not always\n        # along the bond to the nearest neighbor, but typically is. For\n        # example CdPt3 has 2 Pt atoms with a Cd an dPt atom tied for the\n        # nearest.\n        site_indices, neigh_indices, neigh_coords, dists = nn_data\n\n        # sort radii\n        sorted_indices = np.argsort(all_radii)\n        sorted_sites = site_indices[sorted_indices]\n\n        # get first instance of each atom\n        radii = np.empty(len(structure), dtype=np.float64)\n        radii_types = np.empty(len(structure), dtype=all_radii_types.dtype)\n\n        for i in range(len(structure)):\n            first_index = np.argmax(sorted_sites == i)\n            radii[i] = all_radii[sorted_indices[first_index]]\n            radii_types[i] = all_radii_types[sorted_indices[first_index]]\n        return radii, radii_types\n\n    def _calculate_feature_surface_dists(self):\n        \"\"\"\n\n        Calculates the distance from the average coordinates to the surface grid\n        points for each feature node.\n\n        \"\"\"\n        # Calculate the minimum and average distance from each irreducible features\n        # fractional coordinate to its edges. This is often different from the\n        # original basins as we may combine some of them.\n\n        nodes = self.bifurcation_graph.irreducible_nodes\n\n        # collect frac coords and map basin labels to features\n        frac_coords = [i.average_frac_coords for i in nodes]\n        feature_map = np.empty(len(self.bader.basin_maxima_frac), dtype=np.uint32)\n        for node_idx, node in enumerate(nodes):\n            feature_map[node.basins] = node_idx\n\n        # get feature edges\n        neighbor_transforms, _ = self.reference_grid.point_neighbor_transforms\n\n        edge_mask = get_feature_edges(\n            labeled_array=self.bader.basin_labels,\n            feature_map=feature_map,\n            neighbor_transforms=neighbor_transforms,\n            vacuum_mask=self.bader.vacuum_mask,\n        )\n\n        # calculate the minimum and average distance to each features surface\n        min_dists, avg_dists = get_min_avg_feat_surface_dists(\n            labels=self.bader.basin_labels,\n            feature_map=feature_map,\n            frac_coords=np.array(frac_coords, dtype=np.float64),\n            edge_mask=edge_mask,\n            matrix=self.reference_grid.matrix,\n            max_value=np.max(self.structure.lattice.abc) * 2,\n        )\n\n        # set surface distances\n        for node, min_dist, avg_dist in zip(nodes, min_dists, avg_dists):\n            node._min_surface_dist = min_dist\n            node._avg_surface_dist = avg_dist\n\n    ###########################################################################\n    # Read Methods\n    ###########################################################################\n    @classmethod\n    def from_vasp(\n        cls,\n        charge_filename: Path | str = \"CHGCAR\",\n        reference_filename: Path | str = \"ELFCAR\",\n        total_only: bool = True,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Creates an ElfLabeler class object from VASP files.\n\n        Parameters\n        ----------\n        charge_filename : Path | str, optional\n            The path to the CHGCAR like file that will be used for summing charge.\n            The default is \"CHGCAR\".\n        reference_filename : Path | str\n            The path to ELFCAR like file that will be used for partitioning.\n            If None, the charge file will be used for partitioning.\n        total_only: bool\n            If true, only the first set of data in the file will be read. This\n            increases speed and reduced memory usage as the other data is typically\n            not used.\n            Defaults to True.\n        **kwargs : dict\n            Keyword arguments to pass to the Labeler class.\n\n        Returns\n        -------\n        Self\n            An ElfLabeler class object.\n\n        \"\"\"\n        # This is just a wrapper of the Bader class to update the default to\n        # load the ELFCAR\n        charge_grid = Grid.from_vasp(charge_filename, total_only=total_only)\n        reference_grid = Grid.from_vasp(reference_filename, total_only=total_only)\n\n        return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n\n    ###########################################################################\n    # Write Methods\n    ###########################################################################\n\n    def write_bifurcation_plot(\n        self,\n        filename: str | Path,\n    ):\n        \"\"\"\n\n        Writes the BifurcationPlot to an html file. This is just a shortcut for\n        ElfLabeler.bifurcation_plot.write_html.\n\n        Parameters\n        ----------\n        filename : str | Path\n            The Path to write the plot to. 'html' will be appended if it is not\n            present in the path.\n\n        \"\"\"\n        plot = self.bifurcation_plot\n        # make sure path is a Path object\n        filename = Path(filename)\n        # add .html if filename doesn't include it\n        filename_html = filename.with_suffix(\".html\")\n        plot.write_html(filename_html)\n\n    def write_feature_basins(\n        self,\n        feature_indices: list[int],\n        directory: str | Path = Path(\".\"),\n        include_dummy_atoms: bool = True,\n        write_reference: bool = True,\n        output_format: str | Format = None,\n        prefix_override: str = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        For a give list of node keys, writes the bader basins associated with\n        each.\n\n        Parameters\n        ----------\n        feature_indices : list[int]\n            Which features to write basin volumes for.\n        directory : str | Path, optional\n            The directory to write the files in. If None, the active directory\n            is used.\n        include_dummy_atoms : bool, optional\n            Whether or not to add dummy files to the structure. The default is False.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n\n        \"\"\"\n        # get the data to use\n        if write_reference:\n            data_array = self.reference_grid.total\n            data_type = self.reference_grid.data_type\n        else:\n            data_array = self.charge_grid.total\n            data_type = self.charge_grid.data_type\n\n        if directory is None:\n            directory = Path(\".\")\n\n        # get structure\n        if include_dummy_atoms:\n            structure = self.get_feature_structure_by_index(feature_indices)\n        else:\n            structure = self.structure\n\n        # get prefix\n        if prefix_override is None:\n            prefix_override = data_type.prefix\n\n        for feat_idx in feature_indices:\n            basins = self.feature_basins[feat_idx]\n            # get mask where this feature is NOT\n            mask = np.isin(self.bader.basin_labels, basins, invert=True)\n            # copy data to avoid overwriting. Set data off of basin to 0\n            data_array_copy = data_array.copy()\n            data_array_copy[mask] = 0.0\n            grid = Grid(\n                structure=structure,\n                data={\"total\": data_array_copy},\n                data_type=data_type,\n            )\n            file_path = directory / f\"{prefix_override}_f{feat_idx}\"\n            # write file\n            grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n\n    def write_feature_basins_sum(\n        self,\n        feature_indices: list[int],\n        directory: str | Path = Path(\".\"),\n        include_dummy_atoms: bool = False,\n        write_reference: bool = True,\n        output_format: str | Format = None,\n        prefix_override: str = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        For a give list of node keys, writes the union of the bader basins\n        associated with each.\n\n        Parameters\n        ----------\n        feature_indices : list[int]\n            Which features to include in the volume.\n        directory : str | Path, optional\n            The directory to write the files in. If None, the active directory\n            is used.\n        include_dummy_atoms : bool, optional\n            Whether or not to add dummy files to the structure. The default is False.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n        \"\"\"\n        # get the data to use\n        if write_reference:\n            data_array = self.reference_grid.total\n            data_type = self.reference_grid.data_type\n        else:\n            data_array = self.charge_grid.total\n            data_type = self.charge_grid.data_type\n\n        if directory is None:\n            directory = Path(\".\")\n\n        # get structure\n        if include_dummy_atoms:\n            structure = self.get_feature_structure_by_index(feature_indices)\n        else:\n            structure = self.structure\n\n        # get prefix\n        if prefix_override is None:\n            prefix_override = data_type.prefix\n\n        # get all basin indices to include\n        basin_list = []\n        for feat_idx in feature_indices:\n            basin_list.extend(self.feature_basins[feat_idx])\n\n        # get mask where features are not\n        mask = np.isin(self.bader.basin_labels, basin_list, invert=True)\n        # copy data to avoid overwriting. Set data off of basin to 0\n        data_array_copy = data_array.copy()\n        data_array_copy[mask] = 0.0\n        grid = Grid(\n            structure=structure,\n            data={\"total\": data_array_copy},\n            data_type=data_type,\n        )\n        file_path = directory / f\"{prefix_override}_fsum\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n\n    def write_all_features(self, **kwargs):\n        \"\"\"\n        Writes the bader basins associated with all features\n\n        Parameters\n        ----------\n        **kwargs :\n            See :meth:`write_feature_basins`.\n\n        \"\"\"\n        self.write_feature_basins(\n            feature_indices=np.arange(len(self.feature_charges), dtype=int), **kwargs\n        )\n\n    def write_features_by_type(\n        self,\n        included_types: list[FeatureType],\n        prefix_override=None,\n        write_reference: bool = True,\n        directory: str | Path = Path(\".\"),\n        **kwargs,\n    ):\n        \"\"\"\n        Writes the bader basins associated with all features of the selected type\n\n        Parameters\n        ----------\n        included_types : list[FeatureType]\n            The types of features to include, e.g. metallic, lone-pair, etc.\n        prefix_override : str\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is True.\n        **kwargs :\n            See :meth:`write_feature_basins`.\n\n        \"\"\"\n        # get the data to use\n        if write_reference:\n            data_type = self.reference_grid.data_type\n        else:\n            data_type = self.charge_grid.data_type\n        # get prefix\n        if prefix_override is None:\n            prefix_override = data_type.prefix\n        for feature_type in included_types:\n            feature_type = FeatureType(feature_type)\n            feature_indices = self.feature_indices_by_type([feature_type])\n            prefix = prefix_override + f\"_{feature_type.dummy_species}\"\n            self.write_feature_basins_sum(\n                feature_indices=feature_indices,\n                prefix_override=prefix,\n                directory=directory,\n                **kwargs,\n            )\n\n            # rename to remove fsum\n            os.rename(\n                directory / f\"{prefix}_fsum\",\n                directory / f\"{prefix}\",\n            )\n\n    def write_features_by_type_sum(\n        self,\n        included_types: list[FeatureType],\n        **kwargs,\n    ):\n        \"\"\"\n        Writes the union of the bader basins associated with all features of the\n        selected type\n\n        Parameters\n        ----------\n        **kwargs :\n            See :meth:`write_feature_basins_sum`.\n\n        \"\"\"\n        feature_indices = self.feature_indices_by_type(included_types)\n        self.write_feature_basins_sum(feature_indices=feature_indices, **kwargs)\n\n    def to_dict(\n        self,\n        potcar_path: Path | str = \"POTCAR\",\n        use_json: bool = True,\n        splitting_method: Literal[\n            \"equal\", \"pauling\", \"dist\", \"weighted_dist\", \"nearest\"\n        ] = \"weighted_dist\",\n    ) -&gt; dict:\n        \"\"\"\n\n        Gets a dictionary summary of the ElfLabeler analysis.\n\n        Parameters\n        ----------\n        potcar_path : Path | str, optional\n            The Path to a POTCAR file. This must be provided for oxidation states\n            to be calculated, and they will be None otherwise. The default is \"POTCAR\".\n        use_json : bool, optional\n            Convert all entries to JSONable data types. The default is True.\n        splitting_method : Literal[\"equal\", \"pauling\", \"dist\", \"weighted_dist\", \"nearest\"], optional\n            See :meth:`write_feature_basins`.\n\n        Returns\n        -------\n        dict\n            A summary of the ElfLabeler analysis in dictionary form.\n\n        \"\"\"\n        results = {}\n        # collect method kwargs\n        method_kwargs = {\n            \"splitting_method\": splitting_method,\n            \"crystalnn_kwargs\": self.crystalnn_kwargs,\n            \"ignore_low_pseudopotentials\": self.ignore_low_pseudopotentials,\n            \"shared_shell_ratio\": self.shared_shell_ratio,\n            \"covalent_molecule_ratio\": self.covalent_molecule_ratio,\n            \"min_covalent_charge\": self.min_covalent_charge,\n            \"min_covalent_angle\": self.min_covalent_angle,\n            \"min_electride_elf_value\": self.min_electride_elf_value,\n            \"min_electride_depth\": self.min_electride_depth,\n            \"min_electride_charge\": self.min_electride_charge,\n            \"min_electride_volume\": self.min_electride_volume,\n            \"min_electride_dist_beyond_atom\": self.min_electride_dist_beyond_atom,\n        }\n        results[\"method_kwargs\"] = method_kwargs\n        results[\"spin_system\"] = self.spin_system\n\n        # only try to calculate oxidation state if this was not a half spin system\n        potcar_path = Path(potcar_path)\n        if self.spin_system == \"total\" and potcar_path.exists():\n            oxidation_states, charges, volumes = (\n                self.get_oxidation_and_volumes_from_potcar(\n                    potcar_path=potcar_path, use_electrides=False\n                )\n            )\n            oxidation_states_e, charges_e, volumes_e = (\n                self.get_oxidation_and_volumes_from_potcar(\n                    potcar_path=potcar_path, use_electrides=True\n                )\n            )\n        else:\n            oxidation_states = None\n            oxidation_states_e = None\n            charges, volumes = self.get_charges_and_volumes(use_electrides=False)\n            charges_e, volumes_e = self.get_charges_and_volumes(use_electrides=True)\n        if oxidation_states is not None:\n            oxidation_states = oxidation_states.tolist()\n            oxidation_states_e = oxidation_states_e.tolist()\n        results[\"oxidation_states\"] = oxidation_states\n        results[\"oxidation_states_e\"] = oxidation_states_e\n        results[\"charges\"] = charges.tolist()\n        results[\"charges_e\"] = charges_e.tolist()\n        results[\"volumes\"] = volumes.tolist()\n        results[\"volumes_e\"] = volumes_e.tolist()\n\n        # add objects that can convert to json\n        for result in [\n            \"structure\",\n            \"labeled_structure\",\n            \"electride_structure\",\n            \"bifurcation_graph\",\n        ]:\n            result_obj = getattr(self, result, None)\n            if result_obj is not None and use_json:\n                result_obj = result_obj.to_json()\n            results[result] = result_obj\n\n        # add objects that are arrays\n        for result in [\n            \"atom_elf_radii\",\n            \"atom_elf_radii_types\",\n            \"atom_elf_radii_e\",\n            \"atom_elf_radii_types_e\",\n            \"atom_max_values_e\",\n            \"feature_max_values\",\n            \"feature_min_values\",\n            \"feature_charges\",\n            \"feature_volumes\",\n            \"feature_coord_nums\",\n            \"feature_coord_nums_e\",\n            \"feature_min_surface_dists\",\n            \"feature_avg_surface_dists\",\n        ]:\n            result_obj = getattr(self, result, None)\n            if use_json and result_obj is not None:\n                result_obj = result_obj.tolist()\n            results[result] = result_obj\n\n        # add objects that are lists with arrays\n        for result in [\n            \"feature_coord_dists\",\n            \"feature_coord_atoms_dists_e\",\n        ]:\n            result_obj = getattr(self, result, None)\n            if use_json and result_obj is not None:\n                result_obj = [i.tolist() for i in result_obj]\n            results[result] = result_obj\n\n        # add other objects that are already jsonable\n        for result in [\n            \"nelectrides\",\n            \"electride_formula\",\n            \"electrides_per_formula\",\n            \"electrides_per_reduced_formula\",\n            \"feature_types\",\n            \"feature_coord_atoms\",\n            \"feature_coord_atoms_e\",\n            \"atom_feature_indices_e\",\n            \"total_electron_number\",\n            \"total_volume\",\n            \"vacuum_charge\",\n            \"vacuum_volume\",\n        ]:\n            results[result] = getattr(self, result, None)\n\n        return results\n\n    def to_json(self, **kwargs) -&gt; str:\n        \"\"\"\n        Creates a JSON string representation of the results, typically for writing\n        results to file.\n\n        Parameters\n        ----------\n        **kwargs : dict\n            Keyword arguments for the to_dict method.\n\n        Returns\n        -------\n        str\n            A JSON string representation of the BadELF results.\n\n        \"\"\"\n        return json.dumps(self.to_dict(use_json=True, **kwargs))\n\n    def write_json(self, filepath: Path | str = \"elf_labeler.json\", **kwargs) -&gt; None:\n        \"\"\"\n        Writes results of the analysis to file in a JSON format.\n\n        Parameters\n        ----------\n        filepath : Path | str, optional\n            The Path to write the results to. The default is \"elf_labeler.json\".\n        **kwargs : dict\n            keyword arguments for the to_dict method.\n\n        \"\"\"\n        filepath = Path(filepath)\n        with open(filepath, \"w\") as json_file:\n            json.dump(self.to_dict(use_json=True, **kwargs), json_file, indent=4)\n\n    ###########################################################################\n    # Core Graph Construction\n    ###########################################################################\n\n    def _get_bifurcation_graph(self):\n        \"\"\"\n\n        This constructs a BifurcationGraph class and labels each irreducible feature\n        as a chemical feature. This is the core of the method and is not meant to\n        be called directly.\n\n        \"\"\"\n        # run bader for nice looking logging purposes\n        # NOTE: I call a property rather than run_bader/run_atom_assignment to\n        # avoid repeat calcs if we've already run\n        self.bader.atom_labels\n\n        logging.info(\"Beginning ELF Analysis\")\n\n        # get an initial graph connecting bifurcations and final basins\n        self._initialize_bifurcation_graph()\n\n        # Now we have a graph with information associated with each basin. We want\n        # to label each node. First, we label cores as they are the simplest\n        self._mark_cores()\n\n        # Next, we mark shells. This step distinguishes ionic and covalent\n        # features, the most ambiguous step\n        self._mark_shells()\n\n        # Next we label covalent bonds. These must lie along an atomic bond and\n        # have a reasonably large charge\n        self._mark_covalent()\n\n        # Next we mark lone pairs. These split off from covalent bonds or rarely\n        # from atomic shells (e.g. SnO)\n        self._mark_lonepairs()\n\n        # get atomic radii before checking for metal/bare.\n        # NOTE: This intentionally may underestimates radii in metallic systems.\n        # For metal systems, we would treat metal maxima similar to covalent\n        # bonds. For electrides, we would treat maxima as part of a separate\n        # \"electride atom\"\n        logging.info(\"Calculating atomic radii\")\n        (\n            site_indices,\n            neigh_indices,\n            neigh_coords,\n            radii,\n            dists,\n            bond_types,\n            plane_points,\n            plane_vectors,\n        ) = self._get_nn_atom_elf_radii(use_electrides=False)\n        self._atom_nn_elf_radii = radii\n        self._atom_nn_elf_radii_types = bond_types\n        self._nearest_neighbor_data = (site_indices, neigh_indices, neigh_coords, dists)\n        self._atom_nn_planes = (plane_points, plane_vectors)\n\n        # Next we mark our metallic/bare electrons. These currently have a set\n        # of rather arbitrary cutoffs to distinguish between them. In the future\n        # I would like to perform a comprehensive study.\n        self._mark_metallic_or_bare()\n\n        # BUGFIX: The atomic radii are somewhat dependent on if we consider a\n        # feature to be metallic or a qausi-atom. We first calculate the radii\n        # assuming electride atoms to allow for the best chance of a feature getting\n        # through the \"dist_beyond_atom\" cutoff. Then we recalculate and relabel\n        # so that metallic systems have the proper label\n        # Recalculate radii with our updated markers\n        # logging.info(\"Re-calculating atomic radii\")\n        # self._atom_elf_radii = None\n        # self._atom_elf_radii_types = None\n        # self._atom_nn_elf_radii, self._atom_nn_elf_radii_types = self._get_nn_atom_elf_radii(self.structure, self.nearest_neighbor_data)\n\n        # # Re-mark metallic/electrides\n        # self._mark_metallic_or_bare()\n\n        # In some cases, the user may not have used a pseudopotential with enough core electrons.\n        # This can result in an atom having no assigned core/shell, which will\n        # result in nonsense later. We check for this here and throw an error\n        assigned_atoms = []\n        for node in self.bifurcation_graph.get_feature_nodes(FeatureType.atomic_types):\n            assigned_atoms.append(node.nearest_atom)\n        if (\n            len(np.unique(assigned_atoms)) != len(self.structure)\n            and not self.ignore_low_pseudopotentials\n        ):\n            raise Exception(\n                \"At least one atom was not assigned a zero-flux basin. This typically results\"\n                \"from pseudo-potentials (PPs) with only valence electrons (e.g. the defaults for Al, Si, B in VASP 5.X.X).\"\n                \"Try using PPs with more valence electrons such as VASP's GW potentials\"\n            )\n        # Finally, we ensure that all nodes have an assignment\n        if len(self.bifurcation_graph.unassigned_nodes) &gt; 0:\n            raise Exception(\n                \"At least one ELF feature was not assigned. This is a bug!!! Please report it to our github:\"\n                \"https://github.com/SWeav02/baderkit/issues\"\n            )\n\n        # calculate feature surface distances\n        self._calculate_feature_surface_dists()\n        logging.info(\"Finished labeling ELF\")\n\n    def _initialize_bifurcation_graph(self):\n        \"\"\"\n\n        Creates an initial unlabeled bifurcation graph using information from\n        Bader analysis of the ELF.\n\n        \"\"\"\n        self._bifurcation_graph = BifurcationGraph.from_labeler(self)\n\n    ###############################################################################\n    # Core feature labeling methods\n    ###############################################################################\n\n    def _mark_cores(self):\n        logging.info(\"Marking atomic shells\")\n        # cores are reducible domains that contain an atom. They should be within\n        # one voxel of the atom. We must check for this as it is possible for\n        # a different type of basin to contain the atom if too few valence electrons\n        # are in the pseudopotential\n        max_dist = self.reference_grid.max_point_dist * 2\n        for node in self.bifurcation_graph.unassigned_nodes:\n            if node.domain_subtype == DomainSubtype.irreducible_cage:\n                continue\n            if len(node.contained_atoms) != 1:\n                continue\n            if node.atom_distance &lt;= max_dist:\n                node.feature_type = FeatureType.shell\n\n    def _mark_shells(self):\n        # shells are reducible domains that surround exactly one atom.\n        # In a vacuum, an atoms shells are spherical due to symmetry. In a\n        # molecule/solid they will warp due to interactions with neighboring\n        # atoms. If a neighbor has a strong enough attraction, the shell will\n        # break into multiple child domains (covalent/lone-pairs). If its even\n        # stronger, the shell will move fully to the neighbor (ionic bond) and\n        # form a shell there.\n\n        # Our criteria for a shell domain is as follows:\n        # 1. Surrounds 1 atom\n        # 2. Is 0D (finite)\n        # 3. Exists as a shell in a much larger range than as individual child\n        # domains\n\n        # First, we label any nodes that surround 1 atom but don't have a maximum\n        # at the atoms nucleus. This often happens for particularly shallow shells\n        # if they are combined when our graph is first generated\n        for node in self.bifurcation_graph.unassigned_nodes:\n            if len(node.contained_atoms) == 1:\n                node.feature_type = \"shell\"\n\n        # Now we label shells that may be slightly deeper. We compare the range\n        # where the domain surrounds 1 atom to the range itself or any of its children\n        # exist. The ratio is compared to our cutoff\n\n        shell_nodes = []\n        for node in self.bifurcation_graph.reducible_nodes:\n            # skip nodes that don't surround a single atom or have a dimensionality above 0\n            if node.is_infinite or len(node.contained_atoms) != 1:\n                continue\n            # skip nodes that have children that also contain the single atom\n            if any([len(i.contained_atoms) == 1 for i in node.children]):\n                continue\n\n            # Get the depth of the domain\n            shared_shell_depth = node.depth\n\n            # Get the total range this node or its children exist\n            max_elf = 0.0\n            for child in node.deep_children:\n                if child.max_value &gt; max_elf:\n                    max_elf = child.max_value\n            total_depth = max_elf - node.min_value\n\n            ratio = shared_shell_depth / total_depth\n            if ratio &gt; self.shared_shell_ratio:\n                shell_nodes.append(node)\n                print(ratio)\n\n        # mark nodes as shells\n        for node in shell_nodes:\n            if self.combine_shells:\n                # convert to an irreducible node\n                node = node.make_irreducible()\n                node.feature_type = \"shell\"\n            else:\n                for child in node.deep_children:\n                    if not child.is_reducible:\n                        child.subtype = \"shell\"\n\n    def _mark_covalent(self):\n        \"\"\"\n        Takes in a bifurcation graph and labels valence features that\n        are obviously metallic or covalent\n        \"\"\"\n        logging.info(\"Marking covalent features\")\n        graph = self.bifurcation_graph\n\n        # get frac coords of unassigned nodes\n        valence_nodes = []\n        valence_frac = []\n        for node in graph.unassigned_nodes:\n            valence_frac.append(node.average_frac_coords)\n            valence_nodes.append(node)\n\n        # Convert our cutoff angle to radians\n        min_covalent_angle = self.min_covalent_angle * math.pi / 180\n\n        # get our atom frac coords\n        atom_frac_coords = self.structure.frac_coords\n        atom_cart_coords = self.structure.cart_coords\n\n        # check which nodes are within our tolerance\n        # if/then is to avoid numba disliking empty lists\n        if len(valence_frac) &gt; 0:\n            nodes_in_tolerance, atom_neighs = check_all_covalent(\n                valence_frac,\n                atom_frac_coords,\n                atom_cart_coords,\n                frac2cart=self.structure.lattice.matrix,\n                min_covalent_angle=min_covalent_angle,\n            )\n        else:\n            nodes_in_tolerance, atom_neighs = [], []\n\n        for node, in_tolerance, (atom0, atom1) in zip(\n            valence_nodes, nodes_in_tolerance, atom_neighs\n        ):\n            # skip nodes that aren't within our angle tolerance\n            if not in_tolerance:\n                continue\n\n            # set backup\n            contained_atoms = node.ancestors[-1].contained_atoms\n            if atom0 in contained_atoms and atom1 in contained_atoms:\n                is_covalent = True\n            else:\n                is_covalent = False  # could happen if there are multiple roots\n\n            # Sometimes a lone pair happens to align well with an atom that\n            # is not part of our covalent system (e.g. CaC2). Similar to shells,\n            # the range of values containing both atoms should be comparable to\n            # the rane of values containing at least one of them.\n            # POSSIBLE BUG: Atoms with translational symmetry might be counted\n            # as part of multiple covalent systems and break this in small\n            # unit cells. This would require knowing which atom image is contained\n            # which we currently don't track and would require a large rework\n\n            # find range of values containing at least one and both of the atoms\n            one_atom = None\n            both_atoms = None\n            for parent in node.ancestors:\n                contained_atoms = parent.contained_atoms\n                if atom0 in contained_atoms or atom1 in contained_atoms:\n                    if one_atom is None:\n                        one_atom = parent.max_value\n                if atom0 in contained_atoms and atom1 in contained_atoms:\n                    if both_atoms is None:\n                        both_atoms = parent.max_value\n                        break\n\n            is_covalent = (both_atoms / one_atom) &gt;= self.covalent_molecule_ratio\n\n            # check that we truly only have two nearest neighbors\n            if is_covalent and not node.coord_number == 2:\n                is_covalent = False\n\n            if is_covalent:\n                # label as covalent or metallic covalent depending on the species'\n                # type and charge\n                species1 = self.structure[int(atom0)].specie\n                species2 = self.structure[int(atom1)].specie\n                if species1.is_metal or species2.is_metal:\n                    if node.charge &gt; self.min_covalent_charge:\n                        node.feature_type = FeatureType.covalent_metallic\n                    else:\n                        # this is a metal bond but it has very low charge\n                        node.feature_type = FeatureType.shallow_covalent_metallic\n                    # we also go ahead and set the neighboring atoms to avoid some\n                    # CrystalNN calculations\n                    node._coord_indices = [int(atom0), int(atom1)]\n                elif node.charge &gt; self.min_covalent_charge:\n                    node.feature_type = FeatureType.covalent\n                    node._coord_indices = [int(atom0), int(atom1)]\n\n        # note we've labeled our covalent features\n        self._labeled_covalent = True\n\n    def _mark_lonepairs(self):\n        logging.info(\"Marking lone-pair features\")\n        # lone-pairs separate off from covalent bonds or rarely from an ionic\n        # core/shell. When breaking from covalent bonds, the lone-pair will only\n        # have one nearest neighbor in the molecule. When breaking off of\n        # an ionic core/shell, the lone-pair will at some point be part of a\n        # domain surrounding a single atom.\n\n        # POSSIBLE BUG:\n        # In small cells, if a feature neighbors the same atoms at different\n        # translations and both belong to the same molecule/domain, it may\n        # be mislabeled as a lone-pair instead of a metal bond\n        assigned_nodes = []\n        for node in self.bifurcation_graph.irreducible_nodes:\n            if not node.feature_type in [\n                None,\n                FeatureType.unknown,\n                FeatureType.shallow_covalent_metallic,\n            ]:\n                # NOTE: exclude shallow covalent metal features in case these end up being\n                # misassigned deep shells. Not sure if this is necessary\n                assigned_nodes.append(node.key)\n\n        nodes = self.bifurcation_graph.sorted_reducible_nodes.copy()\n        nodes.reverse()\n        for node in nodes:\n            # skip nodes that don't contain atoms\n            if len(node.contained_atoms) == 0:\n                continue\n\n            # if none of this nodes children have an assignment, they are mislabeled\n            # shells\n            all_labeled = True\n            none_labeled = True\n            some_covalent = False\n            some_atom = False\n            for child in node.deep_children:\n                if child.is_reducible:\n                    continue\n                # note if we have a covalent feature\n                if child.feature_type in [\n                    FeatureType.covalent,\n                    FeatureType.covalent_metallic,\n                ]:\n                    some_covalent = True\n                # note if we have some shell feature\n                if child.feature_type in FeatureType.atomic_types:\n                    some_atom = True\n                # If this node is assigned, note that not all are unlabeled\n                if child.key in assigned_nodes:\n                    none_labeled = False\n                # If this node isn't assigned, note not all are labeled\n                else:\n                    all_labeled = False\n\n            # skip if all children are already labeled\n            if all_labeled:\n                continue\n\n            # if we have exactly one atom in this domain, we may have an atom\n            # that's ionically bonded with a lone-pair (e.g. SnO). We may also\n            # have mislabeled a shell earlier due to a particularly deep feature\n            if len(node.contained_atoms) == 1 and not node.is_infinite:\n                # if none are labeled these are mislabeled shells\n                if none_labeled:\n                    for child in node.deep_children:\n                        child.feature_type = FeatureType.deep_shell\n                        assigned_nodes.append(child.key)\n                # if some are atomic and none are covalent, we have ionic\n                # lone-pairs or small metallic features. We check that they\n                # have reasonable charge\n                elif some_atom and not some_covalent:\n                    for child in node.deep_children:\n                        if child.is_reducible or child.key in assigned_nodes:\n                            continue\n                        if child.charge &gt; self.min_covalent_charge:\n                            child.feature_type = FeatureType.lone_pair\n                            assigned_nodes.append(child.key)\n                # otherwise these features are some form of metallic and we just\n                # continue\n                continue\n\n            # if nothing is labeled and we surround more than one atom, we have\n            # a group of metal features. We mark them as assigned and continue\n            if none_labeled:\n                for child in node.deep_children:\n                    assigned_nodes.append(child.key)\n                continue\n\n            # Any other lone-pairs must come along with a covalent bond. If we\n            # don't have one we continue\n            # NOTE: Should I mark these as checked?\n            if not some_covalent:\n                continue\n\n            # otherwise, check each unassigned node to see if it has exactly\n            # one neighbor in this domain\n            for child in node.deep_children:\n                # skip reducible nodes and nodes with assignments\n                if child.is_reducible or child.key in assigned_nodes:\n                    continue\n                # check how many neighs are in this domain\n                neighs_in_domain = 0\n                for atom_idx in child.coord_indices:\n                    if atom_idx in node.contained_atoms:\n                        neighs_in_domain += 1\n                    if neighs_in_domain &gt; 1:\n                        break\n                # if theres more than one neighbor in the molecule, continue\n                if neighs_in_domain &gt; 1:\n                    continue\n                # if we have a node with reasonable charge, mark it at a lone-pair\n                if child.charge &gt; self.min_covalent_charge:\n                    child.feature_type = FeatureType.lone_pair\n                    assigned_nodes.append(child.key)\n                    # reset coord env so that it gets calculated as 1\n                    child._coord_indices = None\n\n    def _mark_metallic(self):\n        logging.info(\"Marking metallic features\")\n        # we mark metallic features simply based on their depth\n        for node in self.bifurcation_graph.unassigned_nodes:\n            if node.depth &lt; self.max_metal_depth:\n                node.feature_type = FeatureType.metallic\n\n    def _mark_metallic_or_bare(self):\n        if not self._labeled_multi:\n            logging.info(\"Marking multi-centered and bare electron features\")\n        else:\n            logging.info(\"Re-marking multi-centered and bare electron features\")\n        self._labeled_multi = True\n        # The remaining features are various types of non-nuclear attractors.\n        # We separate them into metallic or \"bare electrons\" based on a series\n        # of cutoffs\n\n        # first we need to calculate how far each feature is beyond nearby\n        # atom radii\n        for node in self.bifurcation_graph.irreducible_nodes:\n            # get dists to atoms\n            atom_dists = node.atom_dists\n            # get atom radii\n            atom_radii = self.atom_elf_radii\n            # get the lowest distance beyond an atom\n            dist_beyond_atoms = atom_dists - atom_radii\n            node._nearest_atom_sphere = np.argmin(dist_beyond_atoms)\n            node._dist_beyond_atom = dist_beyond_atoms.min()\n\n        # NOTE: These are very likely to change in the future\n        conditions = np.array(\n            [\n                self.min_electride_elf_value,\n                self.min_electride_depth,\n                self.min_electride_charge,\n                self.min_electride_volume,\n                self.min_electride_dist_beyond_atom,\n            ]\n        )\n        for node in self.bifurcation_graph.irreducible_nodes:\n            # skip nodes that aren't metallic/bare/unlabeled\n            if node.feature_type not in [\n                FeatureType.metallic,\n                FeatureType.bare_electron,\n                FeatureType.unknown,\n            ]:\n                continue\n            condition_test = np.array(\n                [\n                    node.max_value,\n                    node.depth_to_infinite,  # Note we use the depth to an infinite connection rather than true depth\n                    node.charge,\n                    node.volume,\n                    node.dist_beyond_atom,\n                ]\n            )\n            if np.all(condition_test &gt; conditions):\n                node.feature_type = FeatureType.bare_electron\n            else:\n                node.feature_type = FeatureType.multi_centered\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.atom_elf_radii","title":"<code>atom_elf_radii</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The radius of each atom calculated from the ELF using the closest neighboring atom in the structure.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.atom_elf_radii_e","title":"<code>atom_elf_radii_e</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The radius of each atom and electride site calculated from the ELF using the closest neighboring atom/electride in the structure.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.atom_elf_radii_types","title":"<code>atom_elf_radii_types</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The type of radius of each elf radius. Covalent indicates that the bond crosses through some covalent or metallic region, and the radius is placed at the maximum in the ELF in this region. Ionic indicates that the bond does not pass through the covalent/metallic region and the radius is placed at the minimum between the two atoms.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.atom_elf_radii_types_e","title":"<code>atom_elf_radii_types_e</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The type of radius of each atom/electride elf radius. Covalent indicates that the bond crosses through some covalent or metallic region, and the radius is placed at the maximum in the ELF in this region. Ionic indicates that the bond does not pass through the covalent/metallic region and the radius is placed at the minimum between the two atoms.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.atom_feature_indices_e","title":"<code>atom_feature_indices_e</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list</code> <p>The feature indices assigned to each atom/electride in the electride structure. Features assigned to multiple atoms are not included.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.atom_max_values_e","title":"<code>atom_max_values_e</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The maximum value that each atom has an existing feature.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.atom_nn_elf_radii","title":"<code>atom_nn_elf_radii</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The elf radii for each atom and its neighboring atoms in the same order as the nearest_neighbor_data property.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.atom_nn_elf_radii_e","title":"<code>atom_nn_elf_radii_e</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The elf radii for each atom/electride and its neighboring atoms in the same order as the nearest_neighbor_data_e property.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.atom_nn_elf_radii_types","title":"<code>atom_nn_elf_radii_types</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The type of radius for each atom and its neighboring atoms in the same order as the nearest_neighbor_data property.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.atom_nn_elf_radii_types_e","title":"<code>atom_nn_elf_radii_types_e</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The type of radius for each atom/electride and its neighboring atoms in the same order as the nearest_neighbor_data property.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.bifurcation_graph","title":"<code>bifurcation_graph</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>BifurcationGraph</code> <p>A BifurcationGraph class representing features and bifurcations in the ELF.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.bifurcation_plot","title":"<code>bifurcation_plot</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Figure</code> <p>A plotly graph object representing the bifurcation graph.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.electride_formula","title":"<code>electride_formula</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>A string representation of the electride formula, rounding partial charge to the nearest integer.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.electride_structure","title":"<code>electride_structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The system's structure including dummy atoms representing electride sites.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.electrides_per_formula","title":"<code>electrides_per_formula</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The number of electride electrons for the full structure formula.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.electrides_per_reduced_formula","title":"<code>electrides_per_reduced_formula</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The number of electrons in the reduced formula of the structure.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_average_frac_coords","title":"<code>feature_average_frac_coords</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The average fractional coordinates of the Bader basin maxima for each feature. Note that it is possible for this coordinate to be outside of the feature, particularly for atom shells which form sphere-like shapes.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_avg_surface_dists","title":"<code>feature_avg_surface_dists</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list</code> <p>The average distance from the average frac coord of each feature to the partitioning surface.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_basins","title":"<code>feature_basins</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list[NDArray]</code> <p>The Bader basins associated with each feature. For features with multiple basins, the basins are separated by very shallow minima and are better understood as a single feature.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_charges","title":"<code>feature_charges</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The charge associated with each feature.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_coord_atoms","title":"<code>feature_coord_atoms</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list</code> <p>The atoms coordinated with each feature.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_coord_atoms_dists_e","title":"<code>feature_coord_atoms_dists_e</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list</code> <p>The distance to each coordinated atom/electride from each feature.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_coord_atoms_e","title":"<code>feature_coord_atoms_e</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list</code> <p>The coordinated atoms to each feature, including electrides as quasi-atoms</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_coord_dists","title":"<code>feature_coord_dists</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list</code> <p>The distance to each coordinated atom from each feature.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_coord_nums","title":"<code>feature_coord_nums</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list</code> <p>The number of atoms coordinated with each feature.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_coord_nums_e","title":"<code>feature_coord_nums_e</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list</code> <p>The number of coordinated atoms for each featuree, including electrides as quasi-atoms.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_frac_coords","title":"<code>feature_frac_coords</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list[NDArray]</code> <p>The fractional coordinates of the maxima in each Bader basin for each feature in the structure.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_max_values","title":"<code>feature_max_values</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The maximum value at which each feature exists.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_min_surface_dists","title":"<code>feature_min_surface_dists</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list</code> <p>The minimum distance from the average frac coord of each feature to the partitioning surface.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_min_values","title":"<code>feature_min_values</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The minimum value at which each feature exists.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_types","title":"<code>feature_types</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list[str]</code> <p>The type of each ELF feature in the system.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_volumes","title":"<code>feature_volumes</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The volume associated with each feature.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.labeled_structure","title":"<code>labeled_structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The system's structure including dummy atoms representing electride sites and covalent/metallic bonds. Features unique to the spin-up/spin-down systems will have xu or xd appended to the species name respectively. Features that exist in both will have nothing appended.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.nearest_neighbor_data","title":"<code>nearest_neighbor_data</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>tuple</code> <p>The nearest neighbor data for the atoms in the system represented as a tuple of arrays. The arrays represent, in order, the central atoms index, its neighbors index, the fractional coordinates of the neighbor, and the distance between the two sites.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.nearest_neighbor_data_e","title":"<code>nearest_neighbor_data_e</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>tuple</code> <p>The nearest neighbor data for the atoms AND the electrides in the system represented as a tuple of arrays. The arrays represent, in order, the central atoms index, its neighbors index, the fractional coordinates of the neighbor, and the distance between the two sites.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.nelectrides","title":"<code>nelectrides</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The number of electride sites in the structure</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.num_vacuum","title":"<code>num_vacuum</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The number of vacuum points in the array</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.structure","title":"<code>structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The PyMatGen Structure representing the system.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.total_electron_number","title":"<code>total_electron_number</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total number of electrons in the system calculated from the atom charges and vacuum charge. If this does not match the true total electron number within reasonable floating point error, there is a major problem.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.total_volume","title":"<code>total_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total volume integrated in the system. This should match the volume of the structure. If it does not there may be a serious problem.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.vacuum_charge","title":"<code>vacuum_charge</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The charge assigned to the vacuum.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.vacuum_mask","title":"<code>vacuum_mask</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool]</code> <p>A mask representing the voxels that belong to the vacuum.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.vacuum_volume","title":"<code>vacuum_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total volume assigned to the vacuum.</p>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.feature_indices_by_type","title":"<code>feature_indices_by_type(feature_types)</code>","text":"<p>Gets a list of feature indices from a list of types of Features (e.g. bare electron, metallic, covalent)</p> <p>Parameters:</p> Name Type Description Default <code>feature_types</code> <code>list[FeatureType | str]</code> <p>The list of feature types to find indices for.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>A list of feature indices corresponding to all feature types in the provided list. These correspond to the order in which feature properties (e.g. ElfLabeler.feature_charges) appear in.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def feature_indices_by_type(self, feature_types: list[FeatureType | str]):\n    \"\"\"\n\n    Gets a list of feature indices from a list of types of Features\n    (e.g. bare electron, metallic, covalent)\n\n    Parameters\n    ----------\n    feature_types : list[FeatureType | str]\n        The list of feature types to find indices for.\n\n    Returns\n    -------\n    NDArray\n        A list of feature indices corresponding to all feature types in the\n        provided list. These correspond to the order in which feature properties\n        (e.g. ElfLabeler.feature_charges) appear in.\n\n    \"\"\"\n    return np.array(\n        [i for i, feat in enumerate(self.feature_types) if feat in feature_types],\n        dtype=np.int64,\n    )\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.from_vasp","title":"<code>from_vasp(charge_filename='CHGCAR', reference_filename='ELFCAR', total_only=True, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates an ElfLabeler class object from VASP files.</p> <p>Parameters:</p> Name Type Description Default <code>charge_filename</code> <code>Path | str</code> <p>The path to the CHGCAR like file that will be used for summing charge. The default is \"CHGCAR\".</p> <code>'CHGCAR'</code> <code>reference_filename</code> <code>Path | str</code> <p>The path to ELFCAR like file that will be used for partitioning. If None, the charge file will be used for partitioning.</p> <code>'ELFCAR'</code> <code>total_only</code> <code>bool</code> <p>If true, only the first set of data in the file will be read. This increases speed and reduced memory usage as the other data is typically not used. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the Labeler class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>An ElfLabeler class object.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>@classmethod\ndef from_vasp(\n    cls,\n    charge_filename: Path | str = \"CHGCAR\",\n    reference_filename: Path | str = \"ELFCAR\",\n    total_only: bool = True,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Creates an ElfLabeler class object from VASP files.\n\n    Parameters\n    ----------\n    charge_filename : Path | str, optional\n        The path to the CHGCAR like file that will be used for summing charge.\n        The default is \"CHGCAR\".\n    reference_filename : Path | str\n        The path to ELFCAR like file that will be used for partitioning.\n        If None, the charge file will be used for partitioning.\n    total_only: bool\n        If true, only the first set of data in the file will be read. This\n        increases speed and reduced memory usage as the other data is typically\n        not used.\n        Defaults to True.\n    **kwargs : dict\n        Keyword arguments to pass to the Labeler class.\n\n    Returns\n    -------\n    Self\n        An ElfLabeler class object.\n\n    \"\"\"\n    # This is just a wrapper of the Bader class to update the default to\n    # load the ELFCAR\n    charge_grid = Grid.from_vasp(charge_filename, total_only=total_only)\n    reference_grid = Grid.from_vasp(reference_filename, total_only=total_only)\n\n    return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.get_charges_and_volumes","title":"<code>get_charges_and_volumes(splitting_method='weighted_dist', use_electrides=True, **kwargs)</code>","text":"<p>Assign charge from each feature to their associated atoms. For features that have multiple neighbors (e.g. covalent bonds), several options are provided for how to divide the charge to nearby neighbors. If use_electrides is set to True, features with electride like character will be treated as atoms and</p> <p>Parameters:</p> Name Type Description Default <code>splitting_method</code> <code>Literal['equal', 'pauling', 'dist', 'weighted_dist', 'nearest']</code> <p>The method used to divide charge and volume of shared features betweeen their coordinating atoms.</p> <pre><code>'weighted_dist' (default)\n    Fraction increases with decreasing distance to each atom. The\n    fraction is further weighted by the radius of each atom\n    calculated from the ELF\n'pauling'\n    Fraction increases with decreasing pauling electronegativity.\n    If an atom has no recorded EN a value of 2.2 is used which\n    may be incorrect in many cases.\n'equal'\n    Each neighboring atom receives an equal fraction.\n'dist'\n    Fraction increases with decreasing distance to the center\n    of each atom\n'nearest'\n    All charge is assigned to the features nearest atom.\n</code></pre> <code>'weighted_dist'</code> <code>use_electrides</code> <code>bool</code> <p>If True, features labeled as bare electrons will be treated as electride atoms. They will receive partial charge from other shared features and their charge/volume will be appended after the atoms'.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[NDArray]</code> <p>Two arrays representing the charges and volumes respectively.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def get_charges_and_volumes(\n    self,\n    splitting_method: Literal[\n        \"weighted_dist\", \"pauling\", \"equal\", \"dist\", \"nearest\"\n    ] = \"weighted_dist\",\n    use_electrides: bool = True,\n    **kwargs,\n) -&gt; tuple[NDArray]:\n    \"\"\"\n    Assign charge from each feature to their associated atoms. For features\n    that have multiple neighbors (e.g. covalent bonds), several options\n    are provided for how to divide the charge to nearby neighbors.\n    If use_electrides is set to True, features with electride like character\n    will be treated as atoms and\n\n    Parameters\n    ----------\n    splitting_method : Literal[\"equal\", \"pauling\", \"dist\", \"weighted_dist\", \"nearest\"], optional\n        The method used to divide charge and volume of shared features\n        betweeen their coordinating atoms.\n\n            'weighted_dist' (default)\n                Fraction increases with decreasing distance to each atom. The\n                fraction is further weighted by the radius of each atom\n                calculated from the ELF\n            'pauling'\n                Fraction increases with decreasing pauling electronegativity.\n                If an atom has no recorded EN a value of 2.2 is used which\n                may be incorrect in many cases.\n            'equal'\n                Each neighboring atom receives an equal fraction.\n            'dist'\n                Fraction increases with decreasing distance to the center\n                of each atom\n            'nearest'\n                All charge is assigned to the features nearest atom.\n\n    use_electrides : bool, optional\n        If True, features labeled as bare electrons will be treated as electride\n        atoms. They will receive partial charge from other shared features\n        and their charge/volume will be appended after the atoms'.\n\n    Returns\n    -------\n    tuple[NDArray]\n        Two arrays representing the charges and volumes respectively.\n\n    \"\"\"\n    if use_electrides:\n        structure = self.electride_structure\n    else:\n        structure = self.structure\n\n    # create an array to store atom charges and volumes\n    atom_charge = np.zeros(len(structure), dtype=np.float64)\n    atom_volume = np.zeros(len(structure), dtype=np.float64)\n\n    # if using pauling, get all electronegativities\n    if splitting_method == \"pauling\":\n        pauling_ens = np.array([i.specie.X for i in structure])\n        pauling_ens = np.nan_to_num(pauling_ens, nan=2.2)\n\n    electride_num = 0\n    for feature_idx in range(len(self.feature_types)):\n        charge = self.feature_charges[feature_idx]\n        volume = self.feature_volumes[feature_idx]\n\n        if use_electrides:\n            # check if this is an electride feature\n            if self.feature_types[feature_idx] in FeatureType.bare_types:\n                # assign charge/volume to self\n                struc_idx = len(self.structure) + electride_num\n                atom_charge[struc_idx] += charge\n                atom_volume[struc_idx] += volume\n                electride_num += 1\n                continue\n\n            # get coordination with electrides\n            coord_atoms = self.feature_coord_atoms_e[feature_idx]\n        else:\n            # get coordination without electrides\n            coord_atoms = self.feature_coord_atoms[feature_idx]\n        # get unique atoms and counts (correction for small cells)\n        unique_atoms, unique_indices, atom_counts = np.unique(\n            coord_atoms, return_index=True, return_counts=True\n        )\n\n        if len(coord_atoms) == 0:\n            # This shouldn't happen, but could if CrystalNN failed\n            # to find neighbors.\n            logging.warning(\n                f\"No neighboring atoms found for feature with index {feature_idx}. Feature assigned to nearest atom.\"\n            )\n            # assign all charge/volume to the closest atom\n            nearest = np.argmin(self.feature_coord_dists[feature_idx])\n            atom_charge[nearest] += charge\n            atom_volume[nearest] += volume\n\n        elif len(coord_atoms) == 1:\n            # all methods will add charge and volume to this atom.\n            # assigning it here potentially avoids divide by zeros for\n            # core features\n            atom_charge[coord_atoms[0]] += charge\n            atom_volume[coord_atoms[0]] += volume\n\n        elif splitting_method == \"equal\":\n            # evenly split the feature to each neighboring atom\n            atom_charge[unique_atoms] += (charge / len(coord_atoms)) * atom_counts\n            atom_volume[unique_atoms] += (volume / len(coord_atoms)) * atom_counts\n\n        elif splitting_method == \"pauling\":\n            # get the pauling ens for coordinated atoms\n            ens = pauling_ens[coord_atoms]\n            # normalize to the total en\n            ens /= ens.sum()\n            # get the weights for each unique atom\n            ens = ens[unique_indices]\n            atom_charge[unique_atoms] += charge * ens * atom_counts\n            atom_volume[unique_atoms] += volume * ens * atom_counts\n\n        elif splitting_method == \"dist\":\n            # get the dist to each coordinated atom\n            if use_electrides:\n                dists = self.feature_coord_atoms_dists_e[feature_idx].copy()\n            else:\n                dists = self.feature_coord_dists[feature_idx].copy()\n            # invert and normalize\n            dists = 1 / dists\n            dists /= dists.sum()\n            # add for each atom\n            for coord_idx, atom in enumerate(coord_atoms):\n                atom_charge[atom] += charge * dists[coord_idx]\n                atom_volume[atom] += volume * dists[coord_idx]\n\n        elif splitting_method == \"weighted_dist\":\n            # get the dist to each coordinated atom and their radii\n            if use_electrides:\n                dists = self.feature_coord_atoms_dists_e[feature_idx].copy()\n                atom_radii = self.atom_elf_radii_e[coord_atoms]\n            else:\n                dists = self.feature_coord_dists[feature_idx].copy()\n                atom_radii = self.atom_elf_radii[coord_atoms]\n\n            # calculate the weighted contribution to each atom and normalize\n            weight = atom_radii / dists\n            weight /= weight.sum()\n            # add for each atom\n            for coord_idx, atom in enumerate(coord_atoms):\n                atom_charge[atom] += charge * weight[coord_idx]\n                atom_volume[atom] += volume * weight[coord_idx]\n\n        elif splitting_method == \"nearest\":\n            # assign all charge/volume to the closest atom\n            nearest = np.argmin(self.feature_coord_dists[feature_idx])\n            atom_charge[nearest] += charge\n            atom_volume[nearest] += volume\n        else:\n            raise ValueError(\n                f\"'{splitting_method}' is not a valid splitting method\"\n            )\n\n    return atom_charge.round(10), atom_volume.round(10)\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.get_feature_labels","title":"<code>get_feature_labels(included_features=FeatureType.valence_types, return_structure=True, return_feat_indices=False, return_charge_volume=False, order_by_type=True)</code>","text":"<p>Assigns each grid point to atoms and features included in the 'included_features' tag. The assignments are represented by an array with the same dimensions as the charge/reference grids with integers representing the atom/feature index in the Structure object including requested feature dummy atoms. By default this method orders requested features so that atoms come first, followed by electrides, and then any other feature types. This is for methods such as BadELF which rely on this ordering scheme.</p> <p>Atoms are included by default and it is generally not recommended to include core/shell features. If these are of interest to you, reach out to us on our github</p> <p>Parameters:</p> Name Type Description Default <code>included_features</code> <code>list[str]</code> <p>The features to include in addition to the atoms. The default is FeatureType.valence_types.</p> <code>valence_types</code> <code>return_structure</code> <code>bool</code> <p>Whether or not to return the structure that the index labels correspond to. The default is True.</p> <code>True</code> <code>return_feat_indices</code> <code>bool</code> <p>Whether or not to return the original feature indices in their new order. The default is False.</p> <code>False</code> <code>order_by_type</code> <code>bool</code> <p>Whether or not to reorder the structure prior to assigning to grid points. The default is True.</p> <code>True</code> <code>return_charge_volume</code> <code>bool</code> <p>Whether or not to return the corresponding charge/volume associated with each feature</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>An array representing grid point assignments. If return_structure or return_feat_indices is set to True, these are returned as well. The returned result is always a tuple, even if only the feature assignments are requested.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def get_feature_labels(\n    self,\n    included_features: list[str] = FeatureType.valence_types,\n    return_structure: bool = True,\n    return_feat_indices: bool = False,\n    return_charge_volume: bool = False,\n    order_by_type: bool = True,\n) -&gt; tuple:\n    \"\"\"\n\n    Assigns each grid point to atoms and features included in the 'included_features'\n    tag. The assignments are represented by an array with the same dimensions\n    as the charge/reference grids with integers representing the atom/feature\n    index in the Structure object including requested feature dummy atoms.\n    By default this method orders requested features so that atoms\n    come first, followed by electrides, and then any other feature types. This\n    is for methods such as BadELF which rely on this ordering scheme.\n\n    Atoms are included by default and it is generally not recommended to include\n    core/shell features. If these are of interest to you, reach out to us\n    on our [github](https://github.com/SWeav02/baderkit)\n\n    Parameters\n    ----------\n    included_features : list[str], optional\n        The features to include in addition to the atoms. The default is FeatureType.valence_types.\n    return_structure : bool, optional\n        Whether or not to return the structure that the index labels correspond\n        to. The default is True.\n    return_feat_indices : bool, optional\n        Whether or not to return the original feature indices in their new\n        order. The default is False.\n    order_by_type : bool, optional\n        Whether or not to reorder the structure prior to assigning to\n        grid points. The default is True.\n    return_charge_volume : bool, optional\n        Whether or not to return the corresponding charge/volume associated\n        with each feature\n\n    Returns\n    -------\n    tuple\n        An array representing grid point assignments. If return_structure or\n        return_feat_indices is set to True, these are returned as well. The\n        returned result is always a tuple, even if only the feature assignments\n        are requested.\n\n    \"\"\"\n\n    # Get the original basin atom assignments\n    basin_atoms = self.bader.basin_atoms.copy()\n\n    # get indices of requested type\n    feature_indices = self.feature_indices_by_type(included_features)\n\n    # reorder features so that electrides are first if requested\n    if order_by_type:\n        bare_feature_indices = []\n        other_feature_indices = []\n        for feat_idx in feature_indices:\n            if self.feature_types[feat_idx] in FeatureType.bare_types:\n                bare_feature_indices.append(feat_idx)\n            else:\n                other_feature_indices.append(feat_idx)\n        feature_indices = bare_feature_indices + other_feature_indices\n\n    # reassign basin atoms and get structure\n    feature_structure = self.structure.copy()\n    new_atom_idx = len(self.structure)\n    for sorted_idx, feat_idx in enumerate(feature_indices):\n        # update basin labels\n        basins = self.feature_basins[feat_idx]\n        basin_atoms[basins] = new_atom_idx\n        new_atom_idx += 1\n        # add feature to structure\n        species = self.feature_types[feat_idx].dummy_species\n        coords = self.feature_average_frac_coords[feat_idx]\n        feature_structure.append(species, coords)\n\n    # NOTE: append -1 so that vacuum gets assigned to -1 in the atom_labels\n    # array\n    basin_atoms = np.insert(basin_atoms, len(basin_atoms), -1)\n\n    # reassign labels\n    feature_labels = basin_atoms[self.bader.basin_labels]\n\n    # get requested results\n    if not any((return_structure, return_feat_indices, return_charge_volume)):\n        return feature_labels\n    results = [feature_labels]\n    if return_structure:\n        results.append(feature_structure)\n\n    if return_feat_indices:\n        results.append(feature_indices)\n\n    if return_charge_volume:\n        basin_atoms = basin_atoms[:-1]\n\n        atom_charges = np.bincount(\n            basin_atoms,\n            weights=self.bader.basin_charges,\n            minlength=len(feature_structure),\n        )\n        atom_volumes = np.bincount(\n            basin_atoms,\n            weights=self.bader.basin_volumes,\n            minlength=len(feature_structure),\n        )\n        results.append(atom_charges)\n        results.append(atom_volumes)\n\n    # return labels\n    return tuple(results)\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.get_feature_structure","title":"<code>get_feature_structure(included_features=FeatureType.valence_types, return_feat_indices=False, order_by_type=True)</code>","text":"<p>Generates a PyMatGen Structure object with dummy atoms for each requested feature. By default this method orders requested features so that atoms come first, followed by electrides, and then any other feature types.</p> <p>Parameters:</p> Name Type Description Default <code>included_features</code> <code>list[str]</code> <p>The features to include in addition to the atoms. The default is FeatureType.valence_types.</p> <code>valence_types</code> <code>return_feat_indices</code> <code>bool</code> <p>Whether or not to return the original feature indices in their new order. The default is False.</p> <code>False</code> <code>order_by_type</code> <code>bool</code> <p>Whether or not to reorder the structure. The default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Structure</code> <p>DESCRIPTION.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def get_feature_structure(\n    self,\n    included_features: list[str] = FeatureType.valence_types,\n    return_feat_indices: bool = False,\n    order_by_type: bool = True,\n) -&gt; Structure:\n    \"\"\"\n\n    Generates a PyMatGen Structure object with dummy atoms for each requested\n    feature. By default this method orders requested features so that atoms\n    come first, followed by electrides, and then any other feature types.\n\n    Parameters\n    ----------\n    included_features : list[str], optional\n        The features to include in addition to the atoms. The default is FeatureType.valence_types.\n    return_feat_indices : bool, optional\n        Whether or not to return the original feature indices in their new\n        order. The default is False.\n    order_by_type : bool, optional\n        Whether or not to reorder the structure. The default is True.\n\n    Returns\n    -------\n    Structure\n        DESCRIPTION.\n\n    \"\"\"\n    # get indices of requested type\n    feature_indices = self.feature_indices_by_type(included_features)\n\n    # reorder features so that electrides are first if requested\n    if order_by_type:\n        bare_feature_indices = []\n        other_feature_indices = []\n        for feat_idx in feature_indices:\n            if self.feature_types[feat_idx] in FeatureType.bare_types:\n                bare_feature_indices.append(feat_idx)\n            else:\n                other_feature_indices.append(feat_idx)\n        feature_indices = bare_feature_indices + other_feature_indices\n\n    # get structure from indices\n    structure = self.get_feature_structure_by_index(feature_indices)\n\n    if return_feat_indices:\n        return structure, feature_indices\n\n    return structure\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.get_feature_structure_by_index","title":"<code>get_feature_structure_by_index(feature_indices)</code>","text":"<p>Generates a PyMatGen Structure object with dummy atoms for each requested feature. This method does not reorder features.</p> <p>Parameters:</p> Name Type Description Default <code>feature_indices</code> <code>list[int]</code> <p>The indices of features to include.</p> required <p>Returns:</p> Name Type Description <code>structure</code> <code>Structure</code> <p>The system's PyMatGen Structure including dummy atoms representing requested features.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def get_feature_structure_by_index(self, feature_indices: list[int]) -&gt; Structure:\n    \"\"\"\n\n    Generates a PyMatGen Structure object with dummy atoms for each requested\n    feature. This method does not reorder features.\n\n    Parameters\n    ----------\n    feature_indices : list[int]\n        The indices of features to include.\n\n    Returns\n    -------\n    structure : Structure\n        The system's PyMatGen Structure including dummy atoms representing\n        requested features.\n\n    \"\"\"\n\n    # Create a new structure without oxidation states\n    structure = self.structure.copy()\n    structure.remove_oxidation_states()\n\n    # add each feature\n    for feat_idx in feature_indices:\n        structure.append(\n            self.feature_types[feat_idx].dummy_species,\n            self.feature_average_frac_coords[feat_idx],\n        )\n\n    return structure\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.get_oxidation_and_volumes_from_potcar","title":"<code>get_oxidation_and_volumes_from_potcar(potcar_path='POTCAR', use_electrides=True, **kwargs)</code>","text":"<p>Calculates the oxidation states, charges, and volumes associated with each atom/electride using the information from a provided POTCAR.</p> <p>Parameters:</p> Name Type Description Default <code>potcar_path</code> <code>Path</code> <p>The path to the POTCAR file. The default is \"POTCAR\".</p> <code>'POTCAR'</code> <code>use_electrides</code> <code>bool</code> <p>Whether or not to treat electrides as quasi atoms. The default is True.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Any keyword arguments to pass to the 'get_charges_and_volumes' method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[NDArray]</code> <p>three arrays representing the oxidation states, charges, and volumes respectively.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def get_oxidation_and_volumes_from_potcar(\n    self, potcar_path: Path = \"POTCAR\", use_electrides: bool = True, **kwargs\n) -&gt; tuple[NDArray]:\n    \"\"\"\n    Calculates the oxidation states, charges, and volumes associated with each\n    atom/electride using the information from a provided POTCAR.\n\n    Parameters\n    ----------\n    potcar_path : Path, optional\n        The path to the POTCAR file. The default is \"POTCAR\".\n    use_electrides : bool, optional\n        Whether or not to treat electrides as quasi atoms. The default is True.\n    **kwargs : dict\n        Any keyword arguments to pass to the 'get_charges_and_volumes' method.\n\n    Returns\n    -------\n    tuple[NDArray]\n        three arrays representing the oxidation states, charges, and volumes\n        respectively.\n\n    \"\"\"\n    charges, volumes = self.get_charges_and_volumes(\n        use_electrides=use_electrides, **kwargs\n    )\n    # convert to path\n    potcar_path = Path(potcar_path)\n    # load\n    with warnings.catch_warnings(record=True):\n        potcars = Potcar.from_file(potcar_path)\n    nelectron_data = {}\n    # the result is a list because there can be multiple element potcars\n    # in the file (e.g. for NaCl, POTCAR = POTCAR_Na + POTCAR_Cl)\n    for potcar in potcars:\n        nelectron_data.update({potcar.element: potcar.nelectrons})\n    # calculate oxidation states\n    if use_electrides:\n        structure = self.electride_structure\n    else:\n        structure = self.structure\n\n    oxi_state_data = []\n    for site, site_charge in zip(structure, charges):\n        element_str = site.specie.symbol\n        val_electrons = nelectron_data.get(element_str, 0.0)\n        oxi_state = val_electrons - site_charge\n        oxi_state_data.append(oxi_state)\n\n    return np.array(oxi_state_data).round(10), charges.round(10), volumes.round(10)\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.to_dict","title":"<code>to_dict(potcar_path='POTCAR', use_json=True, splitting_method='weighted_dist')</code>","text":"<p>Gets a dictionary summary of the ElfLabeler analysis.</p> <p>Parameters:</p> Name Type Description Default <code>potcar_path</code> <code>Path | str</code> <p>The Path to a POTCAR file. This must be provided for oxidation states to be calculated, and they will be None otherwise. The default is \"POTCAR\".</p> <code>'POTCAR'</code> <code>use_json</code> <code>bool</code> <p>Convert all entries to JSONable data types. The default is True.</p> <code>True</code> <code>splitting_method</code> <code>Literal['equal', 'pauling', 'dist', 'weighted_dist', 'nearest']</code> <p>See :meth:<code>write_feature_basins</code>.</p> <code>'weighted_dist'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A summary of the ElfLabeler analysis in dictionary form.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def to_dict(\n    self,\n    potcar_path: Path | str = \"POTCAR\",\n    use_json: bool = True,\n    splitting_method: Literal[\n        \"equal\", \"pauling\", \"dist\", \"weighted_dist\", \"nearest\"\n    ] = \"weighted_dist\",\n) -&gt; dict:\n    \"\"\"\n\n    Gets a dictionary summary of the ElfLabeler analysis.\n\n    Parameters\n    ----------\n    potcar_path : Path | str, optional\n        The Path to a POTCAR file. This must be provided for oxidation states\n        to be calculated, and they will be None otherwise. The default is \"POTCAR\".\n    use_json : bool, optional\n        Convert all entries to JSONable data types. The default is True.\n    splitting_method : Literal[\"equal\", \"pauling\", \"dist\", \"weighted_dist\", \"nearest\"], optional\n        See :meth:`write_feature_basins`.\n\n    Returns\n    -------\n    dict\n        A summary of the ElfLabeler analysis in dictionary form.\n\n    \"\"\"\n    results = {}\n    # collect method kwargs\n    method_kwargs = {\n        \"splitting_method\": splitting_method,\n        \"crystalnn_kwargs\": self.crystalnn_kwargs,\n        \"ignore_low_pseudopotentials\": self.ignore_low_pseudopotentials,\n        \"shared_shell_ratio\": self.shared_shell_ratio,\n        \"covalent_molecule_ratio\": self.covalent_molecule_ratio,\n        \"min_covalent_charge\": self.min_covalent_charge,\n        \"min_covalent_angle\": self.min_covalent_angle,\n        \"min_electride_elf_value\": self.min_electride_elf_value,\n        \"min_electride_depth\": self.min_electride_depth,\n        \"min_electride_charge\": self.min_electride_charge,\n        \"min_electride_volume\": self.min_electride_volume,\n        \"min_electride_dist_beyond_atom\": self.min_electride_dist_beyond_atom,\n    }\n    results[\"method_kwargs\"] = method_kwargs\n    results[\"spin_system\"] = self.spin_system\n\n    # only try to calculate oxidation state if this was not a half spin system\n    potcar_path = Path(potcar_path)\n    if self.spin_system == \"total\" and potcar_path.exists():\n        oxidation_states, charges, volumes = (\n            self.get_oxidation_and_volumes_from_potcar(\n                potcar_path=potcar_path, use_electrides=False\n            )\n        )\n        oxidation_states_e, charges_e, volumes_e = (\n            self.get_oxidation_and_volumes_from_potcar(\n                potcar_path=potcar_path, use_electrides=True\n            )\n        )\n    else:\n        oxidation_states = None\n        oxidation_states_e = None\n        charges, volumes = self.get_charges_and_volumes(use_electrides=False)\n        charges_e, volumes_e = self.get_charges_and_volumes(use_electrides=True)\n    if oxidation_states is not None:\n        oxidation_states = oxidation_states.tolist()\n        oxidation_states_e = oxidation_states_e.tolist()\n    results[\"oxidation_states\"] = oxidation_states\n    results[\"oxidation_states_e\"] = oxidation_states_e\n    results[\"charges\"] = charges.tolist()\n    results[\"charges_e\"] = charges_e.tolist()\n    results[\"volumes\"] = volumes.tolist()\n    results[\"volumes_e\"] = volumes_e.tolist()\n\n    # add objects that can convert to json\n    for result in [\n        \"structure\",\n        \"labeled_structure\",\n        \"electride_structure\",\n        \"bifurcation_graph\",\n    ]:\n        result_obj = getattr(self, result, None)\n        if result_obj is not None and use_json:\n            result_obj = result_obj.to_json()\n        results[result] = result_obj\n\n    # add objects that are arrays\n    for result in [\n        \"atom_elf_radii\",\n        \"atom_elf_radii_types\",\n        \"atom_elf_radii_e\",\n        \"atom_elf_radii_types_e\",\n        \"atom_max_values_e\",\n        \"feature_max_values\",\n        \"feature_min_values\",\n        \"feature_charges\",\n        \"feature_volumes\",\n        \"feature_coord_nums\",\n        \"feature_coord_nums_e\",\n        \"feature_min_surface_dists\",\n        \"feature_avg_surface_dists\",\n    ]:\n        result_obj = getattr(self, result, None)\n        if use_json and result_obj is not None:\n            result_obj = result_obj.tolist()\n        results[result] = result_obj\n\n    # add objects that are lists with arrays\n    for result in [\n        \"feature_coord_dists\",\n        \"feature_coord_atoms_dists_e\",\n    ]:\n        result_obj = getattr(self, result, None)\n        if use_json and result_obj is not None:\n            result_obj = [i.tolist() for i in result_obj]\n        results[result] = result_obj\n\n    # add other objects that are already jsonable\n    for result in [\n        \"nelectrides\",\n        \"electride_formula\",\n        \"electrides_per_formula\",\n        \"electrides_per_reduced_formula\",\n        \"feature_types\",\n        \"feature_coord_atoms\",\n        \"feature_coord_atoms_e\",\n        \"atom_feature_indices_e\",\n        \"total_electron_number\",\n        \"total_volume\",\n        \"vacuum_charge\",\n        \"vacuum_volume\",\n    ]:\n        results[result] = getattr(self, result, None)\n\n    return results\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.to_json","title":"<code>to_json(**kwargs)</code>","text":"<p>Creates a JSON string representation of the results, typically for writing results to file.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Keyword arguments for the to_dict method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the BadELF results.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def to_json(self, **kwargs) -&gt; str:\n    \"\"\"\n    Creates a JSON string representation of the results, typically for writing\n    results to file.\n\n    Parameters\n    ----------\n    **kwargs : dict\n        Keyword arguments for the to_dict method.\n\n    Returns\n    -------\n    str\n        A JSON string representation of the BadELF results.\n\n    \"\"\"\n    return json.dumps(self.to_dict(use_json=True, **kwargs))\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.write_all_features","title":"<code>write_all_features(**kwargs)</code>","text":"<p>Writes the bader basins associated with all features</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>See :meth:<code>write_feature_basins</code>.</p> <code>{}</code> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def write_all_features(self, **kwargs):\n    \"\"\"\n    Writes the bader basins associated with all features\n\n    Parameters\n    ----------\n    **kwargs :\n        See :meth:`write_feature_basins`.\n\n    \"\"\"\n    self.write_feature_basins(\n        feature_indices=np.arange(len(self.feature_charges), dtype=int), **kwargs\n    )\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.write_bifurcation_plot","title":"<code>write_bifurcation_plot(filename)</code>","text":"<p>Writes the BifurcationPlot to an html file. This is just a shortcut for ElfLabeler.bifurcation_plot.write_html.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | Path</code> <p>The Path to write the plot to. 'html' will be appended if it is not present in the path.</p> required Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def write_bifurcation_plot(\n    self,\n    filename: str | Path,\n):\n    \"\"\"\n\n    Writes the BifurcationPlot to an html file. This is just a shortcut for\n    ElfLabeler.bifurcation_plot.write_html.\n\n    Parameters\n    ----------\n    filename : str | Path\n        The Path to write the plot to. 'html' will be appended if it is not\n        present in the path.\n\n    \"\"\"\n    plot = self.bifurcation_plot\n    # make sure path is a Path object\n    filename = Path(filename)\n    # add .html if filename doesn't include it\n    filename_html = filename.with_suffix(\".html\")\n    plot.write_html(filename_html)\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.write_feature_basins","title":"<code>write_feature_basins(feature_indices, directory=Path('.'), include_dummy_atoms=True, write_reference=True, output_format=None, prefix_override=None, **writer_kwargs)</code>","text":"<p>For a give list of node keys, writes the bader basins associated with each.</p> <p>Parameters:</p> Name Type Description Default <code>feature_indices</code> <code>list[int]</code> <p>Which features to write basin volumes for.</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>Path('.')</code> <code>include_dummy_atoms</code> <code>bool</code> <p>Whether or not to add dummy files to the structure. The default is False.</p> <code>True</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>True</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def write_feature_basins(\n    self,\n    feature_indices: list[int],\n    directory: str | Path = Path(\".\"),\n    include_dummy_atoms: bool = True,\n    write_reference: bool = True,\n    output_format: str | Format = None,\n    prefix_override: str = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    For a give list of node keys, writes the bader basins associated with\n    each.\n\n    Parameters\n    ----------\n    feature_indices : list[int]\n        Which features to write basin volumes for.\n    directory : str | Path, optional\n        The directory to write the files in. If None, the active directory\n        is used.\n    include_dummy_atoms : bool, optional\n        Whether or not to add dummy files to the structure. The default is False.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n\n    \"\"\"\n    # get the data to use\n    if write_reference:\n        data_array = self.reference_grid.total\n        data_type = self.reference_grid.data_type\n    else:\n        data_array = self.charge_grid.total\n        data_type = self.charge_grid.data_type\n\n    if directory is None:\n        directory = Path(\".\")\n\n    # get structure\n    if include_dummy_atoms:\n        structure = self.get_feature_structure_by_index(feature_indices)\n    else:\n        structure = self.structure\n\n    # get prefix\n    if prefix_override is None:\n        prefix_override = data_type.prefix\n\n    for feat_idx in feature_indices:\n        basins = self.feature_basins[feat_idx]\n        # get mask where this feature is NOT\n        mask = np.isin(self.bader.basin_labels, basins, invert=True)\n        # copy data to avoid overwriting. Set data off of basin to 0\n        data_array_copy = data_array.copy()\n        data_array_copy[mask] = 0.0\n        grid = Grid(\n            structure=structure,\n            data={\"total\": data_array_copy},\n            data_type=data_type,\n        )\n        file_path = directory / f\"{prefix_override}_f{feat_idx}\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.write_feature_basins_sum","title":"<code>write_feature_basins_sum(feature_indices, directory=Path('.'), include_dummy_atoms=False, write_reference=True, output_format=None, prefix_override=None, **writer_kwargs)</code>","text":"<p>For a give list of node keys, writes the union of the bader basins associated with each.</p> <p>Parameters:</p> Name Type Description Default <code>feature_indices</code> <code>list[int]</code> <p>Which features to include in the volume.</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>Path('.')</code> <code>include_dummy_atoms</code> <code>bool</code> <p>Whether or not to add dummy files to the structure. The default is False.</p> <code>False</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>True</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def write_feature_basins_sum(\n    self,\n    feature_indices: list[int],\n    directory: str | Path = Path(\".\"),\n    include_dummy_atoms: bool = False,\n    write_reference: bool = True,\n    output_format: str | Format = None,\n    prefix_override: str = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    For a give list of node keys, writes the union of the bader basins\n    associated with each.\n\n    Parameters\n    ----------\n    feature_indices : list[int]\n        Which features to include in the volume.\n    directory : str | Path, optional\n        The directory to write the files in. If None, the active directory\n        is used.\n    include_dummy_atoms : bool, optional\n        Whether or not to add dummy files to the structure. The default is False.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n    \"\"\"\n    # get the data to use\n    if write_reference:\n        data_array = self.reference_grid.total\n        data_type = self.reference_grid.data_type\n    else:\n        data_array = self.charge_grid.total\n        data_type = self.charge_grid.data_type\n\n    if directory is None:\n        directory = Path(\".\")\n\n    # get structure\n    if include_dummy_atoms:\n        structure = self.get_feature_structure_by_index(feature_indices)\n    else:\n        structure = self.structure\n\n    # get prefix\n    if prefix_override is None:\n        prefix_override = data_type.prefix\n\n    # get all basin indices to include\n    basin_list = []\n    for feat_idx in feature_indices:\n        basin_list.extend(self.feature_basins[feat_idx])\n\n    # get mask where features are not\n    mask = np.isin(self.bader.basin_labels, basin_list, invert=True)\n    # copy data to avoid overwriting. Set data off of basin to 0\n    data_array_copy = data_array.copy()\n    data_array_copy[mask] = 0.0\n    grid = Grid(\n        structure=structure,\n        data={\"total\": data_array_copy},\n        data_type=data_type,\n    )\n    file_path = directory / f\"{prefix_override}_fsum\"\n    # write file\n    grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.write_features_by_type","title":"<code>write_features_by_type(included_types, prefix_override=None, write_reference=True, directory=Path('.'), **kwargs)</code>","text":"<p>Writes the bader basins associated with all features of the selected type</p> <p>Parameters:</p> Name Type Description Default <code>included_types</code> <code>list[FeatureType]</code> <p>The types of features to include, e.g. metallic, lone-pair, etc.</p> required <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is True.</p> <code>True</code> <code>**kwargs</code> <p>See :meth:<code>write_feature_basins</code>.</p> <code>{}</code> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def write_features_by_type(\n    self,\n    included_types: list[FeatureType],\n    prefix_override=None,\n    write_reference: bool = True,\n    directory: str | Path = Path(\".\"),\n    **kwargs,\n):\n    \"\"\"\n    Writes the bader basins associated with all features of the selected type\n\n    Parameters\n    ----------\n    included_types : list[FeatureType]\n        The types of features to include, e.g. metallic, lone-pair, etc.\n    prefix_override : str\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is True.\n    **kwargs :\n        See :meth:`write_feature_basins`.\n\n    \"\"\"\n    # get the data to use\n    if write_reference:\n        data_type = self.reference_grid.data_type\n    else:\n        data_type = self.charge_grid.data_type\n    # get prefix\n    if prefix_override is None:\n        prefix_override = data_type.prefix\n    for feature_type in included_types:\n        feature_type = FeatureType(feature_type)\n        feature_indices = self.feature_indices_by_type([feature_type])\n        prefix = prefix_override + f\"_{feature_type.dummy_species}\"\n        self.write_feature_basins_sum(\n            feature_indices=feature_indices,\n            prefix_override=prefix,\n            directory=directory,\n            **kwargs,\n        )\n\n        # rename to remove fsum\n        os.rename(\n            directory / f\"{prefix}_fsum\",\n            directory / f\"{prefix}\",\n        )\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.write_features_by_type_sum","title":"<code>write_features_by_type_sum(included_types, **kwargs)</code>","text":"<p>Writes the union of the bader basins associated with all features of the selected type</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>See :meth:<code>write_feature_basins_sum</code>.</p> <code>{}</code> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def write_features_by_type_sum(\n    self,\n    included_types: list[FeatureType],\n    **kwargs,\n):\n    \"\"\"\n    Writes the union of the bader basins associated with all features of the\n    selected type\n\n    Parameters\n    ----------\n    **kwargs :\n        See :meth:`write_feature_basins_sum`.\n\n    \"\"\"\n    feature_indices = self.feature_indices_by_type(included_types)\n    self.write_feature_basins_sum(feature_indices=feature_indices, **kwargs)\n</code></pre>"},{"location":"api_reference/core/labeler/#src.baderkit.core.labelers.elf_labeler.ElfLabeler.write_json","title":"<code>write_json(filepath='elf_labeler.json', **kwargs)</code>","text":"<p>Writes results of the analysis to file in a JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Path | str</code> <p>The Path to write the results to. The default is \"elf_labeler.json\".</p> <code>'elf_labeler.json'</code> <code>**kwargs</code> <code>dict</code> <p>keyword arguments for the to_dict method.</p> <code>{}</code> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler.py</code> <pre><code>def write_json(self, filepath: Path | str = \"elf_labeler.json\", **kwargs) -&gt; None:\n    \"\"\"\n    Writes results of the analysis to file in a JSON format.\n\n    Parameters\n    ----------\n    filepath : Path | str, optional\n        The Path to write the results to. The default is \"elf_labeler.json\".\n    **kwargs : dict\n        keyword arguments for the to_dict method.\n\n    \"\"\"\n    filepath = Path(filepath)\n    with open(filepath, \"w\") as json_file:\n        json.dump(self.to_dict(use_json=True, **kwargs), json_file, indent=4)\n</code></pre>"},{"location":"api_reference/core/labeler_spin/","title":"SpinElfLabeler","text":"<p>Labels chemical features present in the ELF and collects various properties e.g charge, volume, elf value, etc. The spin-up and spin-down systems are treated separately and results can be viewed combined or independently.</p> <p>Parameters:</p> Name Type Description Default <code>charge_grid</code> <code>Grid</code> <p>A charge density Grid object. The total charge density (spin-up + spin-down) should be stored in the 'total' property and the difference (spin-up - spin-down) should be stored in the 'diff' property.</p> required <code>reference_grid</code> <code>Grid</code> <p>An ELF Grid object. The spin-up ELF should be stored in the 'total' property and the spin-down ELF should be stored in the 'diff' property.</p> required <code>**kwargs</code> <code>dict</code> <p>Any keyword argumetns to pass to the child ElfLabeler classes used for each spin.</p> <code>{}</code> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler_spin.py</code> <pre><code>class SpinElfLabeler:\n    \"\"\"\n    Labels chemical features present in the ELF and collects various properties\n    e.g charge, volume, elf value, etc. The spin-up and spin-down systems are\n    treated separately and results can be viewed combined or independently.\n\n    Parameters\n    ----------\n    charge_grid : Grid\n        A charge density Grid object. The total charge density (spin-up + spin-down)\n        should be stored in the 'total' property and the difference (spin-up - spin-down)\n        should be stored in the 'diff' property.\n    reference_grid : Grid\n        An ELF Grid object. The spin-up ELF should be stored in the 'total' property\n        and the spin-down ELF should be stored in the 'diff' property.\n    **kwargs : dict\n        Any keyword argumetns to pass to the child ElfLabeler classes used for\n        each spin.\n\n    \"\"\"\n\n    spin_system = \"combined\"\n\n    def __init__(\n        self,\n        charge_grid: Grid,\n        reference_grid: Grid,\n        **kwargs,\n    ):\n\n        # First make sure the grids are actually spin polarized\n        assert (\n            reference_grid.is_spin_polarized and charge_grid.is_spin_polarized\n        ), \"ELF must be spin polarized. Use a spin polarized calculation or switch to the ElfLabeler class.\"\n        # store the original grid\n        self.original_reference_grid = reference_grid\n        self.original_charge_grid = charge_grid\n        # split the grids to spin up and spin down\n        self.reference_grid_up, self.reference_grid_down = (\n            reference_grid.split_to_spin()\n        )\n        self.charge_grid_up, self.charge_grid_down = charge_grid.split_to_spin()\n        # check if spin up and spin down are the same\n        if np.allclose(\n            self.reference_grid_up.total,\n            self.reference_grid_down.total,\n            rtol=0,\n            atol=1e-4,\n        ):\n            logging.info(\n                \"Spin grids are found to be equal. Only spin-up system will be used.\"\n            )\n            self.equal_spin = True\n        else:\n            self.equal_spin = False\n        # create spin up and spin down elf analyzer instances\n        self.elf_labeler_up = ElfLabeler(\n            reference_grid=self.reference_grid_up,\n            charge_grid=self.charge_grid_up,\n            **kwargs,\n        )\n        if not self.equal_spin:\n            self.elf_labeler_down = ElfLabeler(\n                reference_grid=self.reference_grid_down,\n                charge_grid=self.charge_grid_down,\n                **kwargs,\n            )\n            self.elf_labeler_up.spin_system = \"up\"\n            self.elf_labeler_down.spin_system = \"down\"\n        else:\n            self.elf_labeler_down = self.elf_labeler_up\n            self.elf_labeler_up.spin_system = \"half\"  # same up/down\n\n        # calculated properties\n        self._labeled_structure = None\n        self._electride_structure = None\n        self._atom_elf_radii = None\n        self._atom_elf_radii_types = None\n        self._atom_nn_elf_radii = None\n        self._atom_nn_elf_radii_types = None\n        self._nearest_neighbor_data = None\n        self._electrides_per_formula = None\n        self._electrides_per_reduced_formula = None\n\n    ###########################################################################\n    # Properties combining spin up and spin down systems\n    ###########################################################################\n\n    @property\n    def structure(self) -&gt; Structure:\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The PyMatGen Structure representing the system.\n\n        \"\"\"\n        structure = self.original_reference_grid.structure.copy()\n        return structure\n\n    @property\n    def nearest_neighbor_data(self) -&gt; list:\n        \"\"\"\n\n        Returns\n        -------\n        tuple\n            The nearest neighbor data for the atoms in the system represented as\n            a tuple of arrays. The arrays represent, in order, the central\n            atoms index, its neighbors index, the fractional coordinates of the\n            neighbor, and the distance between the two sites.\n\n        \"\"\"\n        if self._nearest_neighbor_data is None:\n            # get nearest neighbors from spin up labeler\n            nearest_neighbor_data = self.elf_labeler_up.nearest_neighbor_data\n            # set spin down for speed\n            self.elf_labeler_down._nearest_neighbor_data = nearest_neighbor_data\n            self._nearest_neighbor_data = nearest_neighbor_data\n        return self._nearest_neighbor_data\n\n    @property\n    def atom_elf_radii(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The radius of each atom calculated from the ELF using the closest\n            neighboring atom in the structure. This is taken as the average value\n            from both spin systems.\n\n        \"\"\"\n        if self._atom_elf_radii is None:\n            # get the atomic radii from the spin up/down systems\n            spin_up_radii = self.elf_labeler_up.atom_elf_radii\n            spin_down_radii = self.elf_labeler_down.atom_elf_radii\n            self._atom_elf_radii = (spin_up_radii + spin_down_radii) / 2\n        return self._atom_elf_radii\n\n    @property\n    def atom_elf_radii_types(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The type of radius of each elf radius. Covalent indicates that the\n            bond crosses through some covalent or metallic region, and the radius\n            is placed at the maximum in the ELF in this region. Ionic indicates\n            that the bond does not pass through the covalent/metallic region and\n            the radius is placed at the minimum between the two atoms.\n\n        \"\"\"\n        if self._atom_elf_radii_types is None:\n            # make sure spin up/down labelers have calculated radii\n            self.atom_elf_radii\n            # default to covalent\n            self._atom_elf_radii_types = (\n                self.elf_labeler_up._atom_elf_radii_types\n                | self.elf_labeler_down._atom_elf_radii_types\n            )\n        # convert to strings and return\n        return np.where(self._atom_elf_radii_types, \"covalent\", \"ionic\")\n\n    @property\n    def atom_nn_elf_radii(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The elf radii for each atom and its neighboring atoms in the same\n            order as the nearest_neighbor_data property. Radii are taken as\n            averages between the spin-up and spin-down systems.\n\n        \"\"\"\n        if self._atom_nn_elf_radii is None:\n            # get the atomic radii from the spin up/down systems\n            spin_up_radii = self.elf_labeler_up.atom_nn_elf_radii\n            spin_down_radii = self.elf_labeler_down.atom_nn_elf_radii\n            self._atom_nn_elf_radii = (spin_up_radii + spin_down_radii) / 2\n        return self._atom_nn_elf_radii\n\n    @property\n    def atom_nn_elf_radii_types(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray\n            The type of radius for each atom and its neighboring atoms in the same\n            order as the nearest_neighbor_data property.\n\n        \"\"\"\n        if self._atom_nn_elf_radii_types is None:\n            # make sure spin up/down labelers have calculated radii\n            self.atom_nn_elf_radii\n            # default to covalent\n            self._atom_nn_elf_radii_types = (\n                self.elf_labeler_up._atom_nn_elf_radii_types\n                | self.elf_labeler_down._atom_nn_elf_radii_types\n            )\n        # convert to strings and return\n        return np.where(self._atom_nn_elf_radii_types, \"covalent\", \"ionic\")\n\n    @property\n    def labeled_structure(self) -&gt; Structure:\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The system's structure including dummy atoms representing electride\n            sites and covalent/metallic bonds. Features unique to the spin-up/spin-down\n            systems will have xu or xd appended to the species name respectively.\n            Features that exist in both will have nothing appended.\n\n        \"\"\"\n        if self._labeled_structure is None:\n            # start with only atoms\n            labeled_structure = self.structure.copy()\n            # get up and downs structures\n            structure_up = self.elf_labeler_up.labeled_structure\n            structure_down = self.elf_labeler_down.labeled_structure\n            # get species from the spin up system\n            new_species = []\n            new_coords = []\n            for site in structure_up[len(self.structure) :]:\n                species = site.specie.symbol\n                # add frac coords no matter what\n                new_coords.append(site.frac_coords)\n                # if this site is in the spin-down structure, it exists in both and\n                # we add the site with the original species name\n                if site in structure_down:\n                    new_species.append(species)\n                else:\n                    # otherwise, we rename the species\n                    new_species.append(species + \"xu\")\n            # do the same for the spin down system\n            for site in structure_down[len(self.structure) :]:\n                # only add the structure if it didn't exist in the spin up system\n                if site not in structure_up:\n                    species = site.specie.symbol\n                    new_species.append(species + \"xd\")\n                    new_coords.append(site.frac_coords)\n            # add our sites\n            for species, coords in zip(new_species, new_coords):\n                labeled_structure.append(species, coords)\n            self._labeled_structure = labeled_structure\n        return self._labeled_structure\n\n    @property\n    def electride_structure(self) -&gt; Structure:\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The system's structure including dummy atoms representing electride\n            sites. Electrides unique to the spin-up/spin-down\n            systems will have xu or xd appended to the species name respectively.\n            Electrides that exist in both will have nothing appended.\n\n        \"\"\"\n        if self._electride_structure is None:\n            # start with only atoms\n            labeled_structure = self.structure.copy()\n            # get up and downs structures\n            structure_up = self.elf_labeler_up.electride_structure\n            structure_down = self.elf_labeler_down.electride_structure\n            # get species from the spin up system\n            new_species = []\n            new_coords = []\n            for site in structure_up[len(self.structure) :]:\n                species = site.specie.symbol\n                # add frac coords no matter what\n                new_coords.append(site.frac_coords)\n                # if this site is in the spin-down structure, it exists in both and\n                # we add the site with the original species name\n                if site in structure_down:\n                    new_species.append(species)\n                else:\n                    # otherwise, we rename the species\n                    new_species.append(species + \"xu\")\n            # do the same for the spin down system\n            for site in structure_down[len(self.structure) :]:\n                # only add the structure if it didn't exist in the spin up system\n                if site not in structure_up:\n                    species = site.specie.symbol\n                    new_species.append(species + \"xd\")\n                    new_coords.append(site.frac_coords)\n            # add our sites\n            for species, coords in zip(new_species, new_coords):\n                labeled_structure.append(species, coords)\n            self._electride_structure = labeled_structure\n\n        return self._electride_structure\n\n    @property\n    def nelectrides(self) -&gt; int:\n        \"\"\"\n\n        Returns\n        -------\n        int\n            The number of electride sites in the structure\n\n        \"\"\"\n        return len(self.electride_structure) - len(self.structure)\n\n    @property\n    def electride_formula(self):\n        \"\"\"\n\n        Returns\n        -------\n        str\n            A string representation of the electride formula, rounding partial charge\n            to the nearest integer.\n\n        \"\"\"\n        return f\"{self.structure.formula} e{round(self.electrides_per_formula)}\"\n\n    @property\n    def electrides_per_formula(self):\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The number of electride electrons for the full structure formula.\n\n        \"\"\"\n        if self._electrides_per_formula is None:\n            electrides_per_unit = (\n                self.elf_labeler_up.electrides_per_formula\n                + self.elf_labeler_down.electrides_per_formula\n            )\n            self._electrides_per_formula = electrides_per_unit\n        return self._electrides_per_formula\n\n    @property\n    def electrides_per_reduced_formula(self):\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The number of electrons in the reduced formula of the structure.\n\n        \"\"\"\n        if self._electrides_per_reduced_formula is None:\n            (\n                _,\n                formula_reduction_factor,\n            ) = self.structure.composition.get_reduced_composition_and_factor()\n            self._electrides_per_reduced_formula = (\n                self.electrides_per_formula / formula_reduction_factor\n            )\n        return self._electrides_per_reduced_formula\n\n    def get_charges_and_volumes(\n        self,\n        use_electrides: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        Calculates charges and volumes by splitting feature charges/volumes to\n        their neighboring atoms.\n\n        NOTE: Volumes may not have a physical meaning when differences are found\n        between spin up/down systems. They are calculated as the average between\n        the systems.\n\n        Parameters\n        ----------\n        use_electrides : bool, optional\n            Whether or not to consider electrides as quasi-atoms. The default is True.\n        **kwargs : dict\n            Any keyword arguments to use in the corresponding ElfLabeler method\n            for each spin system.\n\n        Returns\n        -------\n        tuple\n            The charges and volumes calculated for each atom.\n\n        \"\"\"\n\n        # get the initial charges/volumes from the spin up system\n        charges, volumes = self.elf_labeler_up.get_charges_and_volumes(\n            use_electrides=use_electrides, **kwargs\n        )\n        # convert to lists\n        charges = charges.tolist()\n        volumes = volumes.tolist()\n\n        # get the charges from the spin down system\n        charges_down, volumes_down = self.elf_labeler_down.get_charges_and_volumes(\n            use_electrides=use_electrides, **kwargs\n        )\n        # get structures from each system\n        if use_electrides:\n            structure_up = self.elf_labeler_up.electride_structure\n            structure_down = self.elf_labeler_down.electride_structure\n        else:\n            structure_up = self.structure\n            structure_down = self.structure\n        # add charge from spin down structure\n        for site, charge, volume in zip(structure_down, charges_down, volumes_down):\n            if site in structure_up:\n                index = structure_up.index(site)\n                charges[index] += charge\n                volumes[index] += volume\n            else:\n                charges.append(charge)\n                volumes.append(volume)\n        return np.array(charges), np.array(volumes) / 2\n\n    def get_oxidation_and_volumes_from_potcar(\n        self, potcar_path: Path = \"POTCAR\", use_electrides: bool = True, **kwargs\n    ):\n        \"\"\"\n        Calculates oxidation states, charges, and volumes by splitting feature\n        charges/volumes to their neighboring atoms and comparing to the valence\n        electrons in the POTCAR.\n\n        NOTE: Volumes may not have a physical meaning when differences are found\n        between spin up/down systems. They are calculated as the average between\n        the systems.\n\n        Parameters\n        ----------\n        potcar_path : Path | str, optional\n            The Path to the POTCAR file. The default is \"POTCAR\".\n        use_electrides : bool, optional\n            Whether or not to consider electrides as quasi-atoms. The default is True.\n        **kwargs : dict\n            Any keyword arguments to use in the corresponding ElfLabeler method\n            for each spin system.\n\n        Returns\n        -------\n        tuple\n            The oxidation states, charges, and volumes calculated for each atom.\n\n        \"\"\"\n\n        # get the charges/volumes\n        charges, volumes = self.get_charges_and_volumes(\n            use_electrides=use_electrides, **kwargs\n        )\n        # convert to path\n        potcar_path = Path(potcar_path)\n        # check if potcar exists. If not, return None and a warning\n        if not potcar_path.exists():\n            logging.warning(\n                \"No POTCAR found at provided path. No oxidation states will be calculated.\"\n            )\n            return None, charges, volumes\n\n        # load\n        with warnings.catch_warnings(record=True):\n            potcars = Potcar.from_file(potcar_path)\n        nelectron_data = {}\n        # the result is a list because there can be multiple element potcars\n        # in the file (e.g. for NaCl, POTCAR = POTCAR_Na + POTCAR_Cl)\n        for potcar in potcars:\n            nelectron_data.update({potcar.element: potcar.nelectrons})\n        # calculate oxidation states\n        if use_electrides:\n            structure = self.electride_structure\n        else:\n            structure = self.structure\n\n        oxi_state_data = []\n        for site, site_charge in zip(structure, charges):\n            element_str = site.specie.symbol\n            val_electrons = nelectron_data.get(element_str, 0.0)\n            oxi_state = val_electrons - site_charge\n            oxi_state_data.append(oxi_state)\n\n        return np.array(oxi_state_data), charges, volumes\n\n    def write_bifurcation_plot(self, filename: str | Path):\n        \"\"\"\n        Writes an html plot representing the bifurcation graph.\n\n        Parameters\n        ----------\n        filename : str | Path\n            The file to write the bifurcation plot to.\n\n        \"\"\"\n        filename = Path(filename)\n\n        if filename.suffix:\n            filename_up = filename.with_name(f\"{filename.stem}_up{filename.suffix}\")\n            filename_down = filename.with_name(f\"{filename.stem}_down{filename.suffix}\")\n        else:\n            filename_up = filename.with_name(f\"{filename.name}_up\")\n            filename_down = filename.with_name(f\"{filename.name}_down\")\n\n        self.elf_labeler_up.write_bifurcation_plot(filename_up)\n        self.elf_labeler_down.write_bifurcation_plot(filename_down)\n\n    ###########################################################################\n    # Vacuum Properties\n    ###########################################################################\n    @property\n    def vacuum_charge(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The charge assigned to the vacuum.\n\n        \"\"\"\n        return self.elf_labeler_up.vacuum_charge + self.elf_labeler_down.vacuum_charge\n\n    @property\n    def vacuum_volume(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total volume assigned to the vacuum. This is an average between\n            the spin up and spin down values.\n\n        \"\"\"\n        return (\n            self.elf_labeler_up.vacuum_volume + self.elf_labeler_down.vacuum_volume\n        ) / 2\n\n    @property\n    def total_electron_number(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total number of electrons in the system calculated from the\n            spin-up and spin-down systems. If this does not match the true\n            total electron number within reasonable floating point error,\n            there is a major problem.\n\n        \"\"\"\n\n        return round(\n            self.elf_labeler_up.total_electron_number\n            + self.elf_labeler_down.total_electron_number,\n            10,\n        )\n\n    @property\n    def total_volume(self):\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total volume integrated in the system. This should match the\n            volume of the structure. If it does not there may be a serious problem.\n\n            This is the average of the two systems\n\n        \"\"\"\n\n        return (\n            self.elf_labeler_up.total_volume + self.elf_labeler_down.total_volume\n        ) / 2\n\n    ###########################################################################\n    # From methods\n    ###########################################################################\n    @classmethod\n    def from_vasp(\n        cls,\n        charge_filename: Path | str = \"CHGCAR\",\n        reference_filename: Path | str = \"ELFCAR\",\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Creates a SpinElfAnalysis class object from VASP files.\n\n        Parameters\n        ----------\n        charge_filename : Path | str, optional\n            The path to the CHGCAR like file that will be used for summing charge.\n            The default is \"CHGCAR\".\n        reference_filename : Path | str\n            The path to ELFCAR like file that will be used for partitioning.\n            If None, the charge file will be used for partitioning.\n        total_only: bool\n            If true, only the first set of data in the file will be read. This\n            increases speed and reduced memory usage as the other data is typically\n            not used.\n            Defaults to True.\n        **kwargs : dict\n            Keyword arguments to pass to the Bader class.\n\n        Returns\n        -------\n        Self\n            A SpinElfAnalysis class object.\n\n        \"\"\"\n        charge_grid = Grid.from_vasp(charge_filename, total_only=False)\n        if reference_filename is None:\n            reference_grid = None\n        else:\n            reference_grid = Grid.from_vasp(reference_filename, total_only=False)\n\n        return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n\n    # TODO: Currently this class is only useful for VASP because .cube files\n    # typically only contain a single grid. Is there a reason to create a convenience\n    # function for cube files?\n\n    def to_dict(\n        self,\n        potcar_path: Path | str = \"POTCAR\",\n        use_json: bool = True,\n        splitting_method: Literal[\n            \"equal\", \"pauling\", \"dist\", \"weighted_dist\", \"nearest\"\n        ] = \"weighted_dist\",\n    ) -&gt; dict:\n        \"\"\"\n\n        Gets a dictionary summary of the ElfLabeler analysis.\n\n        Parameters\n        ----------\n        potcar_path : Path | str, optional\n            The Path to a POTCAR file. This must be provided for oxidation states\n            to be calculated, and they will be None otherwise. The default is \"POTCAR\".\n        use_json : bool, optional\n            Convert all entries to JSONable data types. The default is True.\n        splitting_method : Literal[\"equal\", \"pauling\", \"dist\", \"weighted_dist\", \"nearest\"], optional\n            See :meth:`write_feature_basins`.\n\n        Returns\n        -------\n        dict\n            A summary of the ElfLabeler analysis in dictionary form.\n\n        \"\"\"\n        results = {}\n        # collect method kwargs\n        results[\"method_kwargs\"] = {\n            \"splitting_method\": splitting_method,\n        }\n\n        oxidation_states, charges, volumes = self.get_oxidation_and_volumes_from_potcar(\n            potcar_path=potcar_path, use_electrides=False\n        )\n        oxidation_states_e, charges_e, volumes_e = (\n            self.get_oxidation_and_volumes_from_potcar(\n                potcar_path=potcar_path, use_electrides=True\n            )\n        )\n\n        if oxidation_states is not None:\n            oxidation_states = oxidation_states.tolist()\n            oxidation_states_e = oxidation_states_e.tolist()\n\n        results[\"oxidation_states\"] = oxidation_states\n        results[\"oxidation_states_e\"] = oxidation_states_e\n        results[\"charges\"] = charges.tolist()\n        results[\"charges_e\"] = charges_e.tolist()\n        results[\"volumes\"] = volumes.tolist()\n        results[\"volumes_e\"] = volumes_e.tolist()\n\n        # add objects that can convert to json\n        for result in [\n            \"structure\",\n            \"labeled_structure\",\n            \"electride_structure\",\n        ]:\n            result_obj = getattr(self, result, None)\n            if result_obj is not None and use_json:\n                result_obj = result_obj.to_json()\n            results[result] = result_obj\n\n        # add objects that are arrays\n        for result in [\n            \"atom_elf_radii\",\n            \"atom_elf_radii_types\",\n            \"atom_elf_radii_e\",\n            \"atom_elf_radii_types_e\",\n        ]:\n            result_obj = getattr(self, result, None)\n            if use_json and result_obj is not None:\n                result_obj = result_obj.tolist()\n            results[result] = result_obj\n\n        # add other objects that are already jsonable\n        for result in [\n            \"spin_system\",\n            \"nelectrides\",\n            \"feature_types\",\n            \"electride_formula\",\n            \"electrides_per_formula\",\n            \"electrides_per_reduced_formula\",\n            \"total_electron_number\",\n            \"total_volume\",\n            \"vacuum_charge\",\n            \"vacuum_volume\",\n        ]:\n            results[result] = getattr(self, result, None)\n\n        return results\n\n    def to_json(self, **kwargs) -&gt; str:\n        \"\"\"\n        Creates a JSON string representation of the results, typically for writing\n        results to file.\n\n        Parameters\n        ----------\n        **kwargs : dict\n            Keyword arguments for the to_dict method.\n\n        Returns\n        -------\n        str\n            A JSON string representation of the BadELF results.\n\n        \"\"\"\n        return json.dumps(self.to_dict(use_json=True, **kwargs))\n\n    def write_json(self, filepath: Path | str = \"elf_labeler.json\", **kwargs) -&gt; None:\n        \"\"\"\n        Writes results of the analysis to file in a JSON format.\n\n        Parameters\n        ----------\n        filepath : Path | str, optional\n            The Path to write the results to. The default is \"badelf_results_summary.json\".\n        **kwargs : dict\n            keyword arguments for the to_dict method.\n\n        \"\"\"\n        filepath = Path(filepath)\n        # write spin up and spin down summaries\n        filepath_up = filepath.parent / f\"{filepath.stem}_up{filepath.suffix}\"\n        filepath_down = filepath.parent / f\"{filepath.stem}_down{filepath.suffix}\"\n        self.elf_labeler_up.write_json(filepath=filepath_up, **kwargs)\n        self.elf_labeler_down.write_json(filepath=filepath_down, **kwargs)\n\n        # write total spin summary\n        with open(filepath, \"w\") as json_file:\n            json.dump(self.to_dict(use_json=True, **kwargs), json_file, indent=4)\n\n    def write_all_features(\n        self,\n        directory: str | Path = Path(\".\"),\n        write_reference: bool = True,\n        prefix_override: str = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Writes the bader basins associated with all features\n\n        Parameters\n        ----------\n        directory : str | Path, optional\n            The directory to write to. The default is None.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge\n            density. The default is True.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid. The default is None.\n        **kwargs : dict\n            Keyword arguments to pass to the ElfLabeler write method.\n\n        \"\"\"\n\n        if directory is None:\n            directory = Path(\".\")\n\n        # get prefix\n        if prefix_override is None:\n            if write_reference:\n                prefix_override = self.original_reference_grid.data_type.prefix\n            else:\n                prefix_override = self.original_charge_grid.data_type.prefix\n\n        # temporarily update prefix override to avoid overwriting\n        if self.equal_spin:\n            temp_prefix = f\"{prefix_override}_temp\"\n        else:\n            temp_prefix = prefix_override\n\n        for feat_idx in range(len(self.elf_labeler_up.feature_charges)):\n            self.elf_labeler_up.write_feature_basins(\n                feature_indices=[feat_idx],\n                directory=directory,\n                write_reference=write_reference,\n                prefix_override=temp_prefix,\n                **kwargs,\n            )\n            if not self.equal_spin:\n                # rename with \"up\" so we don't overwrite\n                os.rename(\n                    directory / f\"{temp_prefix}_f{feat_idx}\",\n                    directory / f\"{prefix_override}_f{feat_idx}_up\",\n                )\n            else:\n                os.rename(\n                    directory / f\"{temp_prefix}_f{feat_idx}\",\n                    directory / f\"{prefix_override}_f{feat_idx}\",\n                )\n        if self.equal_spin:\n            return\n        # Write the spin down file and change the name\n        for feat_idx in range(len(self.elf_labeler_down.feature_charges)):\n            self.elf_labeler_down.write_feature_basins(\n                feature_indices=[feat_idx],\n                directory=directory,\n                write_reference=write_reference,\n                prefix_override=temp_prefix,\n                **kwargs,\n            )\n            if not self.equal_spin:\n                # rename with \"up\" so we don't overwrite\n                os.rename(\n                    directory / f\"{temp_prefix}_f{feat_idx}\",\n                    directory / f\"{prefix_override}_f{feat_idx}_down\",\n                )\n\n    def write_features_by_type(\n        self,\n        included_types: list[FeatureType],\n        directory: str | Path = Path(\".\"),\n        prefix_override=None,\n        write_reference: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n\n        Writes the reference ELF or charge-density for the the union of the\n        given atoms to a single file.\n\n        Parameters\n        ----------\n        included_types : list[FeatureType]\n            The types of features to include, e.g. metallic, lone-pair, etc.\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is True.\n        **kwargs :\n            See :meth:`write_feature_basins`.\n\n        \"\"\"\n        if directory is None:\n            directory = Path(\".\")\n\n        # get prefix\n        if prefix_override is None:\n            if write_reference:\n                prefix_override = self.original_reference_grid.data_type.prefix\n            else:\n                prefix_override = self.original_charge_grid.data_type.prefix\n\n        # temporarily update prefix override to avoid overwriting\n        if self.equal_spin:\n            temp_prefix = f\"{prefix_override}_temp\"\n        else:\n            temp_prefix = prefix_override\n\n        for feat_type in included_types:\n            feat_type = FeatureType(feat_type)\n\n            self.elf_labeler_up.write_features_by_type(\n                included_types=[feat_type],\n                directory=directory,\n                write_reference=write_reference,\n                prefix_override=temp_prefix,\n                **kwargs,\n            )\n\n            if not self.equal_spin:\n                # rename with \"up\" so we don't overwrite\n                os.rename(\n                    directory / f\"{temp_prefix}_{feat_type.dummy_species}\",\n                    directory / f\"{prefix_override}_{feat_type.dummy_species}_up\",\n                )\n            else:\n                os.rename(\n                    directory / f\"{temp_prefix}_{feat_type.dummy_species}\",\n                    directory / f\"{prefix_override}_{feat_type.dummy_species}\",\n                )\n                return\n\n                # Write the spin down file and change the name\n            # temporarily update prefix override to avoid overwriting\n            self.elf_labeler_down.write_features_by_type(\n                included_types=[feat_type],\n                directory=directory,\n                write_reference=write_reference,\n                prefix_override=temp_prefix,\n                **kwargs,\n            )\n            if not self.equal_spin:\n                # rename with \"up\" so we don't overwrite\n                os.rename(\n                    directory / f\"{temp_prefix}_{feat_type.dummy_species}\",\n                    directory / f\"{prefix_override}_{feat_type.dummy_species}_down\",\n                )\n\n    def write_features_by_type_sum(\n        self,\n        included_types: list[FeatureType],\n        directory: str | Path = Path(\".\"),\n        prefix_override=None,\n        write_reference: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n\n        Writes the reference ELF or charge-density for the the union of the\n        given atoms to a single file.\n\n        Parameters\n        ----------\n        included_types : list[FeatureType]\n            The types of features to include, e.g. metallic, lone-pair, etc.\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        prefix_override : str, optional\n            The string to add at the front of the output path. If None, defaults\n            to the VASP file name equivalent to the data type stored in the\n            grid.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is True.\n        **kwargs :\n            See :meth:`write_feature_basins`.\n\n        \"\"\"\n        if directory is None:\n            directory = Path(\".\")\n\n        # get prefix\n        if prefix_override is None:\n            if write_reference:\n                prefix_override = self.original_reference_grid.data_type.prefix\n            else:\n                prefix_override = self.original_charge_grid.data_type.prefix\n\n        # temporarily update prefix override to avoid overwriting\n        if self.equal_spin:\n            temp_prefix = f\"{prefix_override}_temp\"\n        else:\n            temp_prefix = prefix_override\n\n        self.elf_labeler_up.write_features_by_type_sum(\n            included_types=included_types,\n            directory=directory,\n            write_reference=write_reference,\n            prefix_override=temp_prefix,\n            **kwargs,\n        )\n        if not self.equal_spin:\n            # rename with \"up\" so we don't overwrite\n            os.rename(\n                directory / f\"{temp_prefix}_fsum\",\n                directory / f\"{prefix_override}_fsum_up\",\n            )\n        else:\n            os.rename(\n                directory / f\"{temp_prefix}_fsum\",\n                directory / f\"{prefix_override}_fsum\",\n            )\n            return\n\n        # Write the spin down file and change the name\n        # temporarily update prefix override to avoid overwriting\n        self.elf_labeler_down.write_features_by_type_sum(\n            included_types=included_types,\n            directory=directory,\n            write_reference=write_reference,\n            prefix_override=temp_prefix,\n            **kwargs,\n        )\n        if not self.equal_spin:\n            # rename with \"up\" so we don't overwrite\n            os.rename(\n                directory / f\"{temp_prefix}_fsum\",\n                directory / f\"{prefix_override}_fsum_down\",\n            )\n</code></pre>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.atom_elf_radii","title":"<code>atom_elf_radii</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The radius of each atom calculated from the ELF using the closest neighboring atom in the structure. This is taken as the average value from both spin systems.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.atom_elf_radii_types","title":"<code>atom_elf_radii_types</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The type of radius of each elf radius. Covalent indicates that the bond crosses through some covalent or metallic region, and the radius is placed at the maximum in the ELF in this region. Ionic indicates that the bond does not pass through the covalent/metallic region and the radius is placed at the minimum between the two atoms.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.atom_nn_elf_radii","title":"<code>atom_nn_elf_radii</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The elf radii for each atom and its neighboring atoms in the same order as the nearest_neighbor_data property. Radii are taken as averages between the spin-up and spin-down systems.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.atom_nn_elf_radii_types","title":"<code>atom_nn_elf_radii_types</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray</code> <p>The type of radius for each atom and its neighboring atoms in the same order as the nearest_neighbor_data property.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.electride_formula","title":"<code>electride_formula</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>A string representation of the electride formula, rounding partial charge to the nearest integer.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.electride_structure","title":"<code>electride_structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The system's structure including dummy atoms representing electride sites. Electrides unique to the spin-up/spin-down systems will have xu or xd appended to the species name respectively. Electrides that exist in both will have nothing appended.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.electrides_per_formula","title":"<code>electrides_per_formula</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The number of electride electrons for the full structure formula.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.electrides_per_reduced_formula","title":"<code>electrides_per_reduced_formula</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The number of electrons in the reduced formula of the structure.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.labeled_structure","title":"<code>labeled_structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The system's structure including dummy atoms representing electride sites and covalent/metallic bonds. Features unique to the spin-up/spin-down systems will have xu or xd appended to the species name respectively. Features that exist in both will have nothing appended.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.nearest_neighbor_data","title":"<code>nearest_neighbor_data</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>tuple</code> <p>The nearest neighbor data for the atoms in the system represented as a tuple of arrays. The arrays represent, in order, the central atoms index, its neighbors index, the fractional coordinates of the neighbor, and the distance between the two sites.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.nelectrides","title":"<code>nelectrides</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The number of electride sites in the structure</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.structure","title":"<code>structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The PyMatGen Structure representing the system.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.total_electron_number","title":"<code>total_electron_number</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total number of electrons in the system calculated from the spin-up and spin-down systems. If this does not match the true total electron number within reasonable floating point error, there is a major problem.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.total_volume","title":"<code>total_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total volume integrated in the system. This should match the volume of the structure. If it does not there may be a serious problem.</p> <p>This is the average of the two systems</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.vacuum_charge","title":"<code>vacuum_charge</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The charge assigned to the vacuum.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.vacuum_volume","title":"<code>vacuum_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total volume assigned to the vacuum. This is an average between the spin up and spin down values.</p>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.from_vasp","title":"<code>from_vasp(charge_filename='CHGCAR', reference_filename='ELFCAR', **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a SpinElfAnalysis class object from VASP files.</p> <p>Parameters:</p> Name Type Description Default <code>charge_filename</code> <code>Path | str</code> <p>The path to the CHGCAR like file that will be used for summing charge. The default is \"CHGCAR\".</p> <code>'CHGCAR'</code> <code>reference_filename</code> <code>Path | str</code> <p>The path to ELFCAR like file that will be used for partitioning. If None, the charge file will be used for partitioning.</p> <code>'ELFCAR'</code> <code>total_only</code> <p>If true, only the first set of data in the file will be read. This increases speed and reduced memory usage as the other data is typically not used. Defaults to True.</p> required <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the Bader class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A SpinElfAnalysis class object.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler_spin.py</code> <pre><code>@classmethod\ndef from_vasp(\n    cls,\n    charge_filename: Path | str = \"CHGCAR\",\n    reference_filename: Path | str = \"ELFCAR\",\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Creates a SpinElfAnalysis class object from VASP files.\n\n    Parameters\n    ----------\n    charge_filename : Path | str, optional\n        The path to the CHGCAR like file that will be used for summing charge.\n        The default is \"CHGCAR\".\n    reference_filename : Path | str\n        The path to ELFCAR like file that will be used for partitioning.\n        If None, the charge file will be used for partitioning.\n    total_only: bool\n        If true, only the first set of data in the file will be read. This\n        increases speed and reduced memory usage as the other data is typically\n        not used.\n        Defaults to True.\n    **kwargs : dict\n        Keyword arguments to pass to the Bader class.\n\n    Returns\n    -------\n    Self\n        A SpinElfAnalysis class object.\n\n    \"\"\"\n    charge_grid = Grid.from_vasp(charge_filename, total_only=False)\n    if reference_filename is None:\n        reference_grid = None\n    else:\n        reference_grid = Grid.from_vasp(reference_filename, total_only=False)\n\n    return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n</code></pre>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.get_charges_and_volumes","title":"<code>get_charges_and_volumes(use_electrides=True, **kwargs)</code>","text":"<p>Calculates charges and volumes by splitting feature charges/volumes to their neighboring atoms.</p> <p>NOTE: Volumes may not have a physical meaning when differences are found between spin up/down systems. They are calculated as the average between the systems.</p> <p>Parameters:</p> Name Type Description Default <code>use_electrides</code> <code>bool</code> <p>Whether or not to consider electrides as quasi-atoms. The default is True.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Any keyword arguments to use in the corresponding ElfLabeler method for each spin system.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple</code> <p>The charges and volumes calculated for each atom.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler_spin.py</code> <pre><code>def get_charges_and_volumes(\n    self,\n    use_electrides: bool = True,\n    **kwargs,\n):\n    \"\"\"\n    Calculates charges and volumes by splitting feature charges/volumes to\n    their neighboring atoms.\n\n    NOTE: Volumes may not have a physical meaning when differences are found\n    between spin up/down systems. They are calculated as the average between\n    the systems.\n\n    Parameters\n    ----------\n    use_electrides : bool, optional\n        Whether or not to consider electrides as quasi-atoms. The default is True.\n    **kwargs : dict\n        Any keyword arguments to use in the corresponding ElfLabeler method\n        for each spin system.\n\n    Returns\n    -------\n    tuple\n        The charges and volumes calculated for each atom.\n\n    \"\"\"\n\n    # get the initial charges/volumes from the spin up system\n    charges, volumes = self.elf_labeler_up.get_charges_and_volumes(\n        use_electrides=use_electrides, **kwargs\n    )\n    # convert to lists\n    charges = charges.tolist()\n    volumes = volumes.tolist()\n\n    # get the charges from the spin down system\n    charges_down, volumes_down = self.elf_labeler_down.get_charges_and_volumes(\n        use_electrides=use_electrides, **kwargs\n    )\n    # get structures from each system\n    if use_electrides:\n        structure_up = self.elf_labeler_up.electride_structure\n        structure_down = self.elf_labeler_down.electride_structure\n    else:\n        structure_up = self.structure\n        structure_down = self.structure\n    # add charge from spin down structure\n    for site, charge, volume in zip(structure_down, charges_down, volumes_down):\n        if site in structure_up:\n            index = structure_up.index(site)\n            charges[index] += charge\n            volumes[index] += volume\n        else:\n            charges.append(charge)\n            volumes.append(volume)\n    return np.array(charges), np.array(volumes) / 2\n</code></pre>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.get_oxidation_and_volumes_from_potcar","title":"<code>get_oxidation_and_volumes_from_potcar(potcar_path='POTCAR', use_electrides=True, **kwargs)</code>","text":"<p>Calculates oxidation states, charges, and volumes by splitting feature charges/volumes to their neighboring atoms and comparing to the valence electrons in the POTCAR.</p> <p>NOTE: Volumes may not have a physical meaning when differences are found between spin up/down systems. They are calculated as the average between the systems.</p> <p>Parameters:</p> Name Type Description Default <code>potcar_path</code> <code>Path | str</code> <p>The Path to the POTCAR file. The default is \"POTCAR\".</p> <code>'POTCAR'</code> <code>use_electrides</code> <code>bool</code> <p>Whether or not to consider electrides as quasi-atoms. The default is True.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Any keyword arguments to use in the corresponding ElfLabeler method for each spin system.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple</code> <p>The oxidation states, charges, and volumes calculated for each atom.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler_spin.py</code> <pre><code>def get_oxidation_and_volumes_from_potcar(\n    self, potcar_path: Path = \"POTCAR\", use_electrides: bool = True, **kwargs\n):\n    \"\"\"\n    Calculates oxidation states, charges, and volumes by splitting feature\n    charges/volumes to their neighboring atoms and comparing to the valence\n    electrons in the POTCAR.\n\n    NOTE: Volumes may not have a physical meaning when differences are found\n    between spin up/down systems. They are calculated as the average between\n    the systems.\n\n    Parameters\n    ----------\n    potcar_path : Path | str, optional\n        The Path to the POTCAR file. The default is \"POTCAR\".\n    use_electrides : bool, optional\n        Whether or not to consider electrides as quasi-atoms. The default is True.\n    **kwargs : dict\n        Any keyword arguments to use in the corresponding ElfLabeler method\n        for each spin system.\n\n    Returns\n    -------\n    tuple\n        The oxidation states, charges, and volumes calculated for each atom.\n\n    \"\"\"\n\n    # get the charges/volumes\n    charges, volumes = self.get_charges_and_volumes(\n        use_electrides=use_electrides, **kwargs\n    )\n    # convert to path\n    potcar_path = Path(potcar_path)\n    # check if potcar exists. If not, return None and a warning\n    if not potcar_path.exists():\n        logging.warning(\n            \"No POTCAR found at provided path. No oxidation states will be calculated.\"\n        )\n        return None, charges, volumes\n\n    # load\n    with warnings.catch_warnings(record=True):\n        potcars = Potcar.from_file(potcar_path)\n    nelectron_data = {}\n    # the result is a list because there can be multiple element potcars\n    # in the file (e.g. for NaCl, POTCAR = POTCAR_Na + POTCAR_Cl)\n    for potcar in potcars:\n        nelectron_data.update({potcar.element: potcar.nelectrons})\n    # calculate oxidation states\n    if use_electrides:\n        structure = self.electride_structure\n    else:\n        structure = self.structure\n\n    oxi_state_data = []\n    for site, site_charge in zip(structure, charges):\n        element_str = site.specie.symbol\n        val_electrons = nelectron_data.get(element_str, 0.0)\n        oxi_state = val_electrons - site_charge\n        oxi_state_data.append(oxi_state)\n\n    return np.array(oxi_state_data), charges, volumes\n</code></pre>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.to_dict","title":"<code>to_dict(potcar_path='POTCAR', use_json=True, splitting_method='weighted_dist')</code>","text":"<p>Gets a dictionary summary of the ElfLabeler analysis.</p> <p>Parameters:</p> Name Type Description Default <code>potcar_path</code> <code>Path | str</code> <p>The Path to a POTCAR file. This must be provided for oxidation states to be calculated, and they will be None otherwise. The default is \"POTCAR\".</p> <code>'POTCAR'</code> <code>use_json</code> <code>bool</code> <p>Convert all entries to JSONable data types. The default is True.</p> <code>True</code> <code>splitting_method</code> <code>Literal['equal', 'pauling', 'dist', 'weighted_dist', 'nearest']</code> <p>See :meth:<code>write_feature_basins</code>.</p> <code>'weighted_dist'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A summary of the ElfLabeler analysis in dictionary form.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler_spin.py</code> <pre><code>def to_dict(\n    self,\n    potcar_path: Path | str = \"POTCAR\",\n    use_json: bool = True,\n    splitting_method: Literal[\n        \"equal\", \"pauling\", \"dist\", \"weighted_dist\", \"nearest\"\n    ] = \"weighted_dist\",\n) -&gt; dict:\n    \"\"\"\n\n    Gets a dictionary summary of the ElfLabeler analysis.\n\n    Parameters\n    ----------\n    potcar_path : Path | str, optional\n        The Path to a POTCAR file. This must be provided for oxidation states\n        to be calculated, and they will be None otherwise. The default is \"POTCAR\".\n    use_json : bool, optional\n        Convert all entries to JSONable data types. The default is True.\n    splitting_method : Literal[\"equal\", \"pauling\", \"dist\", \"weighted_dist\", \"nearest\"], optional\n        See :meth:`write_feature_basins`.\n\n    Returns\n    -------\n    dict\n        A summary of the ElfLabeler analysis in dictionary form.\n\n    \"\"\"\n    results = {}\n    # collect method kwargs\n    results[\"method_kwargs\"] = {\n        \"splitting_method\": splitting_method,\n    }\n\n    oxidation_states, charges, volumes = self.get_oxidation_and_volumes_from_potcar(\n        potcar_path=potcar_path, use_electrides=False\n    )\n    oxidation_states_e, charges_e, volumes_e = (\n        self.get_oxidation_and_volumes_from_potcar(\n            potcar_path=potcar_path, use_electrides=True\n        )\n    )\n\n    if oxidation_states is not None:\n        oxidation_states = oxidation_states.tolist()\n        oxidation_states_e = oxidation_states_e.tolist()\n\n    results[\"oxidation_states\"] = oxidation_states\n    results[\"oxidation_states_e\"] = oxidation_states_e\n    results[\"charges\"] = charges.tolist()\n    results[\"charges_e\"] = charges_e.tolist()\n    results[\"volumes\"] = volumes.tolist()\n    results[\"volumes_e\"] = volumes_e.tolist()\n\n    # add objects that can convert to json\n    for result in [\n        \"structure\",\n        \"labeled_structure\",\n        \"electride_structure\",\n    ]:\n        result_obj = getattr(self, result, None)\n        if result_obj is not None and use_json:\n            result_obj = result_obj.to_json()\n        results[result] = result_obj\n\n    # add objects that are arrays\n    for result in [\n        \"atom_elf_radii\",\n        \"atom_elf_radii_types\",\n        \"atom_elf_radii_e\",\n        \"atom_elf_radii_types_e\",\n    ]:\n        result_obj = getattr(self, result, None)\n        if use_json and result_obj is not None:\n            result_obj = result_obj.tolist()\n        results[result] = result_obj\n\n    # add other objects that are already jsonable\n    for result in [\n        \"spin_system\",\n        \"nelectrides\",\n        \"feature_types\",\n        \"electride_formula\",\n        \"electrides_per_formula\",\n        \"electrides_per_reduced_formula\",\n        \"total_electron_number\",\n        \"total_volume\",\n        \"vacuum_charge\",\n        \"vacuum_volume\",\n    ]:\n        results[result] = getattr(self, result, None)\n\n    return results\n</code></pre>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.to_json","title":"<code>to_json(**kwargs)</code>","text":"<p>Creates a JSON string representation of the results, typically for writing results to file.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Keyword arguments for the to_dict method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the BadELF results.</p> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler_spin.py</code> <pre><code>def to_json(self, **kwargs) -&gt; str:\n    \"\"\"\n    Creates a JSON string representation of the results, typically for writing\n    results to file.\n\n    Parameters\n    ----------\n    **kwargs : dict\n        Keyword arguments for the to_dict method.\n\n    Returns\n    -------\n    str\n        A JSON string representation of the BadELF results.\n\n    \"\"\"\n    return json.dumps(self.to_dict(use_json=True, **kwargs))\n</code></pre>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.write_all_features","title":"<code>write_all_features(directory=Path('.'), write_reference=True, prefix_override=None, **kwargs)</code>","text":"<p>Writes the bader basins associated with all features</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The directory to write to. The default is None.</p> <code>Path('.')</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge density. The default is True.</p> <code>True</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid. The default is None.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the ElfLabeler write method.</p> <code>{}</code> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler_spin.py</code> <pre><code>def write_all_features(\n    self,\n    directory: str | Path = Path(\".\"),\n    write_reference: bool = True,\n    prefix_override: str = None,\n    **kwargs,\n):\n    \"\"\"\n    Writes the bader basins associated with all features\n\n    Parameters\n    ----------\n    directory : str | Path, optional\n        The directory to write to. The default is None.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge\n        density. The default is True.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid. The default is None.\n    **kwargs : dict\n        Keyword arguments to pass to the ElfLabeler write method.\n\n    \"\"\"\n\n    if directory is None:\n        directory = Path(\".\")\n\n    # get prefix\n    if prefix_override is None:\n        if write_reference:\n            prefix_override = self.original_reference_grid.data_type.prefix\n        else:\n            prefix_override = self.original_charge_grid.data_type.prefix\n\n    # temporarily update prefix override to avoid overwriting\n    if self.equal_spin:\n        temp_prefix = f\"{prefix_override}_temp\"\n    else:\n        temp_prefix = prefix_override\n\n    for feat_idx in range(len(self.elf_labeler_up.feature_charges)):\n        self.elf_labeler_up.write_feature_basins(\n            feature_indices=[feat_idx],\n            directory=directory,\n            write_reference=write_reference,\n            prefix_override=temp_prefix,\n            **kwargs,\n        )\n        if not self.equal_spin:\n            # rename with \"up\" so we don't overwrite\n            os.rename(\n                directory / f\"{temp_prefix}_f{feat_idx}\",\n                directory / f\"{prefix_override}_f{feat_idx}_up\",\n            )\n        else:\n            os.rename(\n                directory / f\"{temp_prefix}_f{feat_idx}\",\n                directory / f\"{prefix_override}_f{feat_idx}\",\n            )\n    if self.equal_spin:\n        return\n    # Write the spin down file and change the name\n    for feat_idx in range(len(self.elf_labeler_down.feature_charges)):\n        self.elf_labeler_down.write_feature_basins(\n            feature_indices=[feat_idx],\n            directory=directory,\n            write_reference=write_reference,\n            prefix_override=temp_prefix,\n            **kwargs,\n        )\n        if not self.equal_spin:\n            # rename with \"up\" so we don't overwrite\n            os.rename(\n                directory / f\"{temp_prefix}_f{feat_idx}\",\n                directory / f\"{prefix_override}_f{feat_idx}_down\",\n            )\n</code></pre>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.write_bifurcation_plot","title":"<code>write_bifurcation_plot(filename)</code>","text":"<p>Writes an html plot representing the bifurcation graph.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | Path</code> <p>The file to write the bifurcation plot to.</p> required Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler_spin.py</code> <pre><code>def write_bifurcation_plot(self, filename: str | Path):\n    \"\"\"\n    Writes an html plot representing the bifurcation graph.\n\n    Parameters\n    ----------\n    filename : str | Path\n        The file to write the bifurcation plot to.\n\n    \"\"\"\n    filename = Path(filename)\n\n    if filename.suffix:\n        filename_up = filename.with_name(f\"{filename.stem}_up{filename.suffix}\")\n        filename_down = filename.with_name(f\"{filename.stem}_down{filename.suffix}\")\n    else:\n        filename_up = filename.with_name(f\"{filename.name}_up\")\n        filename_down = filename.with_name(f\"{filename.name}_down\")\n\n    self.elf_labeler_up.write_bifurcation_plot(filename_up)\n    self.elf_labeler_down.write_bifurcation_plot(filename_down)\n</code></pre>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.write_features_by_type","title":"<code>write_features_by_type(included_types, directory=Path('.'), prefix_override=None, write_reference=True, **kwargs)</code>","text":"<p>Writes the reference ELF or charge-density for the the union of the given atoms to a single file.</p> <p>Parameters:</p> Name Type Description Default <code>included_types</code> <code>list[FeatureType]</code> <p>The types of features to include, e.g. metallic, lone-pair, etc.</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>Path('.')</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is True.</p> <code>True</code> <code>**kwargs</code> <p>See :meth:<code>write_feature_basins</code>.</p> <code>{}</code> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler_spin.py</code> <pre><code>def write_features_by_type(\n    self,\n    included_types: list[FeatureType],\n    directory: str | Path = Path(\".\"),\n    prefix_override=None,\n    write_reference: bool = True,\n    **kwargs,\n):\n    \"\"\"\n\n    Writes the reference ELF or charge-density for the the union of the\n    given atoms to a single file.\n\n    Parameters\n    ----------\n    included_types : list[FeatureType]\n        The types of features to include, e.g. metallic, lone-pair, etc.\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is True.\n    **kwargs :\n        See :meth:`write_feature_basins`.\n\n    \"\"\"\n    if directory is None:\n        directory = Path(\".\")\n\n    # get prefix\n    if prefix_override is None:\n        if write_reference:\n            prefix_override = self.original_reference_grid.data_type.prefix\n        else:\n            prefix_override = self.original_charge_grid.data_type.prefix\n\n    # temporarily update prefix override to avoid overwriting\n    if self.equal_spin:\n        temp_prefix = f\"{prefix_override}_temp\"\n    else:\n        temp_prefix = prefix_override\n\n    for feat_type in included_types:\n        feat_type = FeatureType(feat_type)\n\n        self.elf_labeler_up.write_features_by_type(\n            included_types=[feat_type],\n            directory=directory,\n            write_reference=write_reference,\n            prefix_override=temp_prefix,\n            **kwargs,\n        )\n\n        if not self.equal_spin:\n            # rename with \"up\" so we don't overwrite\n            os.rename(\n                directory / f\"{temp_prefix}_{feat_type.dummy_species}\",\n                directory / f\"{prefix_override}_{feat_type.dummy_species}_up\",\n            )\n        else:\n            os.rename(\n                directory / f\"{temp_prefix}_{feat_type.dummy_species}\",\n                directory / f\"{prefix_override}_{feat_type.dummy_species}\",\n            )\n            return\n\n            # Write the spin down file and change the name\n        # temporarily update prefix override to avoid overwriting\n        self.elf_labeler_down.write_features_by_type(\n            included_types=[feat_type],\n            directory=directory,\n            write_reference=write_reference,\n            prefix_override=temp_prefix,\n            **kwargs,\n        )\n        if not self.equal_spin:\n            # rename with \"up\" so we don't overwrite\n            os.rename(\n                directory / f\"{temp_prefix}_{feat_type.dummy_species}\",\n                directory / f\"{prefix_override}_{feat_type.dummy_species}_down\",\n            )\n</code></pre>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.write_features_by_type_sum","title":"<code>write_features_by_type_sum(included_types, directory=Path('.'), prefix_override=None, write_reference=True, **kwargs)</code>","text":"<p>Writes the reference ELF or charge-density for the the union of the given atoms to a single file.</p> <p>Parameters:</p> Name Type Description Default <code>included_types</code> <code>list[FeatureType]</code> <p>The types of features to include, e.g. metallic, lone-pair, etc.</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>Path('.')</code> <code>prefix_override</code> <code>str</code> <p>The string to add at the front of the output path. If None, defaults to the VASP file name equivalent to the data type stored in the grid.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is True.</p> <code>True</code> <code>**kwargs</code> <p>See :meth:<code>write_feature_basins</code>.</p> <code>{}</code> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler_spin.py</code> <pre><code>def write_features_by_type_sum(\n    self,\n    included_types: list[FeatureType],\n    directory: str | Path = Path(\".\"),\n    prefix_override=None,\n    write_reference: bool = True,\n    **kwargs,\n):\n    \"\"\"\n\n    Writes the reference ELF or charge-density for the the union of the\n    given atoms to a single file.\n\n    Parameters\n    ----------\n    included_types : list[FeatureType]\n        The types of features to include, e.g. metallic, lone-pair, etc.\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    prefix_override : str, optional\n        The string to add at the front of the output path. If None, defaults\n        to the VASP file name equivalent to the data type stored in the\n        grid.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is True.\n    **kwargs :\n        See :meth:`write_feature_basins`.\n\n    \"\"\"\n    if directory is None:\n        directory = Path(\".\")\n\n    # get prefix\n    if prefix_override is None:\n        if write_reference:\n            prefix_override = self.original_reference_grid.data_type.prefix\n        else:\n            prefix_override = self.original_charge_grid.data_type.prefix\n\n    # temporarily update prefix override to avoid overwriting\n    if self.equal_spin:\n        temp_prefix = f\"{prefix_override}_temp\"\n    else:\n        temp_prefix = prefix_override\n\n    self.elf_labeler_up.write_features_by_type_sum(\n        included_types=included_types,\n        directory=directory,\n        write_reference=write_reference,\n        prefix_override=temp_prefix,\n        **kwargs,\n    )\n    if not self.equal_spin:\n        # rename with \"up\" so we don't overwrite\n        os.rename(\n            directory / f\"{temp_prefix}_fsum\",\n            directory / f\"{prefix_override}_fsum_up\",\n        )\n    else:\n        os.rename(\n            directory / f\"{temp_prefix}_fsum\",\n            directory / f\"{prefix_override}_fsum\",\n        )\n        return\n\n    # Write the spin down file and change the name\n    # temporarily update prefix override to avoid overwriting\n    self.elf_labeler_down.write_features_by_type_sum(\n        included_types=included_types,\n        directory=directory,\n        write_reference=write_reference,\n        prefix_override=temp_prefix,\n        **kwargs,\n    )\n    if not self.equal_spin:\n        # rename with \"up\" so we don't overwrite\n        os.rename(\n            directory / f\"{temp_prefix}_fsum\",\n            directory / f\"{prefix_override}_fsum_down\",\n        )\n</code></pre>"},{"location":"api_reference/core/labeler_spin/#src.baderkit.core.labelers.elf_labeler.SpinElfLabeler.write_json","title":"<code>write_json(filepath='elf_labeler.json', **kwargs)</code>","text":"<p>Writes results of the analysis to file in a JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Path | str</code> <p>The Path to write the results to. The default is \"badelf_results_summary.json\".</p> <code>'elf_labeler.json'</code> <code>**kwargs</code> <code>dict</code> <p>keyword arguments for the to_dict method.</p> <code>{}</code> Source code in <code>src/baderkit/core/labelers/elf_labeler/elf_labeler_spin.py</code> <pre><code>def write_json(self, filepath: Path | str = \"elf_labeler.json\", **kwargs) -&gt; None:\n    \"\"\"\n    Writes results of the analysis to file in a JSON format.\n\n    Parameters\n    ----------\n    filepath : Path | str, optional\n        The Path to write the results to. The default is \"badelf_results_summary.json\".\n    **kwargs : dict\n        keyword arguments for the to_dict method.\n\n    \"\"\"\n    filepath = Path(filepath)\n    # write spin up and spin down summaries\n    filepath_up = filepath.parent / f\"{filepath.stem}_up{filepath.suffix}\"\n    filepath_down = filepath.parent / f\"{filepath.stem}_down{filepath.suffix}\"\n    self.elf_labeler_up.write_json(filepath=filepath_up, **kwargs)\n    self.elf_labeler_down.write_json(filepath=filepath_down, **kwargs)\n\n    # write total spin summary\n    with open(filepath, \"w\") as json_file:\n        json.dump(self.to_dict(use_json=True, **kwargs), json_file, indent=4)\n</code></pre>"},{"location":"api_reference/plotting/bader/","title":"Bader","text":"<p>               Bases: <code>GridPlotter</code></p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>class BaderPlotter(GridPlotter):\n    def __init__(\n        self,\n        bader: Bader,\n        **grid_kwargs,\n    ):\n        \"\"\"\n        A convenience class for creating plots of individual Bader basins\n        using pyvista's package for VTK.\n\n        Parameters\n        ----------\n        bader : Bader\n            The Bader object to use for isolating basins and creating isosurfaces.\n            The structure will be pulled from the charge grid.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # apply StructurePlotter kwargs\n        grid = bader.charge_grid\n        super().__init__(grid=grid, **grid_kwargs)\n        self.bader = bader\n\n        # pad the label arrays then flatten them\n        padded_basins = np.pad(\n            bader.basin_labels, pad_width=((0, 1), (0, 1), (0, 1)), mode=\"wrap\"\n        )\n        padded_atoms = np.pad(\n            bader.atom_labels, pad_width=((0, 1), (0, 1), (0, 1)), mode=\"wrap\"\n        )\n        # padded_basins = bader.basin_labels\n        # padded_atoms = bader.atom_labels\n        self.flat_bader_basins = padded_basins.ravel(order=\"F\")\n        self.flat_atom_basins = padded_atoms.ravel(order=\"F\")\n\n        # get the initial empty list of visible atom labels and visible basin labels\n        self._visible_bader_basins = set(\n            [i for i, ai in enumerate(bader.basin_atoms) if ai == 0]\n        )\n        self._visible_atom_basins = set()\n        self.visible_bader_basins = [\n            i for i, ai in enumerate(bader.basin_atoms) if ai == 0\n        ]\n        self.visible_atom_basins = []\n        self._hidden_mask = np.zeros(len(self.flat_bader_basins), dtype=bool)\n\n    @property\n    def visible_bader_basins(self) -&gt; list[int]:\n        \"\"\"\n\n        Returns\n        -------\n        list[int]\n            A list of bader basin indices that are currently visible.\n\n        \"\"\"\n        return self._visible_bader_basins\n\n    @visible_bader_basins.setter\n    def visible_bader_basins(self, visible_bader_basins: set[int]):\n        # make sure input is set\n        visible_bader_basins = set(visible_bader_basins)\n        # set visible basins\n        self._visible_bader_basins = visible_bader_basins\n        # update plotter\n        self._update_plotter_mask()\n\n    @property\n    def visible_atom_basins(self) -&gt; list[int]:\n        \"\"\"\n\n        Returns\n        -------\n        list[int]\n            A list of atom indices whose basins are currently visible.\n\n        \"\"\"\n        return self._visible_atom_basins\n\n    @visible_atom_basins.setter\n    def visible_atom_basins(self, visible_atom_basins: set[int]):\n        # make sure input is set\n        visible_atom_basins = set(visible_atom_basins)\n        # update visible basins set\n        self._visible_atom_basins = visible_atom_basins\n        # update plotter\n        self._update_plotter_mask()\n\n    def _update_plotter_mask(self):\n        \"\"\"\n        Updates the mask indicating which areas of the grid should not be shown\n        then sets the regions to -1.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        hidden_mask = ~(\n            np.isin(self.flat_bader_basins, list(self._visible_bader_basins))\n            | np.isin(self.flat_atom_basins, list(self._visible_atom_basins))\n        )\n        self._hidden_mask = hidden_mask\n        # NOTE: using hide_cells works, but results in some funky artifacting.\n        # Maybe there's a way to get it to work, but for now I'm replacing it\n        # for visual quality\n        # self.structured_grid.hide_cells(self.hidden_mask, inplace=True)\n        # update structured_grid\n        temp_values = self.values.copy()\n        temp_values[hidden_mask] = -1\n        self.structured_grid = self._make_structured_grid(temp_values)\n        # update the surface\n        self.surface = self.structured_grid.extract_surface()\n        # update plotter\n        self.iso_val = self._iso_val\n</code></pre>"},{"location":"api_reference/plotting/bader/#src.baderkit.plotting.core.plotter.BaderPlotter.visible_atom_basins","title":"<code>visible_atom_basins</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>list[int]</code> <p>A list of atom indices whose basins are currently visible.</p>"},{"location":"api_reference/plotting/bader/#src.baderkit.plotting.core.plotter.BaderPlotter.visible_bader_basins","title":"<code>visible_bader_basins</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>list[int]</code> <p>A list of bader basin indices that are currently visible.</p>"},{"location":"api_reference/plotting/bader/#src.baderkit.plotting.core.plotter.BaderPlotter.__init__","title":"<code>__init__(bader, **grid_kwargs)</code>","text":"<p>A convenience class for creating plots of individual Bader basins using pyvista's package for VTK.</p> <p>Parameters:</p> Name Type Description Default <code>bader</code> <code>Bader</code> <p>The Bader object to use for isolating basins and creating isosurfaces. The structure will be pulled from the charge grid.</p> required <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def __init__(\n    self,\n    bader: Bader,\n    **grid_kwargs,\n):\n    \"\"\"\n    A convenience class for creating plots of individual Bader basins\n    using pyvista's package for VTK.\n\n    Parameters\n    ----------\n    bader : Bader\n        The Bader object to use for isolating basins and creating isosurfaces.\n        The structure will be pulled from the charge grid.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # apply StructurePlotter kwargs\n    grid = bader.charge_grid\n    super().__init__(grid=grid, **grid_kwargs)\n    self.bader = bader\n\n    # pad the label arrays then flatten them\n    padded_basins = np.pad(\n        bader.basin_labels, pad_width=((0, 1), (0, 1), (0, 1)), mode=\"wrap\"\n    )\n    padded_atoms = np.pad(\n        bader.atom_labels, pad_width=((0, 1), (0, 1), (0, 1)), mode=\"wrap\"\n    )\n    # padded_basins = bader.basin_labels\n    # padded_atoms = bader.atom_labels\n    self.flat_bader_basins = padded_basins.ravel(order=\"F\")\n    self.flat_atom_basins = padded_atoms.ravel(order=\"F\")\n\n    # get the initial empty list of visible atom labels and visible basin labels\n    self._visible_bader_basins = set(\n        [i for i, ai in enumerate(bader.basin_atoms) if ai == 0]\n    )\n    self._visible_atom_basins = set()\n    self.visible_bader_basins = [\n        i for i, ai in enumerate(bader.basin_atoms) if ai == 0\n    ]\n    self.visible_atom_basins = []\n    self._hidden_mask = np.zeros(len(self.flat_bader_basins), dtype=bool)\n</code></pre>"},{"location":"api_reference/plotting/grid/","title":"Grid","text":"<p>               Bases: <code>StructurePlotter</code></p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>class GridPlotter(StructurePlotter):\n    def __init__(\n        self,\n        grid: Grid,\n        **structure_kwargs,\n        # downscale: int | None = 400,\n    ):\n        \"\"\"\n        A convenience class for creating plots of crystal structures and isosurfaces\n        using pyvista's package for VTK.\n\n        Parameters\n        ----------\n        grid : Grid\n            The Grid object to use for isosurfaces. The structure will be pulled\n            from this grid.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # apply StructurePlotter kwargs\n        super().__init__(structure=grid.structure, **structure_kwargs)\n\n        # Grid specific items\n        # if downscale is not None:\n        #     if grid.voxel_resolution &gt; downscale:\n        #         # downscale the grid for speed\n        #         logging.info(\"Grid is above desired resolution. Downscaling.\")\n        #         grid = grid.regrid(downscale)\n        self.grid = grid\n        self._show_surface = True\n        self._show_caps = True\n        self._surface_opacity = 0.8\n        self._cap_opacity = 0.8\n        self._colormap = \"viridis\"\n        self._use_solid_surface_color = False\n        self._use_solid_cap_color = False\n        self._surface_color = \"#BA8E23\"\n        self._cap_color = \"#BA8E23\"\n\n        # wrap values around to get one extra voxel on the far side of each axis.\n        values = np.pad(grid.total, pad_width=((0, 1), (0, 1), (0, 1)), mode=\"wrap\")\n        self.shape = values.shape\n        self.values = values.ravel(order=\"F\")\n        self._min_val = self.values.min()\n        # make min val slightly above 0\n        self._min_val += 0.0000001 * self._min_val\n        self._max_val = self.values.max()\n        # determine default iso if not provided\n        self._iso_val = self._min_val  # np.mean(grid.total)\n        # generate the structured grid\n        indices = np.indices(self.shape).reshape(3, -1, order=\"F\").T\n        self.points = grid.grid_to_cart(indices)\n        self.structured_grid = self._make_structured_grid(self.values)\n        # generate the surface\n        self.surface = self.structured_grid.extract_surface()\n        # update plotter\n        self.plotter = self._create_grid_plot()\n\n    def _make_structured_grid(self, values: NDArray[float]) -&gt; pv.StructuredGrid:\n        \"\"\"\n        Creates a pyvista StructuredGrid object for making isosurfaces. This\n        should generally not be called directly.\n\n        Parameters\n        ----------\n        values : NDArray[float]\n            A 3xN array of values representing the data in the structured grid.\n            These should be raveled/reshaped using Fortran's conventions (order='F'')\n\n        Returns\n        -------\n        structured_grid : pv.StructuredGrid\n            A pyvista StructuredGrid with values representing the grid data.\n\n        \"\"\"\n        structured_grid = pv.StructuredGrid()\n        structured_grid.points = self.points\n        structured_grid.dimensions = self.shape\n        structured_grid[\"values\"] = values\n        return structured_grid\n\n    @property\n    def show_surface(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            whether or not to display the isosurface.\n\n        \"\"\"\n        return self._show_surface\n\n    @show_surface.setter\n    def show_surface(self, show_surface: bool):\n        if \"iso\" in self.plotter.actors.keys():\n            actor = self.plotter.actors[\"iso\"]\n            actor.visibility = show_surface\n        self._show_surface = show_surface\n\n    @property\n    def show_caps(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            Whether or not to display caps on the isosurface.\n\n        \"\"\"\n        return self._show_caps\n\n    @show_caps.setter\n    def show_caps(self, show_caps: bool):\n        if \"cap\" in self.plotter.actors.keys():\n            actor = self.plotter.actors[\"cap\"]\n            actor.visibility = show_caps\n        self._show_caps = show_caps\n\n    @property\n    def surface_opacity(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            Opacity of the isosurface.\n\n        \"\"\"\n        return self._surface_opacity\n\n    @surface_opacity.setter\n    def surface_opacity(self, surface_opacity: float):\n        if \"iso\" in self.plotter.actors.keys():\n            actor = self.plotter.actors[\"iso\"]\n            actor.prop.opacity = surface_opacity\n        self._surface_opacity = surface_opacity\n\n    @property\n    def cap_opacity(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            Opacity of the caps.\n\n        \"\"\"\n        return self._cap_opacity\n\n    @cap_opacity.setter\n    def cap_opacity(self, cap_opacity: float):\n        if \"cap\" in self.plotter.actors.keys():\n            actor = self.plotter.actors[\"cap\"]\n            actor.prop.opacity = cap_opacity\n        self._cap_opacity = cap_opacity\n\n    @property\n    def colormap(self) -&gt; str:\n        \"\"\"\n\n        Returns\n        -------\n        str\n            The colormap for the caps and isosurface. This is ignored when the\n            surface or caps are set to use solid colors. Valid options are those\n            available in matplotlib.\n\n        \"\"\"\n        return self._colormap\n\n    @colormap.setter\n    def colormap(self, colormap: str):\n        # update settings\n        self._colormap = colormap\n        if not self.use_solid_surface_color:\n            self._add_iso_mesh()\n        if not self.use_solid_cap_color:\n            self._add_cap_mesh()\n\n    @property\n    def min_val(self) -&gt; str:\n        return self._min_val\n\n    @min_val.setter\n    def min_val(self, value: float):\n\n        # make sure value is below max value\n        value = min(self.max_val, value)\n\n        # update settings\n        self._min_val = value\n        self._add_cap_mesh()\n\n    @property\n    def max_val(self) -&gt; str:\n        return self._max_val\n\n    @max_val.setter\n    def max_val(self, value: float):\n\n        # make sure value is above min value\n        value = max(self.min_val, value)\n\n        # update settings\n        self._max_val = value\n        self._add_cap_mesh()\n\n    @property\n    def use_solid_surface_color(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            whether or not to use a solid color for the isosurface.\n        \"\"\"\n        return self._use_solid_surface_color\n\n    # TODO: Figure out a way to set the cmap without remaking the surface?\n    @use_solid_surface_color.setter\n    def use_solid_surface_color(self, use_solid_surface_color: bool):\n        # update property\n        self._use_solid_surface_color = use_solid_surface_color\n        # remove surface and add it back with new color/cmap\n        self._add_iso_mesh()\n\n    @property\n    def use_solid_cap_color(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            whether or not to use a solid color for the caps.\n        \"\"\"\n        return self._use_solid_cap_color\n\n    @use_solid_cap_color.setter\n    def use_solid_cap_color(self, use_solid_cap_color: bool):\n        # update property\n        self._use_solid_cap_color = use_solid_cap_color\n        # remove cap and add it back with new color/cmap\n        self._add_cap_mesh()\n\n    @property\n    def surface_color(self) -&gt; str:\n        \"\"\"\n\n        Returns\n        -------\n        str\n            The color to use for the surface as a hex string. This is ignored if\n            the surface is not set to use solid colors.\n\n        \"\"\"\n        return self._surface_color\n\n    @surface_color.setter\n    def surface_color(self, surface_color: str):\n        self._surface_color = surface_color\n        if self.use_solid_surface_color:\n            self._add_iso_mesh()\n\n    @property\n    def cap_color(self):\n        \"\"\"\n\n        Returns\n        -------\n        str\n            The color to use for the caps as a hex string. This is ignored if\n            the caps are not set to use solid colors.\n\n        \"\"\"\n        return self._cap_color\n\n    @cap_color.setter\n    def cap_color(self, cap_color: str):\n        self._cap_color = cap_color\n        if self.use_solid_cap_color:\n            self._add_cap_mesh()\n\n    @property\n    def iso_val(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The value to set the isosurface to.\n\n        \"\"\"\n        return self._iso_val\n\n    @iso_val.setter\n    def iso_val(self, iso_val: float):\n        # make sure iso value is within range\n        iso_val = max(self.min_val, min(iso_val, self.max_val))\n        self._iso_val = iso_val\n        self._update_surface_mesh(iso_val)\n        self._add_iso_mesh()\n        self._add_cap_mesh()\n\n    def _update_surface_mesh(self, iso_value: float):\n        \"\"\"\n        Updates the surface meshes to the provided iso_value\n\n        Parameters\n        ----------\n        iso_value : float\n            The value to update the surface meshes to\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        self.iso = self.structured_grid.contour([iso_value])\n        self.cap = self.surface.contour_banded(\n            2, rng=[iso_value, self.max_val], generate_contour_edges=False\n        )\n\n    def _get_surface_kwargs(self) -&gt; dict:\n        \"\"\"\n        Generates the keyword arguments to use when adding the surface to\n        the plotter. We need this because setting a solid color vs. a colormap\n        requires different keywords\n\n        Returns\n        -------\n        dict\n            The keyword arguments for setting the surface mesh in the plotter.\n\n        \"\"\"\n        kwargs = {\n            \"opacity\": self.surface_opacity,\n            \"pbr\": True,\n            \"name\": \"iso\",\n        }\n        kwargs[\"color\"] = self.surface_color\n        if self.use_solid_surface_color:\n            kwargs[\"color\"] = self.surface_color\n        else:\n            kwargs[\"colormap\"] = self.colormap\n            kwargs[\"scalars\"] = \"values\"\n            kwargs[\"clim\"] = [self.min_val, self.max_val]\n            kwargs[\"show_scalar_bar\"] = False\n        return kwargs\n\n    def _get_cap_kwargs(self) -&gt; dict:\n        \"\"\"\n        Generates the keyword arguments to use when adding the caps to\n        the plotter. We need this because setting a solid color vs. a colormap\n        requires different keywords\n\n        Returns\n        -------\n        dict\n            The keyword arguments for setting the caps mesh in the plotter.\n\n        \"\"\"\n        kwargs = {\n            \"opacity\": self.cap_opacity,\n            \"pbr\": True,\n            \"name\": \"cap\",\n        }\n        if self.use_solid_cap_color:\n            kwargs[\"color\"] = self.cap_color\n        else:\n            kwargs[\"cmap\"] = self.colormap\n            kwargs[\"scalars\"] = \"values\"\n            kwargs[\"clim\"] = [self.min_val, self.max_val]\n            kwargs[\"show_scalar_bar\"] = False\n        return kwargs\n\n    def _add_iso_mesh(self):\n        \"\"\"\n        Removes the current isosurface mesh than adds a new one.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        if self.show_surface:\n            if \"iso\" in self.plotter.actors.keys():\n                self.plotter.remove_actor(\"iso\")\n            if len(self.iso[\"values\"]) &gt; 0:\n                self.plotter.add_mesh(self.iso, **self._get_surface_kwargs())\n\n    def _add_cap_mesh(self) -&gt; dict:\n        \"\"\"\n        Removes the current cap mesh than adds a new one.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        if self.show_caps:\n            if \"cap\" in self.plotter.actors.keys():\n                self.plotter.remove_actor(\"cap\")\n            if len(self.iso[\"values\"]) &gt; 0:\n                self.plotter.add_mesh(self.cap, **self._get_cap_kwargs())\n\n    def _create_grid_plot(self) -&gt; pv.Plotter():\n        \"\"\"\n        Generates a pyvista.Plotter object from the current class variables.\n        This is called when the class is first instanced and generally shouldn't\n        be called again.\n\n        Returns\n        -------\n        plotter : pv.Plotter\n            A pyvista Plotter object representing the provided Structure object.\n\n        \"\"\"\n        # get initial plotter with structure\n        plotter = self._create_structure_plot()\n        # generate initial surface meshes\n        self._update_surface_mesh(self.iso_val)\n        # Add iso mesh\n        if len(self.iso[\"values\"]) &gt; 0:\n            plotter.add_mesh(self.iso, **self._get_surface_kwargs())\n        # Add cap mesh\n        if len(self.cap[\"values\"]) &gt; 0:\n            plotter.add_mesh(self.cap, **self._get_cap_kwargs())\n        return plotter\n\n    def rebuild(self):\n        \"\"\"\n        Builds a new pyvista plotter object representing the current state of\n        the Plotter class.\n\n        Returns\n        -------\n        pv.Plotter\n            A pyvista Plotter object representing the current state of the\n            GridPlotter class.\n\n        \"\"\"\n        return self._create_grid_plot()\n\n    def get_slice_plot(\n        self,\n        hkl: NDArray,\n        d: float,\n        include_atoms: bool = True,\n        filepath: Path = None,\n        **write_kwargs,\n    ):\n        \"\"\"\n        Generates a pyvista plot of a slice at the requested miller plane. If\n        a filepath is provided, the plot is written and no plot object is returned.\n\n        Parameters\n        ----------\n        hkl : NDArray\n            The miller indices of the plane to use.\n        d : float\n            The multiplier for the d-spacing of the current plane\n        include_atoms : bool, optional\n            Whether or not atoms should be incuded. Only atoms whose sphere mesh\n            is sliced by the plane are included. The default is True.\n        filepath : Path, optional\n            The filepath to write the plot to if desired. The default is None.\n        **write_kwargs\n            any additional keyword arguments to provide to the plot writer.\n\n        Returns\n        -------\n        p : pv.plotter | None\n            the pyvista plot of the slice or None if a filepath was provided.\n\n        \"\"\"\n        h, k, l = hkl\n        # get normal vector in cart coords\n        normal = self.structure.get_cart_from_miller(h, k, l)\n        n = self.structure.lattice.d_hkl(hkl)\n        origin = normal * n * d\n        slice_plane = self.structured_grid.slice(normal=normal, origin=origin)\n\n        # create plotter\n        p = pv.Plotter(off_screen=True)\n        p.add_mesh(\n            slice_plane,\n            scalars=\"values\",\n            cmap=self.colormap,\n            clim=(self.min_val, self.max_val),\n            show_scalar_bar=False,\n        )\n\n        # if desired, add any atoms that sit on/near the plane\n        if include_atoms:\n            for i, (site, color) in enumerate(zip(self.structure, self.colors)):\n                center = site.coords\n                radius = self.radii[i]\n                dist = np.dot(center - origin, normal)\n                if not abs(dist) &lt;= radius:\n                    continue\n                # otherwise remove the actor, regenerate, and replot\n                atom_mesh = self.get_site_mesh(i)\n                p.add_mesh(\n                    atom_mesh,\n                    color=color,\n                    metallic=self.atom_metallicness,\n                    pbr=True,  # enable physical based rendering\n                    name=f\"{site.label}\",\n                )\n        # set camera to be perpendicular\n        camera = self.get_camera_position_from_miller(h, k, l)\n        p.camera_position = camera\n        p.camera.parallel_projection = True\n        # p.reset_camera() # zoom to fit\n        self._set_camera_tight(p.camera)\n\n        if filepath is not None:\n            p.screenshot(filepath, **write_kwargs)\n            p.close()\n            return\n\n        return p\n</code></pre>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.cap_color","title":"<code>cap_color</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The color to use for the caps as a hex string. This is ignored if the caps are not set to use solid colors.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.cap_opacity","title":"<code>cap_opacity</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>Opacity of the caps.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.colormap","title":"<code>colormap</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The colormap for the caps and isosurface. This is ignored when the surface or caps are set to use solid colors. Valid options are those available in matplotlib.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.iso_val","title":"<code>iso_val</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The value to set the isosurface to.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.show_caps","title":"<code>show_caps</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to display caps on the isosurface.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.show_surface","title":"<code>show_surface</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>whether or not to display the isosurface.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.surface_color","title":"<code>surface_color</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The color to use for the surface as a hex string. This is ignored if the surface is not set to use solid colors.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.surface_opacity","title":"<code>surface_opacity</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>Opacity of the isosurface.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.use_solid_cap_color","title":"<code>use_solid_cap_color</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>whether or not to use a solid color for the caps.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.use_solid_surface_color","title":"<code>use_solid_surface_color</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>whether or not to use a solid color for the isosurface.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.__init__","title":"<code>__init__(grid, **structure_kwargs)</code>","text":"<p>A convenience class for creating plots of crystal structures and isosurfaces using pyvista's package for VTK.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>Grid</code> <p>The Grid object to use for isosurfaces. The structure will be pulled from this grid.</p> required <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def __init__(\n    self,\n    grid: Grid,\n    **structure_kwargs,\n    # downscale: int | None = 400,\n):\n    \"\"\"\n    A convenience class for creating plots of crystal structures and isosurfaces\n    using pyvista's package for VTK.\n\n    Parameters\n    ----------\n    grid : Grid\n        The Grid object to use for isosurfaces. The structure will be pulled\n        from this grid.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # apply StructurePlotter kwargs\n    super().__init__(structure=grid.structure, **structure_kwargs)\n\n    # Grid specific items\n    # if downscale is not None:\n    #     if grid.voxel_resolution &gt; downscale:\n    #         # downscale the grid for speed\n    #         logging.info(\"Grid is above desired resolution. Downscaling.\")\n    #         grid = grid.regrid(downscale)\n    self.grid = grid\n    self._show_surface = True\n    self._show_caps = True\n    self._surface_opacity = 0.8\n    self._cap_opacity = 0.8\n    self._colormap = \"viridis\"\n    self._use_solid_surface_color = False\n    self._use_solid_cap_color = False\n    self._surface_color = \"#BA8E23\"\n    self._cap_color = \"#BA8E23\"\n\n    # wrap values around to get one extra voxel on the far side of each axis.\n    values = np.pad(grid.total, pad_width=((0, 1), (0, 1), (0, 1)), mode=\"wrap\")\n    self.shape = values.shape\n    self.values = values.ravel(order=\"F\")\n    self._min_val = self.values.min()\n    # make min val slightly above 0\n    self._min_val += 0.0000001 * self._min_val\n    self._max_val = self.values.max()\n    # determine default iso if not provided\n    self._iso_val = self._min_val  # np.mean(grid.total)\n    # generate the structured grid\n    indices = np.indices(self.shape).reshape(3, -1, order=\"F\").T\n    self.points = grid.grid_to_cart(indices)\n    self.structured_grid = self._make_structured_grid(self.values)\n    # generate the surface\n    self.surface = self.structured_grid.extract_surface()\n    # update plotter\n    self.plotter = self._create_grid_plot()\n</code></pre>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.get_slice_plot","title":"<code>get_slice_plot(hkl, d, include_atoms=True, filepath=None, **write_kwargs)</code>","text":"<p>Generates a pyvista plot of a slice at the requested miller plane. If a filepath is provided, the plot is written and no plot object is returned.</p> <p>Parameters:</p> Name Type Description Default <code>hkl</code> <code>NDArray</code> <p>The miller indices of the plane to use.</p> required <code>d</code> <code>float</code> <p>The multiplier for the d-spacing of the current plane</p> required <code>include_atoms</code> <code>bool</code> <p>Whether or not atoms should be incuded. Only atoms whose sphere mesh is sliced by the plane are included. The default is True.</p> <code>True</code> <code>filepath</code> <code>Path</code> <p>The filepath to write the plot to if desired. The default is None.</p> <code>None</code> <code>**write_kwargs</code> <p>any additional keyword arguments to provide to the plot writer.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>p</code> <code>plotter | None</code> <p>the pyvista plot of the slice or None if a filepath was provided.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_slice_plot(\n    self,\n    hkl: NDArray,\n    d: float,\n    include_atoms: bool = True,\n    filepath: Path = None,\n    **write_kwargs,\n):\n    \"\"\"\n    Generates a pyvista plot of a slice at the requested miller plane. If\n    a filepath is provided, the plot is written and no plot object is returned.\n\n    Parameters\n    ----------\n    hkl : NDArray\n        The miller indices of the plane to use.\n    d : float\n        The multiplier for the d-spacing of the current plane\n    include_atoms : bool, optional\n        Whether or not atoms should be incuded. Only atoms whose sphere mesh\n        is sliced by the plane are included. The default is True.\n    filepath : Path, optional\n        The filepath to write the plot to if desired. The default is None.\n    **write_kwargs\n        any additional keyword arguments to provide to the plot writer.\n\n    Returns\n    -------\n    p : pv.plotter | None\n        the pyvista plot of the slice or None if a filepath was provided.\n\n    \"\"\"\n    h, k, l = hkl\n    # get normal vector in cart coords\n    normal = self.structure.get_cart_from_miller(h, k, l)\n    n = self.structure.lattice.d_hkl(hkl)\n    origin = normal * n * d\n    slice_plane = self.structured_grid.slice(normal=normal, origin=origin)\n\n    # create plotter\n    p = pv.Plotter(off_screen=True)\n    p.add_mesh(\n        slice_plane,\n        scalars=\"values\",\n        cmap=self.colormap,\n        clim=(self.min_val, self.max_val),\n        show_scalar_bar=False,\n    )\n\n    # if desired, add any atoms that sit on/near the plane\n    if include_atoms:\n        for i, (site, color) in enumerate(zip(self.structure, self.colors)):\n            center = site.coords\n            radius = self.radii[i]\n            dist = np.dot(center - origin, normal)\n            if not abs(dist) &lt;= radius:\n                continue\n            # otherwise remove the actor, regenerate, and replot\n            atom_mesh = self.get_site_mesh(i)\n            p.add_mesh(\n                atom_mesh,\n                color=color,\n                metallic=self.atom_metallicness,\n                pbr=True,  # enable physical based rendering\n                name=f\"{site.label}\",\n            )\n    # set camera to be perpendicular\n    camera = self.get_camera_position_from_miller(h, k, l)\n    p.camera_position = camera\n    p.camera.parallel_projection = True\n    # p.reset_camera() # zoom to fit\n    self._set_camera_tight(p.camera)\n\n    if filepath is not None:\n        p.screenshot(filepath, **write_kwargs)\n        p.close()\n        return\n\n    return p\n</code></pre>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.rebuild","title":"<code>rebuild()</code>","text":"<p>Builds a new pyvista plotter object representing the current state of the Plotter class.</p> <p>Returns:</p> Type Description <code>Plotter</code> <p>A pyvista Plotter object representing the current state of the GridPlotter class.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def rebuild(self):\n    \"\"\"\n    Builds a new pyvista plotter object representing the current state of\n    the Plotter class.\n\n    Returns\n    -------\n    pv.Plotter\n        A pyvista Plotter object representing the current state of the\n        GridPlotter class.\n\n    \"\"\"\n    return self._create_grid_plot()\n</code></pre>"},{"location":"api_reference/plotting/structure/","title":"Structure","text":"Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>class StructurePlotter:\n\n    def __init__(\n        self,\n        structure: Structure,\n        off_screen: bool = False,\n        qt_plotter: bool = False,\n        qt_frame=None,\n        **kwargs,\n    ):\n        \"\"\"\n        A convenience class for creating plots of crystal structures using\n        pyvista's package for VTK.\n\n        Parameters\n        ----------\n        structure : Structure\n            The pymatgen Structure object to plot.\n        off_screen : bool, optional\n            Whether or not the plotter should be in offline mode. The default is False.\n        qt_plotter : bool, optional\n            Whether or not the plotter will use pyvistaqt for qt applications\n        qt_frame\n            If using pyvistaqt, the QFrame to link the plotter to.\n\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # sort and relabel structure for consistency\n        structure = structure.copy()\n        structure.sort()\n        structure.relabel_sites()\n        # create initial class variables\n        self.structure = structure\n        self.off_screen = off_screen\n        self.qt_plotter = qt_plotter\n        self.qt_frame = qt_frame\n        self._visible_atoms = [i for i in range(len(self.structure))]\n        self._show_lattice = True\n        self._wrap_atoms = True\n        self._lattice_thickness = 0.1\n        self._atom_metallicness = 0.0\n        self._background = \"#FFFFFF\"\n        self._view_indices = [1, 0, 0]\n        self._camera_rotation = (0.0,)\n        self._show_axes = True\n        self._parallel_projection = True\n        self._radii = [s.specie.atomic_radius for s in structure]\n        self._colors = [ATOM_COLORS.get(s.specie.symbol, \"#FFFFFF\") for s in structure]\n        # generate initial plotter\n        self.plotter = self._create_structure_plot()\n        self.view_indices = [1, 0, 0]\n        self.up_indices = [0, 0, 1]\n\n    ###########################################################################\n    # Properties and Setters\n    ###########################################################################\n    @property\n    def visible_atoms(self) -&gt; list[int]:\n        \"\"\"\n\n        Returns\n        -------\n        list[int]\n            A list of atom indices to display in the plot.\n\n        \"\"\"\n        return self._visible_atoms\n\n    @visible_atoms.setter\n    def visible_atoms(self, visible_atoms: list[int]):\n        # update visibility of atoms\n        for i, site in enumerate(self.structure):\n            label = site.label\n            actor = self.plotter.actors[f\"{label}\"]\n            if i in visible_atoms:\n                actor.visibility = True\n            else:\n                actor.visibility = False\n        # set visible atoms\n        self._visible_atoms = visible_atoms\n\n    @property\n    def show_lattice(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            Whether or not to display the outline of the unit cell.\n\n        \"\"\"\n        return self._show_lattice\n\n    @show_lattice.setter\n    def show_lattice(self, show_lattice: bool):\n        actor = self.plotter.actors[\"lattice\"]\n        actor.visibility = show_lattice\n        self._show_lattice = show_lattice\n\n    # @property\n    # def wrap_atoms(self):\n    #     return self._wrap_atoms\n\n    # TODO: Make two sets of atoms with and without wraps?\n    # @wrap_atoms.setter\n    # def wrap_atoms(self, wrap_atoms: bool):\n    #     actor = self.plotter.\n\n    @property\n    def lattice_thickness(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The thickness of the lines outlining the unit cell.\n\n        \"\"\"\n        return self._lattice_thickness\n\n    @lattice_thickness.setter\n    def lattice_thickness(self, lattice_thickness: float):\n        actor = self.plotter.actors[\"lattice\"]\n        actor.prop.line_width = lattice_thickness\n        self._lattice_thickness = lattice_thickness\n\n    @property\n    def atom_metallicness(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The amount of metallic character in the atom display.\n\n        \"\"\"\n        return self._atom_metallicness\n\n    @atom_metallicness.setter\n    def atom_metallicness(self, atom_metallicness: float):\n        # update all atoms\n        for site in self.structure:\n            label = site.label\n            actor = self.plotter.actors[f\"{label}\"]\n            actor.prop.metallic = atom_metallicness\n        self._atom_metallicness = atom_metallicness\n\n    @property\n    def background(self) -&gt; str:\n        \"\"\"\n\n        Returns\n        -------\n        str\n            The color of the plot background as a hex code.\n\n        \"\"\"\n        return self._background\n\n    @background.setter\n    def background(self, background: str):\n        self.plotter.set_background(background)\n        self._background = background\n\n    @property\n    def show_axes(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            Whether or not to show the axis widget. Note this currently only\n            displays the cartesian axes.\n\n        \"\"\"\n        return self._show_axes\n\n    @show_axes.setter\n    def show_axes(self, show_axes: bool):\n        if show_axes:\n            self.plotter.add_axes()\n        else:\n            self.plotter.hide_axes()\n        self._show_axes = show_axes\n\n    @property\n    def parallel_projection(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            If True, a parallel projection scheme will be used rather than\n            perspective.\n\n        \"\"\"\n        return self._parallel_projection\n\n    @parallel_projection.setter\n    def parallel_projection(self, parallel_projection: bool):\n        if parallel_projection:\n            self.plotter.renderer.enable_parallel_projection()\n        else:\n            self.plotter.renderer.disable_parallel_projection()\n        self._parallel_projection = parallel_projection\n\n    @property\n    def radii(self) -&gt; list[float]:\n        \"\"\"\n\n        Returns\n        -------\n        list[float]\n            The radius to display for each atom in the structure. The actual\n            displayed radius will be 0.3*radius.\n\n        \"\"\"\n        return self._radii\n\n    @radii.setter\n    def radii(self, radii: list[float]):\n        # fix radii to be a list and make any negative values == 0.01\n        radii = list(radii)\n        for i, val in enumerate(radii):\n            if val &lt;= 0:\n                radii[i] = 0.01\n        # check which radii have changed and replace these atoms\n        old_radii = self.radii\n        # update radii\n        self._radii = radii\n        # for each site, check if the radius has changed and if it has remove it\n        # then remake\n        for i, (site, old_r, new_r, color) in enumerate(\n            zip(self.structure, old_radii, radii, self.colors)\n        ):\n            if old_r == new_r:\n                continue\n            # otherwise remove the actor, regenerate, and replot\n            self.plotter.remove_actor(f\"{site.label}\")\n            atom_mesh = self.get_site_mesh(i)\n            self.plotter.add_mesh(\n                atom_mesh,\n                color=color,\n                metallic=self.atom_metallicness,\n                pbr=True,  # enable physical based rendering\n                name=f\"{site.label}\",\n            )\n\n    @property\n    def colors(self) -&gt; list[str]:\n        \"\"\"\n\n        Returns\n        -------\n        list[str]\n            The colors to use for each atom as hex codes.\n\n        \"\"\"\n        return self._colors\n\n    @colors.setter\n    def colors(self, colors: list[str]):\n        # for each site, check if the radius has changed and if it has remove it\n        # then remake\n        for site, old_color, new_color in zip(self.structure, self.colors, colors):\n            if old_color == new_color:\n                continue\n            actor = self.plotter.actors[f\"{site.label}\"]\n            actor.prop.color = new_color\n        self._colors = colors\n\n    @property\n    def atom_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n\n        Returns\n        -------\n        atom_df : TYPE\n            A dataframe summarizing the properties of the atom meshes.\n\n        \"\"\"\n        # construct a pandas dataframe for each atom\n        visible = []\n        for i in range(len(self.structure)):\n            if i in self.visible_atoms:\n                visible.append(True)\n            else:\n                visible.append(False)\n        atom_df = pd.DataFrame(\n            {\n                \"Label\": self.structure.labels,\n                \"Visible\": visible,\n                \"Color\": self.colors,\n                \"Radius\": self.radii,\n            }\n        )\n        return atom_df\n\n    @atom_df.setter\n    def atom_df(self, atom_df: pd.DataFrame):\n        visible = atom_df[\"Visible\"]\n        visible_atoms = []\n        for i, val in enumerate(visible):\n            if val == True:\n                visible_atoms.append(i)\n        # set each property from the dataframe\n        self.visible_atoms = visible_atoms\n        self.colors = atom_df[\"Color\"]\n        self.radii = atom_df[\"Radius\"]\n\n    @property\n    def view_indices(self) -&gt; NDArray[int]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[int]\n            The miller indices of the plane that the camera is perpendicular to.\n\n        \"\"\"\n        return self._view_indices\n\n    @view_indices.setter\n    def view_indices(self, view_indices: NDArray[int]):\n        assert len(view_indices) == 3 and all(\n            type(i) == int for i in view_indices\n        ), \"View indices must be an array or list of miller indices\"\n        h, k, l = view_indices\n        camera_position = self.get_camera_position_from_miller(\n            h, k, l, self.camera_rotation\n        )\n        self.camera_position = camera_position\n        # reset the camera zoom so that it fits the screen\n        self.plotter.reset_camera()\n        self._view_indices = view_indices\n\n    @property\n    def camera_rotation(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The rotation of the camera from the default. The default is to set\n            the camera so that the upwards view is as close to the z axis as\n            possible, or the y axis if the view indices are perpendicular to z.\n\n        \"\"\"\n        return self._camera_rotation\n\n    @camera_rotation.setter\n    def camera_rotation(self, camera_rotation: float):\n        h, k, l = self.view_indices\n        camera_position = self.get_camera_position_from_miller(h, k, l, camera_rotation)\n        self.camera_position = camera_position\n        # reset the camera zoom so that it fits the screen\n        self.plotter.reset_camera()\n        self._camera_rotation = camera_rotation\n\n    @property\n    def camera_position(self) -&gt; list[tuple, tuple, tuple]:\n        \"\"\"\n\n        Returns\n        -------\n        list[tuple, tuple, tuple]\n            The set of tuples defining the camera position. In order, this is\n            the camera's position, the focal point, and the view up vector.\n\n        \"\"\"\n        pos = self.plotter.camera_position\n        # convert to list for serializability\n        return [list(pos[0]), list(pos[1]), list(pos[2])]\n\n    @camera_position.setter\n    def camera_position(self, camera_position: NDArray):\n        camera_position = np.array(camera_position).astype(float)\n        if camera_position.ndim == 1:\n            h, k, l = camera_position\n            camera_pos = self.get_camera_position_from_miller(h, k, l)\n            self.plotter.camera_position = camera_pos\n        else:\n            # convert to tuples\n            camera_position = [\n                tuple(camera_position[0]),\n                tuple(camera_position[1]),\n                tuple(camera_position[2]),\n            ]\n            self.plotter.camera_position = camera_position\n\n    @staticmethod\n    def get_edge_atom_fracs(frac_coord: NDArray, tol: float = 1e-08) -&gt; NDArray:\n        \"\"\"\n        Generates translationally equivalent atoms if coords are exactly on an edge\n        of the lattice\n\n        Parameters\n        ----------\n        frac_coord : NDArray\n            The fractiona coordinates of a single atom to wrap.\n        tol : float, optional\n            The tolerance in fractional coords to consider an atom on an edge\n            of the unit cell. The default is 1e-08.\n\n        Returns\n        -------\n        NDArray\n            The fractional coordinates of the atom wrapped at edges.\n\n        \"\"\"\n        transforms = [\n            [0, 1] if abs(x) &lt; tol else [0, -1] if abs(x - 1) &lt; tol else [0]\n            for x in frac_coord\n        ]\n\n        shifts = set(product(*transforms))\n        return [np.array(frac_coord) + np.array(shift) for shift in shifts]\n\n    def get_camera_position_from_miller(\n        self,\n        h: int,\n        k: int,\n        l: int,\n        rotation: float = 0,\n    ) -&gt; list[tuple, tuple, tuple]:\n        \"\"\"\n        Creates a camera position list from a list of miller indices.\n\n        Parameters\n        ----------\n        h : int\n            First miller index.\n        k : int\n            Second miller index.\n        l : int\n            Third miller index.\n        rotation: float\n            The rotation in degrees of the camera. The default of 0 will arrange\n            the camera as close to Z=1 as possible, or in the case that it this\n            is parallel, it will default to close to Y=1.\n\n        Returns\n        -------\n        list[tuple, tuple, tuple]\n            The set of tuples defining the camera position. In order, this is\n            the camera's position, the focal point, and the view up vector.\n\n        \"\"\"\n        # check for all 0s and adjust\n        if all([x == 0 for x in [h, k, l]]):\n            h, k, l = 1, 0, 0\n        # convert to vector perpendicular to the miller plane\n        view_direction = self.structure.get_cart_from_miller(h, k, l)\n        # Calculate a distance to the camera that doesn't clip any bodies. It's\n        # fine if this is very large as methods using this function should reset\n        # the camera after. We use half the sum of all lattice sides plus the largest\n        # atom radius as this should always be well outside the camera's range\n        camera_distance = sum(self.structure.lattice.lengths) + max(self.radii)\n\n        # Set focal point as center of lattice\n        matrix = self.structure.lattice.matrix\n        far_corner = np.sum(matrix, axis=0)\n        focal_point = far_corner / 2\n        # set the cameras position by adding the view direction to the focal point.\n        # The position is scaled by multiplying by the desired distance\n        camera_position = focal_point + view_direction * camera_distance\n\n        # Find an orthogonal vector that has the maximum z value. This is done\n        # using Gram-Schmidt orthogonalization.\n        z_axis = np.array([0, 0, 1])\n        view_up = z_axis - np.dot(z_axis, view_direction) * view_direction\n        norm_proj_z = np.linalg.norm(view_up)\n        if norm_proj_z &lt; 1e-14:\n            # fallback to y-axis if view direction is exactly perpendicular to\n            # the z direction\n            y_axis = np.array([0, 1, 0])\n            view_up = y_axis - np.dot(y_axis, view_direction) * view_direction\n\n        # Now we rotate the camera. We intentionally rotate counter clockwise to\n        # make the structure appear to rotate clockwise.\n        # convert degrees to radians\n        angle_rad = np.deg2rad(rotation)\n        view_up_rot = view_up * np.cos(angle_rad) + np.cross(\n            view_direction, view_up\n        ) * np.sin(angle_rad)\n        # return camera position\n        return [\n            tuple(camera_position),  # where the camera is\n            tuple(focal_point),  # where it's looking\n            tuple(view_up_rot),  # which direction is up\n        ]\n\n    def get_site_mesh(self, site_idx: int) -&gt; pv.PolyData:\n        \"\"\"\n        Generates a mesh for the provided site index.\n\n        Parameters\n        ----------\n        site_idx : int\n            The index of the atom to create the mesh for.\n\n        Returns\n        -------\n        pv.PolyData\n            A pyvista mesh representing an atom.\n\n        \"\"\"\n        site = self.structure[site_idx]\n        radius = self.radii[site_idx]\n        frac_coords = site.frac_coords\n        # wrap atom if on edge\n        if self._wrap_atoms:\n            all_frac_coords = self.get_edge_atom_fracs(frac_coords)\n        else:\n            all_frac_coords = [frac_coords]\n        # convert to cart coords\n        cart_coords = all_frac_coords @ self.structure.lattice.matrix\n        # generate meshes for each atom\n        spheres = []\n        for cart_coord in cart_coords:\n            spheres.append(\n                pv.Sphere(\n                    radius=radius * 0.3,\n                    center=cart_coord,\n                    theta_resolution=30,\n                    phi_resolution=30,\n                )\n            )\n        # merge all meshes\n        return pv.merge(spheres)\n\n    def get_all_site_meshes(self) -&gt; list[pv.PolyData]:\n        \"\"\"\n        Gets a list of pyvista meshes representing the atoms in the structure\n\n        Returns\n        -------\n        meshes : pv.PolyData\n            A list of pyvista meshes representing each atom.\n\n        \"\"\"\n        meshes = [self.get_site_mesh(i) for i in range(len(self.structure))]\n        return meshes\n\n    def get_lattice_mesh(self) -&gt; pv.PolyData:\n        \"\"\"\n        Generates the mesh representing the outline of the unit cell.\n\n        Returns\n        -------\n        pv.PolyData\n            A pyvista mesh representing the outline of the unit cell.\n\n        \"\"\"\n        # get the lattice matrix\n        a, b, c = self.structure.lattice.matrix\n        # get the corners of the matrix\n        corners = [np.array([0, 0, 0]), a, b, c, a + b, a + c, b + c, a + b + c]\n        # get the indices indicating edges of the lattice\n        edges = [\n            (0, 1),\n            (0, 2),\n            (0, 3),\n            (1, 4),\n            (1, 5),\n            (2, 4),\n            (2, 6),\n            (3, 5),\n            (3, 6),\n            (4, 7),\n            (5, 7),\n            (6, 7),\n        ]\n        # generate lines with pv\n        lines = []\n        for i, j in edges:\n            line = pv.Line(corners[i], corners[j])\n            lines.append(line)\n        # combine and return\n        return pv.merge(lines)\n\n    def _create_structure_plot(self) -&gt; pv.Plotter:\n        \"\"\"\n        Generates a pyvista.Plotter object from the current class variables.\n        This is called when the class is first instanced and generally shouldn't\n        be called again.\n\n        Returns\n        -------\n        plotter : pv.Plotter\n            A pyvista Plotter object representing the provided Structure object.\n\n        \"\"\"\n        if self.qt_plotter:\n            assert self.qt_frame is not None, \"A frame must be set to use qt\"\n            plotter = QtInteractor(self.qt_frame)\n        else:\n            plotter = pv.Plotter(off_screen=self.off_screen)\n        # set background\n        plotter.set_background(self.background)\n        # add atoms\n        atom_meshes = self.get_all_site_meshes()\n        for i, (site, atom_mesh, color) in enumerate(\n            zip(self.structure, atom_meshes, self.colors)\n        ):\n            actor = plotter.add_mesh(\n                atom_mesh,\n                color=color,\n                metallic=self.atom_metallicness,\n                pbr=True,  # enable physical based rendering\n                name=f\"{site.label}\",\n            )\n            if not i in self.visible_atoms:\n                actor.visibility = False\n\n        # add lattice if desired\n        lattice_mesh = self.get_lattice_mesh()\n        plotter.add_mesh(\n            lattice_mesh,\n            line_width=self.lattice_thickness,\n            color=\"k\",\n            name=\"lattice\",\n        )\n\n        # set camera perspective type\n        if self.parallel_projection:\n            plotter.renderer.enable_parallel_projection()\n\n        # reset camera to fit well\n        plotter.reset_camera()\n\n        return plotter\n\n    def show(self):\n        \"\"\"\n        Renders the plot to a window. After closing the window, a new instance\n        must be created to plot again. Pressing q pauses the rendering allowing\n        changes to be made without fully exiting.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        self.plotter.show(auto_close=False)\n\n    def update(self):\n        \"\"\"\n        Updates the pyvista plotter object when linked with a render window in\n        Trame. Generally this is not needed outside of Trame applications.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        self.plotter.update()\n\n    def rebuild(self) -&gt; pv.Plotter:\n        \"\"\"\n        Builds a new pyvista plotter object representing the current state of\n        the Plotter class.\n\n        Returns\n        -------\n        pv.Plotter\n            A pyvista Plotter object representing the current state of the\n            StructurePlotter class.\n\n        \"\"\"\n        return self._create_structure_plot()\n\n    def get_plot_html(self) -&gt; str:\n        \"\"\"\n        Creates an html string representing the current state of the StructurePlotter\n        class.\n\n        Returns\n        -------\n        str\n            The html string representing the current StructurePlotter class.\n\n        \"\"\"\n        if sys.platform == \"win32\":\n            # We can return the html directly without opening a subprocess. And\n            # we need to because the \"fork\" start method doesn't work\n            html_plotter = self.plotter.export_html(filename=None)\n            return html_plotter.read()\n        # BUG-FIX: On Linux and maybe MacOS, pyvista's export_html must be run\n        # as a main process. To do this within our streamlit apps, we use python's\n        # multiprocess to run the process as is done in [stpyvista](https://github.com/edsaac/stpyvista/blob/main/src/stpyvista/trame_backend.py)\n        queue = Queue(maxsize=1)\n        process = Process(target=_export_html, args=(queue, self.plotter))\n        process.start()\n        html_plotter = queue.get().read()\n        process.join()\n        return html_plotter\n\n    def get_plot_screenshot(\n        self,\n        filename: str | Path | io.BytesIO = None,\n        transparent_background: bool = None,\n        return_img: bool = True,\n        window_size: tuple[int, int] = None,\n        scale: int = None,\n    ) -&gt; NDArray[float]:\n        \"\"\"\n        Creates a screenshot of the current state of the StructurePlotter class.\n        This is a wraparound of pyvista's screenshot method\n\n        Parameters\n        ----------\n        filename: str | Path | io.BytesIO\n            Location to write image to. If None, no image is written.\n\n        transparent_background: bool\n            Whether to make the background transparent.\n            The default is looked up on the plotter\u2019s theme.\n\n        return_img: bool\n            If True, a numpy.ndarray of the image will be returned. Defaults to\n            True.\n\n        window_size: tuple[int, int]\n            Set the plotter\u2019s size to this (width, height) before taking the\n            screenshot.\n\n        scale: int\n            Set the factor to scale the window size to make a higher resolution image. If None this will use the image_scale property on this plotter which defaults to one.\n\n        Returns\n        -------\n        NDArray[float]\n            Array containing pixel RGB and alpha. Sized:\n\n            [Window height x Window width x 3] if transparent_background is set to False.\n\n            [Window height x Window width x 4] if transparent_background is set to True.\n\n        \"\"\"\n\n        if not self.qt_plotter:\n            plotter = self.rebuild()\n            plotter.camera = self.plotter.camera.copy()\n        else:\n            plotter = self.plotter\n\n        # enable off screen rendering momentarily\n        plotter.ren_win.SetOffScreenRendering(True)\n        screenshot = plotter.screenshot(\n            filename=filename,\n            transparent_background=transparent_background,\n            return_img=return_img,\n            window_size=window_size,\n            scale=scale,\n        )\n        plotter.ren_win.SetOffScreenRendering(False)\n        if not self.qt_plotter:\n            plotter.close()\n        return screenshot\n\n    def _set_camera_tight(self, camera, padding=0.0, adjust_render_window=True):\n        \"\"\"\n        Adjust the camera parallel_scale to fit the actors tightly,\n        without changing the camera position, focal point, or view direction.\n        \"\"\"\n        ren = camera._renderer\n        x0, x1, y0, y1, z0, z1 = ren.bounds\n\n        # Compute aspect ratio\n        ren.ComputeAspect()\n        aspect = ren.GetAspect()\n\n        # Bounding box size\n        bbox_size = np.array([x1 - x0, y1 - y0, z1 - z0])\n\n        # Use current camera view up and direction\n        viewup = np.array(camera.GetViewUp())\n        direction = np.array(camera.GetFocalPoint()) - np.array(camera.GetPosition())\n        direction /= np.linalg.norm(direction)\n        horizontal = np.cross(direction, viewup)\n\n        # Project bounding box onto camera plane axes\n        vert_dist = abs(bbox_size @ viewup)\n        horiz_dist = abs(bbox_size @ horizontal)\n\n        # Set parallel scale\n        ps = max(horiz_dist / aspect[0], vert_dist) / 2\n        camera.parallel_scale = ps * (1 + padding)\n\n        # Reset clipping planes\n        camera._renderer.ResetCameraClippingRange(x0, x1, y0, y1, z0, z1)\n\n        if adjust_render_window:\n            ren_win = ren.GetRenderWindow()\n            size = list(ren_win.GetSize())\n            size_ratio = size[0] / size[1]\n            tight_ratio = horiz_dist / vert_dist\n            resize_ratio = tight_ratio / size_ratio\n            if resize_ratio &lt; 1:\n                size[0] = round(size[0] * resize_ratio)\n            else:\n                size[1] = round(size[1] / resize_ratio)\n            ren_win.SetSize(size)\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.atom_df","title":"<code>atom_df</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Name Type Description <code>atom_df</code> <code>TYPE</code> <p>A dataframe summarizing the properties of the atom meshes.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.atom_metallicness","title":"<code>atom_metallicness</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The amount of metallic character in the atom display.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.background","title":"<code>background</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The color of the plot background as a hex code.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.camera_position","title":"<code>camera_position</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>list[tuple, tuple, tuple]</code> <p>The set of tuples defining the camera position. In order, this is the camera's position, the focal point, and the view up vector.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.camera_rotation","title":"<code>camera_rotation</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The rotation of the camera from the default. The default is to set the camera so that the upwards view is as close to the z axis as possible, or the y axis if the view indices are perpendicular to z.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.colors","title":"<code>colors</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>list[str]</code> <p>The colors to use for each atom as hex codes.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.lattice_thickness","title":"<code>lattice_thickness</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The thickness of the lines outlining the unit cell.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.parallel_projection","title":"<code>parallel_projection</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>If True, a parallel projection scheme will be used rather than perspective.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.radii","title":"<code>radii</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>list[float]</code> <p>The radius to display for each atom in the structure. The actual displayed radius will be 0.3*radius.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.show_axes","title":"<code>show_axes</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to show the axis widget. Note this currently only displays the cartesian axes.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.show_lattice","title":"<code>show_lattice</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to display the outline of the unit cell.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.view_indices","title":"<code>view_indices</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>NDArray[int]</code> <p>The miller indices of the plane that the camera is perpendicular to.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.visible_atoms","title":"<code>visible_atoms</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>list[int]</code> <p>A list of atom indices to display in the plot.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.__init__","title":"<code>__init__(structure, off_screen=False, qt_plotter=False, qt_frame=None, **kwargs)</code>","text":"<p>A convenience class for creating plots of crystal structures using pyvista's package for VTK.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>The pymatgen Structure object to plot.</p> required <code>off_screen</code> <code>bool</code> <p>Whether or not the plotter should be in offline mode. The default is False.</p> <code>False</code> <code>qt_plotter</code> <code>bool</code> <p>Whether or not the plotter will use pyvistaqt for qt applications</p> <code>False</code> <code>qt_frame</code> <p>If using pyvistaqt, the QFrame to link the plotter to.</p> <code>None</code> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def __init__(\n    self,\n    structure: Structure,\n    off_screen: bool = False,\n    qt_plotter: bool = False,\n    qt_frame=None,\n    **kwargs,\n):\n    \"\"\"\n    A convenience class for creating plots of crystal structures using\n    pyvista's package for VTK.\n\n    Parameters\n    ----------\n    structure : Structure\n        The pymatgen Structure object to plot.\n    off_screen : bool, optional\n        Whether or not the plotter should be in offline mode. The default is False.\n    qt_plotter : bool, optional\n        Whether or not the plotter will use pyvistaqt for qt applications\n    qt_frame\n        If using pyvistaqt, the QFrame to link the plotter to.\n\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # sort and relabel structure for consistency\n    structure = structure.copy()\n    structure.sort()\n    structure.relabel_sites()\n    # create initial class variables\n    self.structure = structure\n    self.off_screen = off_screen\n    self.qt_plotter = qt_plotter\n    self.qt_frame = qt_frame\n    self._visible_atoms = [i for i in range(len(self.structure))]\n    self._show_lattice = True\n    self._wrap_atoms = True\n    self._lattice_thickness = 0.1\n    self._atom_metallicness = 0.0\n    self._background = \"#FFFFFF\"\n    self._view_indices = [1, 0, 0]\n    self._camera_rotation = (0.0,)\n    self._show_axes = True\n    self._parallel_projection = True\n    self._radii = [s.specie.atomic_radius for s in structure]\n    self._colors = [ATOM_COLORS.get(s.specie.symbol, \"#FFFFFF\") for s in structure]\n    # generate initial plotter\n    self.plotter = self._create_structure_plot()\n    self.view_indices = [1, 0, 0]\n    self.up_indices = [0, 0, 1]\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_all_site_meshes","title":"<code>get_all_site_meshes()</code>","text":"<p>Gets a list of pyvista meshes representing the atoms in the structure</p> <p>Returns:</p> Name Type Description <code>meshes</code> <code>PolyData</code> <p>A list of pyvista meshes representing each atom.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_all_site_meshes(self) -&gt; list[pv.PolyData]:\n    \"\"\"\n    Gets a list of pyvista meshes representing the atoms in the structure\n\n    Returns\n    -------\n    meshes : pv.PolyData\n        A list of pyvista meshes representing each atom.\n\n    \"\"\"\n    meshes = [self.get_site_mesh(i) for i in range(len(self.structure))]\n    return meshes\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_camera_position_from_miller","title":"<code>get_camera_position_from_miller(h, k, l, rotation=0)</code>","text":"<p>Creates a camera position list from a list of miller indices.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>int</code> <p>First miller index.</p> required <code>k</code> <code>int</code> <p>Second miller index.</p> required <code>l</code> <code>int</code> <p>Third miller index.</p> required <code>rotation</code> <code>float</code> <p>The rotation in degrees of the camera. The default of 0 will arrange the camera as close to Z=1 as possible, or in the case that it this is parallel, it will default to close to Y=1.</p> <code>0</code> <p>Returns:</p> Type Description <code>list[tuple, tuple, tuple]</code> <p>The set of tuples defining the camera position. In order, this is the camera's position, the focal point, and the view up vector.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_camera_position_from_miller(\n    self,\n    h: int,\n    k: int,\n    l: int,\n    rotation: float = 0,\n) -&gt; list[tuple, tuple, tuple]:\n    \"\"\"\n    Creates a camera position list from a list of miller indices.\n\n    Parameters\n    ----------\n    h : int\n        First miller index.\n    k : int\n        Second miller index.\n    l : int\n        Third miller index.\n    rotation: float\n        The rotation in degrees of the camera. The default of 0 will arrange\n        the camera as close to Z=1 as possible, or in the case that it this\n        is parallel, it will default to close to Y=1.\n\n    Returns\n    -------\n    list[tuple, tuple, tuple]\n        The set of tuples defining the camera position. In order, this is\n        the camera's position, the focal point, and the view up vector.\n\n    \"\"\"\n    # check for all 0s and adjust\n    if all([x == 0 for x in [h, k, l]]):\n        h, k, l = 1, 0, 0\n    # convert to vector perpendicular to the miller plane\n    view_direction = self.structure.get_cart_from_miller(h, k, l)\n    # Calculate a distance to the camera that doesn't clip any bodies. It's\n    # fine if this is very large as methods using this function should reset\n    # the camera after. We use half the sum of all lattice sides plus the largest\n    # atom radius as this should always be well outside the camera's range\n    camera_distance = sum(self.structure.lattice.lengths) + max(self.radii)\n\n    # Set focal point as center of lattice\n    matrix = self.structure.lattice.matrix\n    far_corner = np.sum(matrix, axis=0)\n    focal_point = far_corner / 2\n    # set the cameras position by adding the view direction to the focal point.\n    # The position is scaled by multiplying by the desired distance\n    camera_position = focal_point + view_direction * camera_distance\n\n    # Find an orthogonal vector that has the maximum z value. This is done\n    # using Gram-Schmidt orthogonalization.\n    z_axis = np.array([0, 0, 1])\n    view_up = z_axis - np.dot(z_axis, view_direction) * view_direction\n    norm_proj_z = np.linalg.norm(view_up)\n    if norm_proj_z &lt; 1e-14:\n        # fallback to y-axis if view direction is exactly perpendicular to\n        # the z direction\n        y_axis = np.array([0, 1, 0])\n        view_up = y_axis - np.dot(y_axis, view_direction) * view_direction\n\n    # Now we rotate the camera. We intentionally rotate counter clockwise to\n    # make the structure appear to rotate clockwise.\n    # convert degrees to radians\n    angle_rad = np.deg2rad(rotation)\n    view_up_rot = view_up * np.cos(angle_rad) + np.cross(\n        view_direction, view_up\n    ) * np.sin(angle_rad)\n    # return camera position\n    return [\n        tuple(camera_position),  # where the camera is\n        tuple(focal_point),  # where it's looking\n        tuple(view_up_rot),  # which direction is up\n    ]\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_edge_atom_fracs","title":"<code>get_edge_atom_fracs(frac_coord, tol=1e-08)</code>  <code>staticmethod</code>","text":"<p>Generates translationally equivalent atoms if coords are exactly on an edge of the lattice</p> <p>Parameters:</p> Name Type Description Default <code>frac_coord</code> <code>NDArray</code> <p>The fractiona coordinates of a single atom to wrap.</p> required <code>tol</code> <code>float</code> <p>The tolerance in fractional coords to consider an atom on an edge of the unit cell. The default is 1e-08.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>The fractional coordinates of the atom wrapped at edges.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>@staticmethod\ndef get_edge_atom_fracs(frac_coord: NDArray, tol: float = 1e-08) -&gt; NDArray:\n    \"\"\"\n    Generates translationally equivalent atoms if coords are exactly on an edge\n    of the lattice\n\n    Parameters\n    ----------\n    frac_coord : NDArray\n        The fractiona coordinates of a single atom to wrap.\n    tol : float, optional\n        The tolerance in fractional coords to consider an atom on an edge\n        of the unit cell. The default is 1e-08.\n\n    Returns\n    -------\n    NDArray\n        The fractional coordinates of the atom wrapped at edges.\n\n    \"\"\"\n    transforms = [\n        [0, 1] if abs(x) &lt; tol else [0, -1] if abs(x - 1) &lt; tol else [0]\n        for x in frac_coord\n    ]\n\n    shifts = set(product(*transforms))\n    return [np.array(frac_coord) + np.array(shift) for shift in shifts]\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_lattice_mesh","title":"<code>get_lattice_mesh()</code>","text":"<p>Generates the mesh representing the outline of the unit cell.</p> <p>Returns:</p> Type Description <code>PolyData</code> <p>A pyvista mesh representing the outline of the unit cell.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_lattice_mesh(self) -&gt; pv.PolyData:\n    \"\"\"\n    Generates the mesh representing the outline of the unit cell.\n\n    Returns\n    -------\n    pv.PolyData\n        A pyvista mesh representing the outline of the unit cell.\n\n    \"\"\"\n    # get the lattice matrix\n    a, b, c = self.structure.lattice.matrix\n    # get the corners of the matrix\n    corners = [np.array([0, 0, 0]), a, b, c, a + b, a + c, b + c, a + b + c]\n    # get the indices indicating edges of the lattice\n    edges = [\n        (0, 1),\n        (0, 2),\n        (0, 3),\n        (1, 4),\n        (1, 5),\n        (2, 4),\n        (2, 6),\n        (3, 5),\n        (3, 6),\n        (4, 7),\n        (5, 7),\n        (6, 7),\n    ]\n    # generate lines with pv\n    lines = []\n    for i, j in edges:\n        line = pv.Line(corners[i], corners[j])\n        lines.append(line)\n    # combine and return\n    return pv.merge(lines)\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_plot_html","title":"<code>get_plot_html()</code>","text":"<p>Creates an html string representing the current state of the StructurePlotter class.</p> <p>Returns:</p> Type Description <code>str</code> <p>The html string representing the current StructurePlotter class.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_plot_html(self) -&gt; str:\n    \"\"\"\n    Creates an html string representing the current state of the StructurePlotter\n    class.\n\n    Returns\n    -------\n    str\n        The html string representing the current StructurePlotter class.\n\n    \"\"\"\n    if sys.platform == \"win32\":\n        # We can return the html directly without opening a subprocess. And\n        # we need to because the \"fork\" start method doesn't work\n        html_plotter = self.plotter.export_html(filename=None)\n        return html_plotter.read()\n    # BUG-FIX: On Linux and maybe MacOS, pyvista's export_html must be run\n    # as a main process. To do this within our streamlit apps, we use python's\n    # multiprocess to run the process as is done in [stpyvista](https://github.com/edsaac/stpyvista/blob/main/src/stpyvista/trame_backend.py)\n    queue = Queue(maxsize=1)\n    process = Process(target=_export_html, args=(queue, self.plotter))\n    process.start()\n    html_plotter = queue.get().read()\n    process.join()\n    return html_plotter\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_plot_screenshot","title":"<code>get_plot_screenshot(filename=None, transparent_background=None, return_img=True, window_size=None, scale=None)</code>","text":"<p>Creates a screenshot of the current state of the StructurePlotter class. This is a wraparound of pyvista's screenshot method</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | Path | BytesIO</code> <p>Location to write image to. If None, no image is written.</p> <code>None</code> <code>transparent_background</code> <code>bool</code> <p>Whether to make the background transparent. The default is looked up on the plotter\u2019s theme.</p> <code>None</code> <code>return_img</code> <code>bool</code> <p>If True, a numpy.ndarray of the image will be returned. Defaults to True.</p> <code>True</code> <code>window_size</code> <code>tuple[int, int]</code> <p>Set the plotter\u2019s size to this (width, height) before taking the screenshot.</p> <code>None</code> <code>scale</code> <code>int</code> <p>Set the factor to scale the window size to make a higher resolution image. If None this will use the image_scale property on this plotter which defaults to one.</p> <code>None</code> <p>Returns:</p> Type Description <code>NDArray[float]</code> <p>Array containing pixel RGB and alpha. Sized:</p> <p>[Window height x Window width x 3] if transparent_background is set to False.</p> <p>[Window height x Window width x 4] if transparent_background is set to True.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_plot_screenshot(\n    self,\n    filename: str | Path | io.BytesIO = None,\n    transparent_background: bool = None,\n    return_img: bool = True,\n    window_size: tuple[int, int] = None,\n    scale: int = None,\n) -&gt; NDArray[float]:\n    \"\"\"\n    Creates a screenshot of the current state of the StructurePlotter class.\n    This is a wraparound of pyvista's screenshot method\n\n    Parameters\n    ----------\n    filename: str | Path | io.BytesIO\n        Location to write image to. If None, no image is written.\n\n    transparent_background: bool\n        Whether to make the background transparent.\n        The default is looked up on the plotter\u2019s theme.\n\n    return_img: bool\n        If True, a numpy.ndarray of the image will be returned. Defaults to\n        True.\n\n    window_size: tuple[int, int]\n        Set the plotter\u2019s size to this (width, height) before taking the\n        screenshot.\n\n    scale: int\n        Set the factor to scale the window size to make a higher resolution image. If None this will use the image_scale property on this plotter which defaults to one.\n\n    Returns\n    -------\n    NDArray[float]\n        Array containing pixel RGB and alpha. Sized:\n\n        [Window height x Window width x 3] if transparent_background is set to False.\n\n        [Window height x Window width x 4] if transparent_background is set to True.\n\n    \"\"\"\n\n    if not self.qt_plotter:\n        plotter = self.rebuild()\n        plotter.camera = self.plotter.camera.copy()\n    else:\n        plotter = self.plotter\n\n    # enable off screen rendering momentarily\n    plotter.ren_win.SetOffScreenRendering(True)\n    screenshot = plotter.screenshot(\n        filename=filename,\n        transparent_background=transparent_background,\n        return_img=return_img,\n        window_size=window_size,\n        scale=scale,\n    )\n    plotter.ren_win.SetOffScreenRendering(False)\n    if not self.qt_plotter:\n        plotter.close()\n    return screenshot\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_site_mesh","title":"<code>get_site_mesh(site_idx)</code>","text":"<p>Generates a mesh for the provided site index.</p> <p>Parameters:</p> Name Type Description Default <code>site_idx</code> <code>int</code> <p>The index of the atom to create the mesh for.</p> required <p>Returns:</p> Type Description <code>PolyData</code> <p>A pyvista mesh representing an atom.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_site_mesh(self, site_idx: int) -&gt; pv.PolyData:\n    \"\"\"\n    Generates a mesh for the provided site index.\n\n    Parameters\n    ----------\n    site_idx : int\n        The index of the atom to create the mesh for.\n\n    Returns\n    -------\n    pv.PolyData\n        A pyvista mesh representing an atom.\n\n    \"\"\"\n    site = self.structure[site_idx]\n    radius = self.radii[site_idx]\n    frac_coords = site.frac_coords\n    # wrap atom if on edge\n    if self._wrap_atoms:\n        all_frac_coords = self.get_edge_atom_fracs(frac_coords)\n    else:\n        all_frac_coords = [frac_coords]\n    # convert to cart coords\n    cart_coords = all_frac_coords @ self.structure.lattice.matrix\n    # generate meshes for each atom\n    spheres = []\n    for cart_coord in cart_coords:\n        spheres.append(\n            pv.Sphere(\n                radius=radius * 0.3,\n                center=cart_coord,\n                theta_resolution=30,\n                phi_resolution=30,\n            )\n        )\n    # merge all meshes\n    return pv.merge(spheres)\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.rebuild","title":"<code>rebuild()</code>","text":"<p>Builds a new pyvista plotter object representing the current state of the Plotter class.</p> <p>Returns:</p> Type Description <code>Plotter</code> <p>A pyvista Plotter object representing the current state of the StructurePlotter class.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def rebuild(self) -&gt; pv.Plotter:\n    \"\"\"\n    Builds a new pyvista plotter object representing the current state of\n    the Plotter class.\n\n    Returns\n    -------\n    pv.Plotter\n        A pyvista Plotter object representing the current state of the\n        StructurePlotter class.\n\n    \"\"\"\n    return self._create_structure_plot()\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.show","title":"<code>show()</code>","text":"<p>Renders the plot to a window. After closing the window, a new instance must be created to plot again. Pressing q pauses the rendering allowing changes to be made without fully exiting.</p> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def show(self):\n    \"\"\"\n    Renders the plot to a window. After closing the window, a new instance\n    must be created to plot again. Pressing q pauses the rendering allowing\n    changes to be made without fully exiting.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    self.plotter.show(auto_close=False)\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.update","title":"<code>update()</code>","text":"<p>Updates the pyvista plotter object when linked with a render window in Trame. Generally this is not needed outside of Trame applications.</p> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def update(self):\n    \"\"\"\n    Updates the pyvista plotter object when linked with a render window in\n    Trame. Generally this is not needed outside of Trame applications.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    self.plotter.update()\n</code></pre>"},{"location":"badelf/background/","title":"Background","text":"<p>Note</p> <p>This page assumes prior knowledge of Bader's method for quantifying atomic charge and oxidation states as well as the Electron Localization Function. See the Bader and ElfLabeler for more information.</p> <p>In most cases, Bader's analysis of the charge density suffices for examining local charges. Where it fails is when there is interest in the charge of chemical features which do not appear in the charge density. For example, one may be interested in the charge located at a covalent bond as atoms move closer together, or the charge in the bare electrons of electrides. It is these situations where the Electron Localization Function (ELF) is more useful. Unlike the charge density, the ELF typically displays maxima at most chemical features familiar to chemists. This allows each feature to be analyzed independently and can make it easier to visualize interesting bonding interactions.</p> <p></p> <p>Nearly since its conception, the ELF has been used to integrate local charge of atoms and chemical features (see for example, Kohout et. al.). This is typically accomplished using a technique similar to that of Bader. The ELF is first separated into regions called basins which contain a singular local maximum, sometimes termed an attractor. The charge density in the basins can then be integrated to calculate a local charge. Historically, the separation of basins has been done using the same method as Bader, with regions partitioned by zero-flux surfaces. We have also developed two additional methods which make use of voronoi-like planes (see Methods for details). These methods are the original source of the term BadELF, but it can more generally be used to describe any combination of Bader-like charge analysis of the ELF.</p> <p>Warning</p> <p>Our BadELF implementation performs additional analysis to label chemical features in the ELF to help provide a more directly useful interpretation. It is important to note that for a variety of reasons the final chemical features do not always correspond directly with a single basin. For more information, see the ElfLabeler.</p>"},{"location":"badelf/methods/","title":"Methods and Benchmarks","text":"<p>The available BadELF methods differ from the Bader methods in that they refer to different partitioning schemes rather than methods of approximating the smooth zero-flux surface.</p>"},{"location":"badelf/methods/#methods","title":"Methods","text":"zero-flux (default)voronelfbadelf <p>Key Takeaway: Fastest method with some potential interstitial bias.</p> <p>This is the primary method used historically. It is conceptually very similar to Bader's method, dividing the ELF into regions (called basins) separated by a zero-flux surface. The charge density is then integrated to assign charge to each basin. This method essentially wraps the <code>Bader</code> class and retains all of its speed and rigor. </p> <p>There are two potential downsides of this method. The first is that in highly ionic systems, nearly all of the interstitial region is assigned to the atom with a higher ELF value (typically the anion). This leads to near formal charges, and it is difficult to pull out information about any degree of covalency. The second is that chemical features that are shared by multiple atomes (i.e. covalent/metallic bonds) are not rigorously divided, requiring an arbitrary choice of how to split them up.</p> <p>Despite these downsides, we have chosen to use this method as the default as it scales significantly better than the alternative methods and has been prefered in the historical literature.</p> <p>Key Takeaway: Tries to alleviate issues in the zero-flux method. Works well for systems with entirely concave basins</p> <p>This method is designed to alleviate the issues described in the zero-flux method. Rather than relying on a full zero-flux surface, planes are placed perpendicular to the vector between each atom and its neighbors. The placement of the planes depends on the type of interaction. For ionic bonds, the plane is placed at the minimum between the atoms which corresponds to a point on the zero-flux surface. For covalent and metallic bonds, a separate basin appears in the ELF between the atoms, and the plane is placed at the maximum along the bond which falls in this region. </p> <p>The use of planes means the interstitial space is more evenly divided between the atoms and allows covalent/metallic features to be separated rigorously. However, this method has several issues of its own. The most important is that it assumes the ELF basin's to be concave. This is usually the case for atoms, but is not true for many other features such as metal bonds and electride electrons. The second is that it scales rather poorly, depending on both the number of grid points and the number of planes that must be constructed. Therefore, we tend to prefer the other methods.</p> <p>Key Takeaways: A hybrid of the zero-flux and voronelf methods. Often best for electride systems.</p> <p>This is the original 'BadELF' method created by the Warren Lab at UNC. It is a hybrid of the other two methods, using a zero-flux surface to separate bare electrons in electrides and planes to separate atoms. For electride systems, this often helps alleviate the issues of the voronelf method. The downsides are that it retains the potential bias of the zero-flux method around electride sites and will still behave poorly for systems where atoms or metallic bonds are not concave and fairly spherical.</p> <p>We recommend this method for most electrides, but suggest a more in-depth analysis for complex systems that may have heavy polarization or mixed metal/electride features.</p>"},{"location":"badelf/usage/","title":"Quick Start","text":""},{"location":"badelf/usage/#introduction","title":"Introduction","text":"<p>The <code>Badelf</code> class uses principles from Bader's Quantum Theory of Atoms in Molecules combined with the Electron Localization Function (ELF) to calculate atomic charges. It is primarily designed for calculating oxidation states in electride systems, which was the motivation for the original work. For more in-depth analysis of the ELF, particularly in systems with non-nuclear chemical features (e.g. covalent bonds, lone-pairs), the ElfLabeler class is likely more appropriate.</p>"},{"location":"badelf/usage/#basic-use","title":"Basic Use","text":"<p>BadELF can be run through the command line interface or through Python script. Currently only VASP's CHGCAR and ELFCAR files are supported.</p> <p>By default, BadELF uses the 'zero-flux' algorithm which separates all ELF basins at zero-flux surfaces, following traditional ELF charge analysis. The original badelf algorithm also incorporates voronoi-like planes and may be more appropriate in some systems.</p> Command LinePythonGUI App <ol> <li> <p>Activate your environment with BaderKit installed. If you are not using an environment manager, skip to step 2.</p> <pre><code>conda activate my_env\n</code></pre> </li> <li> <p>Navigate to the directory with your charge density and ELF files.</p> <pre><code>cd /path/to/directory\n</code></pre> </li> <li> <p>Run the BadELF analysis. Replace 'chargefile' and 'elffile' with the names of your charge-density and ELF files.</p> <pre><code>baderkit badelf chargefile elffile\n</code></pre> </li> </ol> <p>Output files for atoms will be written automatically to a <code>badelf_atom_summary.tsv</code> which includes rows for each atom with columns for:</p> <ul> <li>atom labels/assignments</li> <li>coordinates (fractional) </li> <li>charges (e) </li> <li>volumes (\u00c5<sup>3</sup>)</li> <li>minimum surface distances (\u00c5)</li> </ul> <p>Additional arguments and options such as those for printing output files or using different  algorithms can be viewed by running the help command. <pre><code>baderkit badelf --help\n</code></pre></p> <ol> <li> <p>Import the <code>Badelf</code> class.</p> <pre><code>from baderkit.core import Badelf\n</code></pre> </li> <li> <p>Use the <code>Badelf</code> class' <code>from_vasp</code> method to read a <code>CHGCAR</code> and <code>ELFCAR</code> file.</p> <pre><code># instantiate the class\nbadelf = Badelf.from_vasp(\"path/to/chargefile\", \"path/to/elffile\")\n</code></pre> </li> <li> <p>To run the analysis, we can call any class property. Try getting a complete summary in dictionary format.     ```python     results = badelf.to_json()</p> </li> <li> <p>Now try getting individual properties. For more details on each property, see the API reference.     <pre><code>atom_charges = badelf.atom_charges # Total atom charges\natom_labels = badelf.atom_labels # Atom assignments for each point in the grid\nmaxima_coords = badelf.basin_maxima_frac # Frac coordinates of each attractor\n</code></pre></p> </li> <li> <p>BaderKit also provides convenience methods for writing results to file. First, let's write a summary of the full analysis.</p> <pre><code>badelf.write_json()\n</code></pre> </li> <li> <p>Now let's write the volume assigned to one of our atoms.</p> <pre><code>badelf.write_atom_volumes(atom_indices = [0])\n</code></pre> </li> </ol> <p>Tip</p> <p>After creating a <code>Badelf</code> class object, it doesn't matter what order you call properties, summaries, or write methods in. BaderKit calculates properties/results only when they are needed and caches them.</p> <p>Warning</p> <p>Currently the GUI App only supports Bader analysis.</p>"},{"location":"badelf/usage/#spin-dependent-calculations","title":"Spin-Dependent Calculations","text":"<p>BaderKit provides a convenience class for performing <code>BadELF</code> on the spin-up and spin-down ELF separately. The combined results are also calculated by taking either the average or sum of the respective property.</p> Command LinePython <p>Run the command with the <code>--spin</code> tag.</p> <pre><code>baderkit badelf chargefile elffile --spin\n</code></pre> <p>The results for each spin system are then written to separate files.</p> <ol> <li> <p>Import the <code>SpinBadelf</code> class and read in your spin-dependent files.</p> <pre><code>from baderkit.core import SpinBadelf\n# instantiate the class\nbadelf = SpinBadelf.from_vasp(\"path/to/chargefile\", \"path/to/elffile\")\n</code></pre> </li> <li> <p>Get the separate results for the spin-up and spin-down systems.</p> <pre><code>spin_up = badelf.badelf_up\nspin_down = badelf.badelf_down\n</code></pre> </li> <li> <p>View properties separately or combined.</p> <pre><code>up_charges = spin_up.charges\ndown_charges = spin_down.charges\ntotal_charges = badelf.charges\n</code></pre> </li> </ol>"},{"location":"badelf/usage/#labeling-the-elf","title":"Labeling the ELF","text":"<p>In Bader analysis there are typically maxima only at the center of each atom making it quite easy to assign each basin. In the ELF this becomes much more complicated as a single basin may belong to multiple atoms (e.g. covalent bonds) or even no atoms (e.g. electrides). Because of this, it is necessary to label each basin prior to assigning atomic charges to know how each basin should be split. This process is handled by the ElfLabeler class. Keyword arguments can be fed to the <code>ElfLabeler</code> when running BadELF through python by providing them in dictionary format to the <code>elf_labeler</code> argument.</p>"},{"location":"badelf/usage/#warnings-for-vasp","title":"Warnings for VASP","text":""},{"location":"badelf/usage/#low-valence-pseudopotentials","title":"Low Valence Pseudopotentials","text":"<p>VASP only includes the valence electrons in the ELFCAR. This means that for pseudopotentials with relatively few valence electrons, it is possible for the ELF to be zero at atom centers. We recommend using VASP's GW potentials, with additional valence electrons.</p>"},{"location":"badelf/usage/#mismatched-grids","title":"Mismatched Grids","text":"<p>By default, VASP writes the CHGCAR and ELFCAR to different grid shapes (the \"fine\" and standard FFT meshes). The <code>Badelf</code> and <code>ElfLabeler</code> classes require the grid sizes match. This can be achieved by setting the <code>NGX(YZ)</code> and <code>NGX(YZ)F</code> tags in the INCAR to match. Alternatively, one can set the <code>PREC</code> tag to <code>single</code>, but this should be done with caution as it generally lowers the quality of the calculation unless the <code>ENCUT</code> and <code>NGX(YZ)</code> tags are set as well.</p>"},{"location":"badelf/usage/#atomic-position-precision","title":"Atomic Position Precision","text":"<p>For BadELF alorithms involving planes (i.e. <code>badelf</code> and <code>voronelf</code>), results can change significantly with very small differences in atom position. VASP writes atomic positions in the CHGCAR and ELFCAR with limited precision, sometimes much lower than the values in the POSCAR/CONTCAR. To help with this, we provide an option to override the crystal structure when reading in the CHGCAR/ELFCAR:</p> <pre><code>from baderkit.core import Badelf\n\nbadelf = Badelf.from_vasp(\"path/to/chargefile\", \"path/to/elffile\", poscar_file=\"path/to/poscar\")\n</code></pre>"},{"location":"bader/background/","title":"Background","text":"<p>In chemistry and materials science, we often find ourselves talking about the  oxidation state of a given atom. We discuss the atom as if it has taken or given  exactly one electron. However, in real molecules and materials, the charge density  is a smooth continuous function, and the electrons do not \"belong\" to any given atom.  Indeed, the concept of oxidation states is not founded in quantum mechanics, and  is effectively a tool invented by chemists through the years. Still, it  is an exceptionally useful tool that allows for qualitative understanding of a  vast array of concepts from bonding in organic molecules, to doping in metal alloys,  to the charging of lithium ion batteries.</p> <p>There have been many methods for calculating oxidation states proposed through the years. One of the most popular was proposed by Bader in his Quantum Theory  of Atoms in Molecules (QTAIM). This method relies solely on the charge density, which is relatively insensitive to the choise of basis set used to approximate  the wavefunction of the system, and is observable through experiment.  In the QTAIM method, the charge is separated  into regions by a surface located at local minima throughout the charge density.  More technically, this \"zero-flux\" surface is made up of points where the gradient  normal to the surface is zero.</p> <p>We describe the regions defined by these surfaces as basins, though they are  also commonly called Bader regions. Each basin has exactly one local maximum,  sometimes termed an attractor. Each attractor typically (though not always)  correspond to an atom, and the charge and oxidation state of the atom can be determined  by integrating the charge density within this region.</p> <p></p> <p>In practice, it is often difficult and computationally expense to thoroughly  sample the zero-flux surface defining basins. To avoid this problem,  Henkelman et. al. proposed a brilliantly simple alternative utilizing the  common representation of the charge density as points on a regular grid.  Each point on the grid is assigned to a basin by climbing the  steepest gradient until a local maximum is reached. Repeat gradient calculations  can be avoided by stopping the ascent when a previously assigned path is reached.  The end result is a robust and efficient method for dividing the charge density  into basins, without ever needing to calculate the exact location of the zero-flux  surface.</p> <p>Since the development of their original algorithm the Henkelman group and others have developed several improved methods for performing this steepest ascent. Each has its own advantages and disadvantages. We recommend reading through our Methods and Benchmarks page to determine the best one for your use case.</p>"},{"location":"bader/methods/","title":"Methods and Benchmarks","text":"<p>Through the years, several methods for performing grid-based Bader assignment have been developed. BaderKit includes each of the methods available in the Henkelman group's code as well as one developed by our own group. Here we provide brief descriptions for each and  benchmark them to  assist in selecting the one most appropriate for you. Additionally, we provide information on how BaderKit's implementation differs from the original Fortran code.</p>"},{"location":"bader/methods/#methods","title":"Methods","text":"<p>Below is a summary of the benchmarks and suggested use cases for each method. Values are based on a computer with 16 cores and 32 GB of memory. We suggest doing your own tests for your system.</p> Method Speed (s/atom)<sup>1</sup> Converged Grid Density (pts/\u00c5<sup>3</sup>)<sup>2</sup> Max Atoms<sup>1</sup> Orientation Error (e<sup>-</sup>)<sup>3</sup> neargrid-weight 0.21 8700 1140 0.0006 neargrid 0.20 63000 1140 0.0001 weight 0.26 8300 1000 0.0009 ongrid 0.19 &gt;150000 1250 0.04 <p> <ol> <li>Assuming ~30 \u00c5<sup>3</sup> per atom and a resolution of 10000 pts/\u00c5<sup>3</sup></li> <li>Resolution at which benchmark reached within 0.001 e<sup>-</sup> of converged value</li> <li>Standard deviation of orientation benchmarks</li> </ol> </p> neargrid-weight (default)neargridweightongrid <p>Key Takeaways: A hybrid method with the speed of the <code>neargrid</code> method and accuracy of the <code>weight</code> method.</p> <p>This method is a hybrid of the neargrid and weight methods. It first runs the neargrid method, then uses the fractional assignment of the weight method to split the grid points at basin edges. The result is a method that requires minimal additional time over the original neargrid method, but with a convergence rate like that of the weight method.</p> <p>Key Takeaway: Very fast and memory efficient, but requires a fine grid.</p> <p>This algorithm was developed by Henkelman et. al. after the ongrid method to fix orientation errors. It assigns each point on the grid to one basin, and its accuracy is therefore very dependent on the grid density.</p> <p>A gradient vector is calculated at each point using the three nearest neighbors.  A step is made to the neighboring point closest to this gradient vector. A correction vector pointing from the new point to the original gradient is calculated to preserve information about the true gradient.</p> <p>At each step, this correction vector is compounded. If any component of the  correction vector is ever closer to a neighboring point than the current one,  a correction is made to keep the path closer to the true gradient.</p> <p>After all of the points are assigned, a refinement must be made to the  points on the edge, as the accumulation of the gradient is technically only correct for the first point in the path.</p> <p>Reference</p> <p>W. Tang, E. Sanville, and G. Henkelman, A grid-based Bader analysis algorithm without lattice bias, J. Phys.: Condens. Matter 21, 084204 (2009)</p> <p>Key Takeaways: Converges at rough grid densities. Slightly slower and less memory efficient than other methods.</p> <p>This method converges quickly with grid density by allowing each point to be partially assigned to multiple basins. To reduce orientation errors, a voronoi cell is generated for each point on the grid to determine its nearest neighbors. A \"flux\" is calculated  from each point to its neighbors using the difference  in charge density modified by the distance to the neighbor and area of the  shared voronoi facet. The total flux is then normalized to determine the fraction of volume flowing to each neighbor.</p> <p>Moving from highest to lowest, each point is assigned to basins by assigning the fraction going to each neighbor to that neighbors own fractional assignments, creating a 'weight' corresponding to the portion of each point flowing to a given basin. The ordering from highest to lowest ensures that the higher neighbors have already received their assignment.</p> <p>Reference</p> <p>M. Yu and D. R. Trinkle, Accurate and efficient algorithm for Bader charge integration, J. Chem. Phys. 134, 064111 (2011) </p> <p>Key Takeaways: Fast, but prone to orientation errors. We do not recommend using this method, but it is kept for historical reasons.</p> <p>This is the original algorithm proposed by Henkelman et. al. It is very fast, but prone to error. It gives slightly different oxidation  states for different orientations of a molecule or material.</p> <p>For each point on the grid, the gradient is calculated for the 26 nearest  neighbors, and the neighbor with the steepest gradient is selected as the  next point in the path. This path is followed until a maximum is reached or a previous point in the path is hit. In the former case, all of the points in the path are assigned to the maximum, and in the latter they are assigned to the same maximum as the colliding path.</p> <p>Reference</p> <p>G. Henkelman, A. Arnaldsson, and H. J\u00f3nsson, A fast and robust algorithm for Bader decomposition of charge density, Comput. Mater. Sci. 36, 354-360 (2006)</p>"},{"location":"bader/methods/#benchmarks","title":"Benchmarks","text":"SpeedConvergenceMemoryOrientationCalculation Details <p>BaderKit shows improved speeds for all methods. The <code>neargrid-weight</code> method adds very little additional time over the original <code>neargrid</code> method. In all cases, loading the charge density from file makes up a bulk of the calculation, resulting in relatively small differences in each methods speed.</p> <p></p> <p>As expected from their original papers, the <code>weight</code> method converges first followed by the <code>neargrid</code> method. The <code>ongrid</code> method does not converge even at a resolution &gt;150000 pts/\u00c5<sup>3</sup>. Our own <code>neargrid-weight</code> method converges at a similar resolution as the <code>weight</code> method.</p> <p></p> <p>BaderKit uses more memory than the original Fortran code in all cases. This is largely due the need to store chunks of data for parallelization. We hope to improve this in the future.</p> <p></p> <p>The <code>neargrid</code>, <code>weight</code>, and <code>neargrid-weight</code> methods show minimal variance with orientation (&lt;0.001 e<sup>-</sup>), while the <code>ongrid</code> method shows a large bias.</p> <p>Speed, convergence, and memory benchmarks were performed on a conventional cubic 8 atom NaCl structure at varying grid densities. The charge density was calculated using the Vienna Ab-initio Simulation Package (VASP) with the PBE GGA density functional, an energy cutoff of 372.85 eV, a 3x3x3 Monkhorst\u2013Pack k-point mesh, and VASP's default GW pseudo-potentials. The unit cell relaxed to a lattice size of 5.53 \u00c5.</p> <p>Orientation benchmarks were run on a water molecule in a cubic lattice with 270 grid points  along each 8.04 \u00c5 axis. Calculations were performed using VASP, PBE GGA density functional, an energy cutoff of 400 eV, a 2x2x2 Monkhorst\u2013Pack k-point mesh, and VASP's default PBE pseudo-potentials.</p> <p>In all cases, the total charge density including the frozen atomic cores was used as the reference grid as suggested in our documentation. This is necessary for accuracy, but results in increased runtme due to the need to load two, possibly very large, files.</p> <p>All bader calculations were performed using a AMD Ryzen\u2122 Threadripper\u2122 1950X CPU with 16 cores (2 threads per core).</p> <p>Speed benchmarks were run 10 times and the average taken to account for minor fluctuations in computational time. Speed tests were run through the command line to capture the entire workflow including file read/write, basin assignment, and atom assignment. The systematic shift in all BaderKit methods is due to the initialization of Python's interpreter.    </p>"},{"location":"bader/methods/#implementation-differences","title":"Implementation Differences","text":"All MethodsOngridNeargridWeight <ul> <li> <p>Maxima/Basin Reduction: In highly symmetric systems it is common for local maxima to be positioned exactly between two or more grid points. This results in adjacent grid points with the same value. The Henkelman group's code treats these as individual maxima/basins, while we combine them to the correct single maximum/basin.</p> </li> <li> <p>Pointers Over Paths: Except for in the <code>weight</code> method, the Henkelman code starts at an arbitrary point and climbs a path to a maximum, assigning points along the way. This is fast as a serial operation, but is difficult to parallelize due to the reliance on knowledge of previously traversed paths. We instead prefer to assign pointers from each point to its highest neighbor in parallel,  effectively constructing a forest of trees with roots corresponding to basins.  We then utilize a pointer jumping algorithm to efficiently assign each point to its basin.</p> </li> <li> <p>Vacuum: By default we remove grid points below a given tolerance, including all negative values. The Henkelman group's code instead removes points with an absolute value below this tolerance.</p> </li> </ul> <ul> <li>Parallelization: As described in All Methods,  we prefer to calculate pointers in parallel and assign basins with a <code>pointer jumping</code> algorithm. In this method we achieve this by calculating the steepest neighbor for each point in parallel rather than the original method of following the steepest neighbors up a path to a maximum.</li> </ul> <ul> <li> <p>Iterative Edge Refinement: The original <code>neargrid</code> paper suggests only one edge refinement is needed. We found this is sometimes not the case, and several refinements may be needed to reach convergence. For example, the original code assigns asymmetrical charges/volumes to symmetrical basins in our test case. We therefore use iterative refinement rather than a single refinement.</p> </li> <li> <p>Parallelization: The original method starts at an arbitrary point and constructs a path traveling up the gradient, assigning points along the way. It then refines the edges once, as they may be slightly misassigned. This refinement is necessary because the gradient adjustments are only truly accurate for the starting point in the path. We therefore abandon the initial assignment entirely, instead calculating pointers from each point to its highest neighbor in parallel and reducing with a <code>pointer jumping</code> algorithm.  These pointers differ from the <code>ongrid</code> method in that they are calculated using  the gradient. The edges are then refined by performing the true hill climbing for each edge point in parallel. The result is identical to the original method with speed comparable to the <code>ongrid</code> method.</p> </li> </ul> <ul> <li> <p>Weight Basin Reduction: The weight method uses a voronoi cell to determine  neighbors and reduce orientation errors. This results in some points being  labeled as maxima when they have a lower value than one of their 26 nearest neighbors.  This results in many unrealistic basins which can significantly slow down the calculation. We remove these maxima by assigning their full weight to the highest neighbor.</p> </li> <li> <p>Parallelization: Though the <code>weight</code> method involves calculating weights that are dependent on one another, most of the components of the 'flux' used in this calculation are independent. We take advantage of this and calculate the  flux in parallel. This comes at the cost of storing the  information in memory using an array that is several times the size of the  original grid.</p> </li> <li> <p>Reversed Assignment: Calculating the weight from high to low requires one to track the partial basin assignments of each point for reference later. We instead move over the data from low to high, adding the weighted charge of each point to its higher neighbors. In this way, the charge/volume is accumulated without the need to track each points partial assignments.</p> </li> <li> <p>Basin Labels: Because the weight method provides fractional assignments, it is difficult to represent each points basin assignment. We opt to assign each point to its neighbor with the highest flux. This results in basin labels for each point, but they are only about as accurate as the <code>ongrid</code> method.</p> </li> <li> <p>Unknown Bug-fix: We have found that in some cases, particularly in non-cubic systems, the results of our method vary from the original. In particular we often find fewer local maxima (prior to any maxima reduction). As an example, the Henkelman code finds 8 local maxima in our test system while our own code finds 6. After careful examination, we are quite sure the 6 maxima are correct. We are unsure what causes this bug, but it also appears to affect the calculated positions of the basin maxima in the <code>BCF.dat</code> output for all systems and slightly affect the calculated charges in many systems.</p> </li> </ul>"},{"location":"bader/usage/","title":"Quick Start","text":""},{"location":"bader/usage/#introduction","title":"Introduction","text":"<p>The <code>Bader</code> class reproduces the methods for Bader charge analysis available in the  Henkelman group's excellent  Fortran code within the Python ecosystem. It is built on top of the PyMatGen package, allowing for easy extension to other projects. Under the hood, <code>Bader</code> runs on Numba  and NumPy to parallelize and vectorize calculations. This allows <code>Bader</code> to reach speeds comparable or faster than the original code.</p>"},{"location":"bader/usage/#basic-use","title":"Basic Use","text":"<p>BaderKit can be used through the command line interface or through Python script. This page covers only the most simple use case of running  Bader charge analysis on a VASP <code>CHGCAR</code> or Gaussian <code>cube</code> file. For more  advance usage, see our API reference  and Examples pages.</p> Command LinePythonGUI App <ol> <li> <p>Activate your environment with BaderKit installed. If you are not using an environment manager, skip to step 2.</p> <pre><code>conda activate my_env\n</code></pre> </li> <li> <p>Navigate to the directory with your charge density file.</p> <pre><code>cd /path/to/directory\n</code></pre> </li> <li> <p>Run the bader analysis. Replace 'chargefile' with the name of your file.</p> <pre><code>baderkit run chargefile\n</code></pre> </li> </ol> <p>Output files for atoms and bader basins will be written automatically to  <code>bader_atom_summary.tsv</code> and <code>bader_basin_summary.tsv</code> respectively. Each file includes rows for each atom or basin with columns for:</p> <ul> <li>atom labels/assignments</li> <li>coordinates (fractional) </li> <li>charges (e) </li> <li>volumes (\u00c5<sup>3</sup>)</li> <li>minimum surface distances (\u00c5)</li> <li>distances to nearest atom (\u00c5) basins only</li> </ul> <p>Additional arguments and options such as those for printing output files or using different  algorithms can be viewed by running the help command. <pre><code>baderkit run --help\n</code></pre></p> <ol> <li> <p>Import the <code>Bader</code> class.</p> <pre><code>from baderkit.core import Bader\n</code></pre> </li> <li> <p>Use the <code>Bader</code> class' <code>from_dynamic</code> method to read a <code>CHGCAR</code> or <code>cube</code> file.</p> <pre><code># instantiate the class\nbader = Bader.from_dynamic(\"path/to/charge_file\")\n</code></pre> </li> <li> <p>To run the analysis, we can call any class property. Try getting a complete summary in dictionary format.     <pre><code>results = bader.to_json()\n</code></pre></p> </li> <li> <p>Now try getting individual properties. For more details on each property, see the API reference.     <pre><code>atom_charges = bader.atom_charges # Total atom charges\natom_labels = bader.atom_labels # Atom assignments for each point in the grid\nbasin_volumes = bader.basin_volumes # The volumes of each bader basin\nmaxima_coords = bader.basin_maxima_frac # Frac coordinates of each attractor\n</code></pre></p> </li> <li> <p>BaderKit also provides convenience methods for writing results to file. First, let's write a summary of the full analysis.</p> <pre><code>bader.write_json()\n</code></pre> </li> <li> <p>Now let's write the volume assigned to one of our atoms.</p> <pre><code>bader.write_atom_volumes(atom_indices = [0])\n</code></pre> </li> </ol> <p>Tip</p> <p>After creating a <code>Bader</code> class object, it doesn't matter what order you call properties, summaries, or write methods in. BaderKit calculates properties/results only when they are needed and caches them.</p> <ol> <li> <p>Activate your environment with BaderKit installed. If you are not using an environment manager, skip to step 2.</p> <pre><code>conda activate my_env\n</code></pre> </li> <li> <p>Run the BaderKit GUI.     <pre><code>baderkit gui\n</code></pre></p> <p>This will launch a new window: </p> </li> <li> <p>Browse to find you charge density file, select your method, and run!</p> </li> </ol>"},{"location":"bader/usage/#warning-for-vasp-and-other-pseudopotential-codes","title":"Warning for VASP (And other pseudopotential codes)","text":"<p>VASP and other pseudopotential codes only include the valence electrons in their charge density outputs. In VASP, there is an option to write out the core electron density by adding the tag <code>LAECHG=.TRUE.</code> to your <code>INCAR</code> file.</p> <p>This will write the core charge density to an <code>AEECAR0</code> file and the valence  to <code>AECCAR2</code> which can be summed together to get a total charge density that is much more accurate for partitioning. We highly recommend doing this.</p> Command LinePython <ol> <li>Sum the files using BaderKit's convenience method. <pre><code>baderkit sum AECCAR0 AECCAR2\n</code></pre></li> <li>Run the analysis using this total charge density as the reference for partitioning. <pre><code>baderkit run CHGCAR -ref CHGCAR_sum\n</code></pre></li> </ol> <ol> <li>Import the Bader and Grid classes. <pre><code>from baderkit.core import Bader, Grid\n</code></pre></li> <li>Load the CHGCAR, AECCAR0 and AECCAR2 <pre><code>charge_grid = Grid.from_vasp(\"CHGCAR\")\naeccar0_grid = Grid.from_vasp(\"AECCAR0\")\naeccar2_grid = Grid.from_vasp(\"AECCAR2\")\n</code></pre></li> <li>Sum the AECCAR files <pre><code>reference_grid = aeccar0.linear_add(aeccar2_grid)\n</code></pre></li> <li>Create the bader object <pre><code>bader = Bader(\n    charge_grid = charge_grid,\n    reference_grid = reference_grid\n    )\n</code></pre> From here, the <code>Bader</code> class object can be used as described in the Basic Use section.</li> </ol> <p>Warning</p> <p>A fine grid is needed to accurately reproduce the core charge density. We have found that a grid density of ~22 pts/\u00c5 along each lattice vector (~10000 pts / \u00c5<sup>3</sup>) is fine enough in most cases, but we generally recommend testing an increasing set of grid densities until convergence is reached.</p>"},{"location":"elf_labeler/background/","title":"Background","text":"<p>Note</p> <p>This page assumes prior knowledge of Bader's method for quantifying atomic charge and oxidation states. See Bader for more information.</p>"},{"location":"elf_labeler/background/#the-electron-localization-function","title":"The Electron Localization Function","text":"<p>The Electron Localization Function (ELF), as its name suggests, is a measure of the localization of electrons in a system. It was originally developed in 1990 by Becke and Edgecombe and was very quickly adopted as a tool for the qualitative and quantitative analysis of chemical features and bonding.</p> <p></p> <p>There are many interpretations of the ELF, but our favorite comes from J.K. Burdett and T.A. McCormick. For those who are not so math oriented, don't worry. The equations simplify very quickly.</p> <p>For a system with spin \\(\\sigma\\), the charge density, \\(\\rho_{\\sigma}\\), and a set of occupied molecular orbitals, \\({\\psi_{i\\sigma}}\\), the ELF is given by</p> \\[ \\begin{equation} \\text{ELF} = \\frac{1}{1 + (\\frac{D_{\\sigma}}{D_{\\sigma,gas}})^2}\\ \\label{eq:1} \\end{equation} \\] <p>where,</p> \\[ \\begin{equation} D_{\\sigma}/D_{\\sigma,gas} = 0.3483\\rho^{-5/3}_{\\sigma}\\Big[\\sum_{i}|\\nabla\\psi_{i\\sigma}|^2 - \\frac{1}{8}|\\nabla\\rho_{\\sigma}|^2/\\rho_{\\sigma}\\Big] \\label{eq:2} \\end{equation} \\] <p>The \\(D_{\\sigma}\\) is the first term in the Taylor expansion of the spherically averaged \\(\\sigma\\)-spin pair probability, and the subscript \"gas\" refers to the corresponding value for the homogenous electron gas. </p> <p>The ELF ranges from 0 to 1 and has a value of 0.5 for the homogenous electron gas. Therefore, an ELF value of 1.0 corresponds to a fully localized region and a value of 0.5 to a fully delocalized region. Values below 0.5 are less intuitive. A useful observation is that the first term in the brackets of \\(\\eqref{eq:2}\\) is the kinetic energy density at a given point and the latter term is proportional to the Weisz\u00e4cker functional (the kinetic energy density at a point if only one occupied orbital were to contribute to \\(\\rho\\)). The first term is always greater than the second and in practice is typically much larger. This means that for most systems, the dominant part of equation \\(\\eqref{eq:2}\\) is</p> \\[ \\sum_i\\frac{|\\nabla\\psi_{i\\sigma}|^2}{\\rho^{5/3}} \\] <p>Thus, the ELF is primarily dependent on the kinetic energy density (numerator) and charge density (denomenator). As this term is inverted in equation \\(\\eqref{eq:1}\\), the ELF increases with charge density and decreases with kinetic energy. This is chemically intuitive, as it suggests high localization where there are many electrons or where electrons are not moving significantly. Another useful note is that the ELF tends to decrease heavily in regions where there are a significant number of nodes in the occupied orbitals. In these regions, the increase in charge density is outweighed by the contribution of nodes to the kinetic energy. Thus, an ELF value below 0.5 can be understood as a region with very little electron density (i.e. interstitial areas between atoms) or a region with a great number of nodes.</p>"},{"location":"elf_labeler/background/#topology-of-the-elf","title":"Topology of the ELF","text":"<p>Note</p> <p>This discussion is largely based on this review by Carlo Gatti: Chemical bonding in crystals: new directions.</p> <p>Much like Bader analysis, the ELF can be separated into multiple regions at zero-flux surfaces. These regions are called basins and each contains a single local maximum called an attractor. Typically, attractors are single points, but in areas of high symmetry they may be rings or cages. Each basin has its own set of useful properties such as charge, volume, position, shape, etc. The advantage of the ELF over the charge density is its ability to show localized features that the charge density does not (e.g. covalent bonds, lone-pairs, electrides, etc.), which can enable more in-depth analysis of chemical interactions.</p> <p>A helpful tool for analyzing ELF basins is the bifurcation plot. The x-axis of a bifurcation plot spans the elf values from 0 to 1. Each value of x defines a set of solids called domains where the ELF is greater than or equal to x. As x is increased, some domains split (bifurcate) at saddle points into smaller domains. New domains are represented by points at the x value at which they appear and are connected to their parent by a line. The domains that never split are exactly the same as the basins described earlier. In our bifurcation plots, we represent these as rectangles that span their total ELF depth. Thus, the bifurcation plot maps out the relationships between various basins and their parent domains.</p> <p></p> <p> The bifurcation plot for Ca<sub>2</sub>N. The first two bars represent the Ca shells, the third bar the N shell, and the final red bar an electride electron. The electride and N atom form a larger domain at ~0.1 as evidenced by the lines connecting them to a reducible domain. This domain does not connect to the Ca atoms until a lower value of ~0.06. The `depth` of each domain is represented by horizontal lines for reducible domains and the length of the bars for irreducible domains (basins). Note that the Ca and N only display single shells due to the use of pseudopotentials. </p> <p>The bifurcation plot provides us with a depth for each domain which corresponds to the range of x values in which the domain exists. Our team uses this to make a distinction between basins and chemical features (or ELF features). Chemical features are what a chemist would likely use to analyze a system such as covalent bonds, lone-pairs, atom shells, etc. In most cases, these features map directly to a single basin, but in some cases two or more basins are separated by a very shallow depth. In these cases, it is often more intuitive to consider the sum of these basins as a single chemical feature. For example, the outer shell of anions is often slighly polarized towards the nearby cations, leading to several very shallow basins.</p> <p></p> <p> Depth shematic for LiI. The central purple atom is iodide and the yellow isosurface is its outermost shell at the given ELF value. The second image shows the bifurcation of the shell into smaller basins. These disappear at a slightly higher ELF value, resulting in a very shallow depth. Because these basins are so shallow relative to the domain formed below 0.56, it is more intuitive to describe them as a single feature. </p>"},{"location":"elf_labeler/background/#labeling-chemical-features","title":"Labeling Chemical features","text":"<p>Labeling chemical features in the ELF is best done by rigorous analysis of an expert. Despite this, its beneficial to have a method that automatically guesses the types of features in a system. This is the aim of the <code>ElfLabeler</code> class.</p> <p>Following Bader, we can broadly categorize features into three categories:</p> <ol> <li>Core: Atomic shells, not including the valence shell.</li> <li>Bonding: Features involved in attractive forces. This can further be separated into two categories.<ul> <li>shared: covalent, metallic, multi-centered, etc.</li> <li>unshared: ionic, electrostatic, van der Waals, etc.</li> </ul> </li> <li>Non-bonding: lone-pairs, f-centers, electrides, etc.</li> </ol> <p>In practice, many of these are difficult to distinguish without human chemical intuition. We have so far developed methods to label only some of these features, and in many cases multiple features may be categorized together. We list the current labels and describe our criteria for labeling them below.</p> <ol> <li> <p>Atomic Shells appear as point attractor at the center of the atom or as cage attractors fully surrounding an atom. Currently, we do not distinguish between core shells and valence shells, and this label may also be applied to unshared bonding features.</p> </li> <li> <p>Covalent Bonds are point or ring attractors that sit directly along a bond between an atom and its neighbor. This is also a common feature of the outermost shells of anions in ionic bonds, and an arbitrary cutoff must be applied.</p> </li> <li> <p>Metallic-covalent Bonds are essentially the same as covalent bonds, but involve a metallic species. They may also have significantly lower charge and localization if they are part of a larger metallic network.</p> </li> <li> <p>Lone-pairs typically appear in systems with covalent bonds and join with covalent bonds to form a domain surrounding multiple atoms. In some cases, lone-pairs can also form in ionic systems (e.g. SnO) in which case they will bifurcate from the related atom's outermost shell at low ELF values and have a large depth.</p> </li> <li> <p>Metallic features often appear as many, shallow depth point attractors forming a network spread throughout the system. They are very similar to multi-centered bonds and non-bonding features, with arbitrary cutoffs based on depth.</p> </li> <li> <p>Multi-centered Bonds sit at interstitial sites between multiple atoms. They are often found in metallic systems, and share many similarities with metallic features. In most cases they are really only distince from metallic features in that they have a greater depth and are more likely to have a higher ELF value.</p> </li> <li> <p>Bare Electrons include features like f-centers and electrides. Like metallic features, it is difficult to distinguish them from multi-centered bonds, and we are currently working to determine reasonable criteria for distinguishing them.</p> </li> </ol> <p>Note</p> <p>The 'ElfLabeler' is a work in progress and we are looking to improve it. If you have suggestions or desired features, please let our team know on our github issues page.</p>"},{"location":"elf_labeler/usage/","title":"Quick Start","text":""},{"location":"elf_labeler/usage/#introduction","title":"Introduction","text":"<p>The first step of the BadELF algorithm is to determine whether there are bare electrons in the system and, if so, where they are located. In the original paper, this was done by using relatively simple distance and ELF value cutoffs. Since then, the <code>ElfLabeler</code> method has evolved to be more rigorous. Using exclusively the ELF, charge density, and crystal structure, the <code>ElfLabeler</code> class aims to automatically label not only bare electrons, but atom shells, covalent bonds, metallic features, and lone-pairs.</p> <p>While it was originally conceived to support the BadELF algorithm, the current ElfLabeler class can be used as a general tool for analyzing the ELF, providing considerably more information on each ELF feature than the Badelf class.</p>"},{"location":"elf_labeler/usage/#basic-use","title":"Basic Use","text":"<p>The <code>ElfLabeler</code> can be run through the command line interface or through Python script. Currently only VASP's CHGCAR and ELFCAR files are supported.</p> Command LinePythonGUI App <ol> <li> <p>Activate your environment with BaderKit installed. If you are not using an environment manager, skip to step 2.</p> <pre><code>conda activate my_env\n</code></pre> </li> <li> <p>Navigate to the directory with your charge density and ELF files.</p> <pre><code>cd /path/to/directory\n</code></pre> </li> <li> <p>Run the <code>ElfLabeler</code> analysis. Replace 'chargefile' and 'elffile' with the names of your charge-density and ELF files.</p> <pre><code>baderkit label chargefile elffile\n</code></pre> </li> </ol> <p>An output summary will automatically be written to an 'elf_labeler.json' file.</p> <ol> <li> <p>Import the <code>ElfLabeler</code> class.</p> <pre><code>from baderkit.core import ElfLabeler\n</code></pre> </li> <li> <p>Use the <code>ElfLabeler</code> class' <code>from_vasp</code> method to read a <code>CHGCAR</code> and <code>ELFCAR</code> file.</p> <pre><code># instantiate the class\nlabeler = ElfLabeler.from_vasp(\"path/to/chargefile\", \"path/to/elffile\")\n</code></pre> </li> <li> <p>To run the analysis, we can call any class property. Try getting a complete summary in dictionary format.     <pre><code>results = labeler.to_json()\n</code></pre></p> </li> <li> <p>Now try getting individual properties. For more details on each property, see the API reference.     <pre><code>feature_types = labeler.feature_types\nfeature_charges = labeler.feature_charges\nlabeled_structure = labeler.labeled_structure\n</code></pre></p> </li> <li> <p>BaderKit also provides convenience methods for writing results to file. Let's write a summary of the full analysis, as well as a plot of the bifurcation graph.</p> <pre><code>labeler.write_json()\nlabeler.write_bifurcation_plot()\n</code></pre> </li> </ol> <p>Note</p> <p>The <code>ElfLabeler</code> uses the <code>Bader</code> class for partitioning. Any extra keyword arguments, such as the <code>method</code> parameter will be passed to the <code>Bader</code> class.</p> <p>Warning</p> <p>Currently the GUI App only supports Bader analysis.</p>"},{"location":"elf_labeler/usage/#spin-dependent-calculations","title":"Spin-Dependent Calculations","text":"<p>BaderKit provides a convenience class for using the <code>ElfLabeler</code> on the spin-up and spin-down ELF separately. The combined results are also calculated by taking either the average or sum of the respective property.</p> Command LinePython <p>Run the command with the <code>--spin</code> tag.</p> <pre><code>baderkit label chargefile elffile --spin\n</code></pre> <p>The results for each spin system are then written to separate files.</p> <ol> <li> <p>Import the <code>SpinElfLabeler</code> class and read in your spin-dependent files.</p> <pre><code>from baderkit.core import SpinElfLabeler\n# instantiate the class\nlabeler = SpinElfLabeler.from_vasp(\"path/to/chargefile\", \"path/to/elffile\")\n</code></pre> </li> <li> <p>Get the separate results for the spin-up and spin-down systems.</p> <pre><code>spin_up = labeler.elf_labeler_up\nspin_down = labeler.elf_labeler_down\n</code></pre> </li> <li> <p>View properties separately or combined.</p> <pre><code>up_charges = spin_up.feature_charges\ndown_charges = spin_down.feature_charges\ntotal_charges = badelf.feature_charges\n</code></pre> </li> </ol>"},{"location":"elf_labeler/usage/#visualizing-and-interpreting-results","title":"Visualizing and Interpreting Results","text":""},{"location":"elf_labeler/usage/#the-labeled-structure","title":"The Labeled Structure","text":"<p>A useful output from the <code>ElfLabeler</code> class is the labeled structure which is a pymatgen <code>Structure</code> object with 'dummy' atoms representing the different types of ELF features. This can be obtained from the <code>labeled_structure</code> property.</p> <p>Pymatgen limits what labels can be used for dummy atoms based on if they start with the labels of an existing atom. Currently, we have settled on the following \"species\" labels for dummy atoms.</p> Feature Label Shell \"Xs\" Covalent \"Z\" Multi-centered \"Mc\" Lone-Pair \"Lp\" Metallic \"M\" Bare Electron \"E\" <p>This structure can be written to a cif or POSCAR format with the <code>Structure.to()</code> method.</p>"},{"location":"elf_labeler/usage/#feature-properties","title":"Feature Properties","text":"<p>The properties assigned to each feature in the labeled structure are available as class properties. They may also be written to file with the <code>ElfLabeler.to_json()</code> method, which is used when running through the command line. Properties are always in the same order as the dummy atoms in the <code>labeled_structure</code>.</p> <p>Some properties have <code>_e</code> appended at the end. This indicates that the electride sites were treated as quasi-atoms for this property. The electrides are included in any CrystalNN related analysis and given their own charge and \"oxidation state\". The equivalent properties without <code>_e</code> are calculated treating electride sites as some form of multi-centered bond.</p>"},{"location":"elf_labeler/usage/#warnings-for-vasp","title":"Warnings for VASP","text":"<p>See the warning on the Badelf page.</p>"},{"location":"example_scripts/custom_file_formats/","title":"Custom Data Formats","text":"<p>BaderKit only provides convenience functions for loading VASP <code>CHGCAR</code>-like files or Gaussian <code>cube</code>-like files. However, as long as you can read in your charge density into a NumPy array, you can still use BaderKit by constructing the <code>Structure</code>,  <code>Grid</code>, and <code>Bader</code> classes manually.</p> <pre><code># import \nfrom baderkit.core import Bader, Grid, Structure\nimport numpy as np\n\n# Create a PyMatGen Structure object. This is usually easiest to do from a\n# file, but can also be made manually.\nstructure = Structure.from_file(filename = \"mystructure.cif\", fmt = \"cif\")\n\n# Load your data, however you can, into a numpy array.\ncharge_data = np.array([\n[[1,2,3],[3,4,5],[6,7,8]],\n[[1,2,3],[3,4,5],[6,7,8]],\n[[1,2,3],[3,4,5],[6,7,8]],\n])\n\n# Create a data dictionary\ndata = {\"total\": charge_data}\n\n# create Grid objects for the charge-density (and reference file if needed)\ncharge_grid = Grid(structure=structure, data=data)\n\n# Create the Bader object\nbader = Bader(charge_grid = charge_grid)\n</code></pre> <p>Warning</p> <p>The charge density data must follow VASP's conventions, i.e. it should be stored as </p> <p>data(r) = n(r) x V<sub>grid</sub> x V<sub>cell</sub></p> <p>where</p> <ul> <li>n(r) = charge density in 1/Ang at point r</li> <li>V<sub>grid</sub> = the total number of grid points</li> <li>V<sub>cell</sub> = the volume of the simulation cell</li> </ul> <p>See VASP's wiki for more details.</p>"},{"location":"example_scripts/spin_polarized_calculations/","title":"Spin Separated Calculations","text":"<p>BaderKit runs on whatever set of data is stored in the <code>total</code> property of the <code>Grid</code> class. By default, this data is read from the first set of data in a <code>CHGCAR</code> or <code>cube</code> format file. This typically represents the total charge density of both the spin-up and spin-down electrons.</p> <p>In VASP, spin polarized calculations will also write an additional set of data representing the difference between the spin-up and spin-down charge densities. When read from file, this data is stored in the <code>diff</code> property of the <code>Grid</code> class.</p> <p>Assuming we have run a spin-polarized calculation with VASP, we can run the Bader analysis on the separate spin-up and spin-down systems by creating two <code>Grid</code> and <code>Bader</code> class objects with the appropriate charge densities in the <code>total</code> property.</p> Command LinePython <ol> <li> <p>Split your file using the provided helper command. Replace 'chargefile' with your actual file path.</p> <pre><code>baderkit split chargefile\n</code></pre> </li> <li> <p>Run the bader analysis on the spin up system and copy it to avoid overwriting.</p> <pre><code>baderkit run chargefile_up\nmv bader_atom_summary.tsv bader_atom_summary_up.tsv\nmv bader_basin_summary.tsv bader_basin_summary_up.tsv\n</code></pre> </li> <li> <p>Run the bader analysis on the spin down system.</p> <pre><code>baderkit run chargefile_down\nmv bader_atom_summary.tsv bader_atom_summary_down.tsv\nmv bader_basin_summary.tsv bader_basin_summary_down.tsv\n</code></pre> </li> </ol> <pre><code># import \nfrom baderkit.core import Bader, Grid\n\n# load the spin polarized charge grid. Make sure the `total_only` tag is set to\n# false to indicate that we want to load all sets of data.\npolarized_grid = Grid.from_vasp(\"CHGCAR\", total_only=False)\n\n# split the polarized grid to the spin up and spin down components\ngrid_up, grid_down = polarized_grid.split_to_spin()\n\n# create our Bader classes\nbader_up = Bader(grid_up)\nbader_down = Bader(grid_down)\n\n# get results\nresults_up = bader_up.results_summary\nresults_down = bader_down.results_summary\n</code></pre> <p>Tip</p> <p>This analysis can be run on results from softwares other than VASP as well. Either set up the <code>polarized_grid</code> so that it follows VASP's <code>total</code> and <code>diff</code> format, or load/create the <code>grid_up</code> and <code>grid_down</code> from already split data.</p> <p>Warning</p> <p>This example does not use the core + valence charge density as we suggest in our warning. This is because VASP does not write spin separated <code>AECCAR0</code> or <code>AECCAR2</code> files. You can still use the <code>CHGCAR_sum</code> as a reference, but the bader basins will be defined by the total charge density, not the spin-polarized ones.</p>"}]}