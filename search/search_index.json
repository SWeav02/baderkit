{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quick Start","text":""},{"location":"#quick-start","title":"Quick Start","text":"<p>BaderKit reproduces the methods for Bader charge analysis available in the  Henkelman group's excellent  Fortran code within the Python ecosystem. It is built on top of the PyMatGen package, allowing for easy extension to other projects. Under the hood, BaderKit runs on Numba  and NumPy to parallelize and vectorize calculations. This allows BaderKit to reach speeds comparable or faster than the original code.</p>"},{"location":"#installation","title":"Installation","text":"conda (recommended)pipGUI App (Optional) <p>If you haven't already, install a conda environment manager such as Anaconda.</p> <ol> <li>Create a conda environment using the following command in your terminal. Replace <code>my_env</code> with whatever name you prefer. <pre><code>conda create -n my_env\n</code></pre></li> <li>Activate your environment. <pre><code>conda activate my_env\n</code></pre></li> <li>Install BaderKit. <pre><code>conda install -c conda-forge baderkit\n</code></pre></li> <li>Confirm the install by running the help command. <pre><code>baderkit --help\n</code></pre></li> </ol> <p>We generally recommend using a virtual environment manager such as Anaconda or venv to keep your Python work environments isolated. If you don't want to, you can still use pip so long as Python is installed.</p> <ol> <li>Install BaderKit with the following command in your terminal. <pre><code>pip install baderkit\n</code></pre></li> <li>Confirm the install by running the help command <pre><code>baderkit --help\n</code></pre></li> </ol> <p>In addition to the core package, there is an optional GUI feature which allows for easy viewing and plotting of results. This requires extra dependencies which can be installed through pip.</p> <pre><code>pip install baderkit[gui]\n</code></pre> <p>Note</p> <p>This is kept as optional as the GUI requires significantly more dependencies than the base app. Unfortunately, this means conda cannot be used, as it does not allow for optional dependencies.</p>"},{"location":"#basic-use","title":"Basic Use","text":"<p>Once installed, BaderKit can be used through the command line interface or through Python script. This page covers only the most simple use case of running  Bader charge analysis on a VASP <code>CHGCAR</code> or Gaussian <code>cube</code> file. For more  advance usage, see our API reference  and Examples pages.</p> Command LinePythonGUI App <ol> <li> <p>Activate your environment with BaderKit installed. If you are not using an environment manager, skip to step 2.</p> <pre><code>conda activate my_env\n</code></pre> </li> <li> <p>Navigate to the directory with your charge density file.</p> <pre><code>cd /path/to/directory\n</code></pre> </li> <li> <p>Run the bader analysis. Replace 'chargefile' with the name of your file.</p> <pre><code>baderkit run chargefile\n</code></pre> </li> </ol> <p>Output files for atoms and bader basins will be written automatically to  <code>bader_atom_summary.tsv</code> and <code>bader_basin_summary.tsv</code> respectively. Each file includes rows for each atom or basin with columns for:</p> <ul> <li>atom labels/assignments</li> <li>coordinates (fractional) </li> <li>charges (e) </li> <li>volumes (\u00c5<sup>3</sup>)</li> <li>minimum surface distances (\u00c5)</li> <li>distances to nearest atom (\u00c5) basins only</li> </ul> <p>Additional arguments and options such as those for printing output files or using different  algorithms can be viewed by running the help command. <pre><code>baderkit run --help\n</code></pre></p> <ol> <li> <p>The core functionality of BaderKit revolves around the <code>Bader</code> class. First, import the <code>Bader</code> class.</p> <pre><code>from baderkit.core import Bader\n</code></pre> </li> <li> <p>Use the <code>Bader</code> class' <code>from_dynamic</code> method to read a <code>CHGCAR</code> or <code>cube</code> file.</p> <pre><code># instantiate the class\nbader = Bader.from_dynamic(\"path/to/charge_file\")\n</code></pre> </li> <li> <p>To run the analysis, we can call any class property. Try getting a complete summary in dictionary format.     <pre><code>results = bader.results_summary\n</code></pre></p> </li> <li> <p>Now try getting individual properties. For more details on each property, see the API reference.     <pre><code>atom_charges = bader.atom_charges # Total atom charges\natom_labels = bader.atom_labels # Atom assignments for each point in the grid\nbasin_volumes = bader.basin_volumes # The volumes of each bader basin\nmaxima_coords = bader.basin_maxima_frac # Frac coordinates of each attractor\n</code></pre></p> </li> <li> <p>BaderKit also provides convenience methods for writing results to file. First, let's write a summary of the full analysis.</p> <pre><code>bader.write_results_summary()\n</code></pre> </li> <li> <p>Now let's write the volume assigned to one of our atoms.</p> <pre><code>bader.write_atom_volumes(atom_indices = [0])\n</code></pre> </li> </ol> <p>Tip</p> <p>After creating a <code>Bader</code> class object, it doesn't matter what order you call properties, summaries, or write methods in. BaderKit calculates properties/results only when they are needed and caches them.</p> <ol> <li> <p>Activate your environment with BaderKit installed. If you are not using an environment manager, skip to step 2.</p> <pre><code>conda activate my_env\n</code></pre> </li> <li> <p>Run the BaderKit GUI.     <pre><code>baderkit gui\n</code></pre></p> <p>This will launch a new window: </p> </li> <li> <p>Browse to find you charge density file, select your method, and run!</p> </li> </ol>"},{"location":"#warning-for-vasp-and-other-pseudopotential-codes","title":"Warning for VASP (And other pseudopotential codes)","text":"<p>VASP and other pseudopotential codes only include the valence electrons in their charge density outputs. In VASP, there is an option to write out the core electron density by adding the tag <code>LAECHG=.TRUE.</code> to your <code>INCAR</code> file.</p> <p>This will write the core charge density to an <code>AEECAR0</code> file and the valence  to <code>AECCAR2</code> which can be summed together to get a total charge density that is much more accurate for partitioning. We highly recommend doing this.</p> Command LinePython <ol> <li>Sum the files using BaderKit's convenience method. <pre><code>baderkit sum AECCAR0 AECCAR2\n</code></pre></li> <li>Run the analysis using this total charge density as the reference for partitioning. <pre><code>baderkit run CHGCAR -ref CHGCAR_sum\n</code></pre></li> </ol> <ol> <li>Import the Bader and Grid classes. <pre><code>from baderkit.core import Bader, Grid\n</code></pre></li> <li>Load the CHGCAR, AECCAR0 and AECCAR2 <pre><code>charge_grid = Grid.from_vasp(\"CHGCAR\")\naeccar0_grid = Grid.from_vasp(\"AECCAR0\")\naeccar2_grid = Grid.from_vasp(\"AECCAR2\")\n</code></pre></li> <li>Sum the AECCAR files <pre><code>reference_grid = aeccar0.linear_add(aeccar2_grid)\n</code></pre></li> <li>Create the bader object <pre><code>bader = Bader(\n    charge_grid = charge_grid,\n    reference_grid = reference_grid\n    )\n</code></pre> From here, the <code>Bader</code> class object can be used as described in the Basic Use section.</li> </ol> <p>Warning</p> <p>A fine grid is needed to accurately reproduce the core charge density. We have found that a grid density of ~22 pts/\u00c5 along each lattice vector (~10000 pts / \u00c5<sup>3</sup>) is fine enough in most cases, but we generally recommend testing an increasing set of grid densities until convergence is reached.</p>"},{"location":"background/","title":"Background","text":"<p>In chemistry and materials science, we often find ourselves talking about the  oxidation state of a given atom. We discuss the atom as if it has taken or given  exactly one electron. However, in real molecules and materials, the charge density  is a smooth continuous function, and the electrons do not \"belong\" to any given atom.  Indeed, the concept of oxidation states is not founded in quantum mechanics, and  is effectively a tool invented by chemists through the years. Still, it  is an exceptionally useful tool that allows for qualitative understanding of a  vast array of concepts from bonding in organic molecules, to doping in metal alloys,  to the charging of lithium ion batteries.</p> <p>There have been many methods for calculating oxidation states proposed through the years. One of the most popular was proposed by Bader in his Quantum Theory  of Atoms in Molecules (QTAIM). This method relies solely on the charge density, which is relatively insensitive to the choise of basis set used to approximate  the wavefunction of the system, and is observable through experiment.  In the QTAIM method, the charge is separated  into regions by a surface located at local minima throughout the charge density.  More technically, this \"zero-flux\" surface is made up of points where the gradient  normal to the surface is zero.</p> <p>We describe the regions defined by these surfaces as basins, though they are  also commonly called Bader regions. Each basin has exactly one local maximum,  sometimes termed an attractor. Each attractor typically (though not always)  correspond to an atom, and the charge and oxidation state of the atom can be determined  by integrating the charge density within this region.</p> <p></p> <p>In practice, it is often difficult and computationally expense to thoroughly  sample the zero-flux surface defining basins. To avoid this problem,  Henkelman et. al. proposed a brilliantly simple alternative utilizing the  common representation of the charge density as points on a regular grid.  Each point on the grid is assigned to a basin by climbing the  steepest gradient until a local maximum is reached. Repeat gradient calculations  can be avoided by stopping the ascent when a previously assigned path is reached.  The end result is a robust and efficient method for dividing the charge density  into basins, without ever needing to calculate the exact location of the zero-flux  surface.</p> <p>Since the development of their original algorithm the Henkelman group and others have developed several improved methods for performing this steepest ascent. Each has its own advantages and disadvantages. We recommend reading through our Methods and Benchmarks page to determine the best one for your use case.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page hosts various examples for using BaderKit for cases not covered on the Quick Start page. If you run into issues and cannot find the answer here or using our API reference, feel free to open an issue or discussion on our github page. Similarly, if you have an example you would like to add, please open a discussion or pull request.</p>"},{"location":"examples/#list-of-examples","title":"List of examples","text":"<p>File formats other than CHGCAR or cube</p> <p>Spin separated calculations</p>"},{"location":"implementation/","title":"Methods and Benchmarks","text":"<p>Through the years, several methods for performing grid-based Bader assignment have been developed. BaderKit includes each of the methods available in the Henkelman group's code as well as one developed by our own group. Here we provide brief descriptions for each and  benchmark them to  assist in selecting the one most appropriate for you. Additionally, we provide information on how BaderKit's implementation differs from the original Fortran code.</p>"},{"location":"implementation/#methods","title":"Methods","text":"<p>Below is a summary of the benchmarks and suggested use cases for each method. Values are based on a computer with 16 cores and 32 GB of memory. We suggest doing your own tests for your system.</p> Method Speed (s/atom)<sup>1</sup> Converged Grid Density (pts/\u00c5<sup>3</sup>)<sup>2</sup> Max Atoms<sup>1</sup> Orientation Error (e<sup>-</sup>)<sup>3</sup> neargrid-weight 0.21 8700 1140 0.0006 neargrid 0.20 63000 1140 0.0001 weight 0.26 8300 1000 0.0009 ongrid 0.19 &gt;150000 1250 0.04 <p>1. Assuming ~30 \u00c5<sup>3</sup> per atom and a resolution of 10000 pts/\u00c5<sup>3</sup></p> <p>2. Resolution at which benchmark reached within 0.001 e<sup>-</sup> of converged value</p> <p>3. Standard deviation of orientation benchmarks</p> neargrid-weight (default)neargridweightongrid <p>Key Takeaways: A hybrid method with the speed of the <code>neargrid</code> method and accuracy of the <code>weight</code> method.</p> <p>This method is a hybrid of the neargrid and weight methods. It first runs the neargrid method, then uses the fractional assignment of the weight method to split the grid points at basin edges. The result is a method that requires minimal additional time over the original neargrid method, but with a convergence rate like that of the weight method.</p> <p>Key Takeaway: Very fast and memory efficient, but requires a fine grid.</p> <p>This algorithm was developed by Henkelman et. al. after the ongrid method to fix orientation errors. It assigns each point on the grid to one basin, and its accuracy is therefore very dependent on the grid density.</p> <p>A gradient vector is calculated at each point using the three nearest neighbors.  A step is made to the neighboring point closest to this gradient vector. A correction vector pointing from the new point to the original gradient is calculated to preserve information about the true gradient.</p> <p>At each step, this correction vector is compounded. If any component of the  correction vector is ever closer to a neighboring point than the current one,  a correction is made to keep the path closer to the true gradient.</p> <p>After all of the points are assigned, a refinement must be made to the  points on the edge, as the accumulation of the gradient is technically only correct for the first point in the path.</p> <p>Reference</p> <p>W. Tang, E. Sanville, and G. Henkelman, A grid-based Bader analysis algorithm without lattice bias, J. Phys.: Condens. Matter 21, 084204 (2009)</p> <p>Key Takeaways: Converges at rough grid densities. Slightly slower and less memory efficient than other methods.</p> <p>This method converges quickly with grid density by allowing each point to be partially assigned to multiple basins. To reduce orientation errors, a voronoi cell is generated for each point on the grid to determine its nearest neighbors. A \"flux\" is calculated  from each point to its neighbors using the difference  in charge density modified by the distance to the neighbor and area of the  shared voronoi facet. The total flux is then normalized to determine the fraction of volume flowing to each neighbor.</p> <p>Moving from highest to lowest, each point is assigned to basins by assigning the fraction going to each neighbor to that neighbors own fractional assignments, creating a 'weight' corresponding to the portion of each point flowing to a given basin. The ordering from highest to lowest ensures that the higher neighbors have already received their assignment.</p> <p>Reference</p> <p>M. Yu and D. R. Trinkle, Accurate and efficient algorithm for Bader charge integration, J. Chem. Phys. 134, 064111 (2011) </p> <p>Key Takeaways: Fast, but prone to orientation errors. We do not recommend using this method, but it is kept for historical reasons.</p> <p>This is the original algorithm proposed by Henkelman et. al. It is very fast, but prone to error. It gives slightly different oxidation  states for different orientations of a molecule or material.</p> <p>For each point on the grid, the gradient is calculated for the 26 nearest  neighbors, and the neighbor with the steepest gradient is selected as the  next point in the path. This path is followed until a maximum is reached or a previous point in the path is hit. In the former case, all of the points in the path are assigned to the maximum, and in the latter they are assigned to the same maximum as the colliding path.</p> <p>Reference</p> <p>G. Henkelman, A. Arnaldsson, and H. J\u00f3nsson, A fast and robust algorithm for Bader decomposition of charge density, Comput. Mater. Sci. 36, 354-360 (2006)</p>"},{"location":"implementation/#benchmarks","title":"Benchmarks","text":"SpeedConvergenceMemoryOrientationCalculation Details <p>BaderKit shows improved speeds for all methods. The <code>neargrid-weight</code> method adds very little additional time over the original <code>neargrid</code> method. In all cases, loading the charge density from file makes up a bulk of the calculation, resulting in relatively small differences in each methods speed.</p> <p></p> <p>As expected from their original papers, the <code>weight</code> method converges first followed by the <code>neargrid</code> method. The <code>ongrid</code> method does not converge even at a resolution &gt;150000 pts/\u00c5<sup>3</sup>. Our own <code>neargrid-weight</code> method converges at a similar resolution as the <code>weight</code> method.</p> <p></p> <p>BaderKit uses more memory than the original Fortran code in all cases. This is largely due the need to store chunks of data for parallelization. We hope to improve this in the future.</p> <p></p> <p>The <code>neargrid</code>, <code>weight</code>, and <code>neargrid-weight</code> methods show minimal variance with orientation (&lt;0.001 e<sup>-</sup>), while the <code>ongrid</code> method shows a large bias.</p> <p>Speed, convergence, and memory benchmarks were performed on a conventional cubic 8 atom NaCl structure at varying grid densities. The charge density was calculated using the Vienna Ab-initio Simulation Package (VASP) with the PBE GGA density functional, an energy cutoff of 372.85 eV, a 3x3x3 Monkhorst\u2013Pack k-point mesh, and VASP's default GW pseudo-potentials. The unit cell relaxed to a lattice size of 5.53 \u00c5.</p> <p>Orientation benchmarks were run on a water molecule in a cubic lattice with 270 grid points  along each 8.04 \u00c5 axis. Calculations were performed using VASP, PBE GGA density functional, an energy cutoff of 400 eV, a 2x2x2 Monkhorst\u2013Pack k-point mesh, and VASP's default PBE pseudo-potentials.</p> <p>In all cases, the total charge density including the frozen atomic cores was used as the reference grid as suggested in our documentation. This is necessary for accuracy, but results in increased runtme due to the need to load two, possibly very large, files.</p> <p>All bader calculations were performed using a AMD Ryzen\u2122 Threadripper\u2122 1950X CPU with 16 cores (2 threads per core).</p> <p>Speed benchmarks were run 10 times and the average taken to account for minor fluctuations in computational time. Speed tests were run through the command line to capture the entire workflow including file read/write, basin assignment, and atom assignment. The systematic shift in all BaderKit methods is due to the initialization of Python's interpreter.    </p>"},{"location":"implementation/#implementation-differences","title":"Implementation Differences","text":"All MethodsOngridNeargridWeight <ul> <li> <p>Maxima/Basin Reduction: In highly symmetric systems it is common for local maxima to be positioned exactly between two or more grid points. This results in adjacent grid points with the same value. The Henkelman group's code treats these as individual maxima/basins, while we combine them to the correct single maximum/basin.</p> </li> <li> <p>Pointers Over Paths: Except for in the <code>weight</code> method, the Henkelman code starts at an arbitrary point and climbs a path to a maximum, assigning points along the way. This is fast as a serial operation, but is difficult to parallelize due to the reliance on knowledge of previously traversed paths. We instead prefer to assign pointers from each point to its highest neighbor in parallel,  effectively constructing a forest of trees with roots corresponding to basins.  We then utilize a pointer jumping algorithm to efficiently assign each point to its basin.</p> </li> <li> <p>Vacuum: By default we remove grid points below a given tolerance, including all negative values. The Henkelman group's code instead removes points with an absolute value below this tolerance.</p> </li> </ul> <ul> <li>Parallelization: As described in All Methods,  we prefer to calculate pointers in parallel and assign basins with a <code>pointer jumping</code> algorithm. In this method we achieve this by calculating the steepest neighbor for each point in parallel rather than the original method of following the steepest neighbors up a path to a maximum.</li> </ul> <ul> <li> <p>Iterative Edge Refinement: The original <code>neargrid</code> paper suggests only one edge refinement is needed. We found this is sometimes not the case, and several refinements may be needed to reach convergence. For example, the original code assigns asymmetrical charges/volumes to symmetrical basins in our test case. We therefore use iterative refinement rather than a single refinement.</p> </li> <li> <p>Parallelization: The original method starts at an arbitrary point and constructs a path traveling up the gradient, assigning points along the way. It then refines the edges once, as they may be slightly misassigned. This refinement is necessary because the gradient adjustments are only truly accurate for the starting point in the path. We therefore abandon the initial assignment entirely, instead calculating pointers from each point to its highest neighbor in parallel and reducing with a <code>pointer jumping</code> algorithm.  These pointers differ from the <code>ongrid</code> method in that they are calculated using  the gradient. The edges are then refined by performing the true hill climbing for each edge point in parallel. The result is identical to the original method with speed comparable to the <code>ongrid</code> method.</p> </li> </ul> <ul> <li> <p>Weight Basin Reduction: The weight method uses a voronoi cell to determine  neighbors and reduce orientation errors. This results in some points being  labeled as maxima when they have a lower value than one of their 26 nearest neighbors.  This results in many unrealistic basins which can significantly slow down the calculation. We remove these maxima by assigning their full weight to the highest neighbor.</p> </li> <li> <p>Parallelization: Though the <code>weight</code> method involves calculating weights that are dependent on one another, most of the components of the 'flux' used in this calculation are independent. We take advantage of this and calculate the  flux in parallel. This comes at the cost of storing the  information in memory using an array that is several times the size of the  original grid.</p> </li> <li> <p>Reversed Assignment: Calculating the weight from high to low requires one to track the partial basin assignments of each point for reference later. We instead move over the data from low to high, adding the weighted charge of each point to its higher neighbors. In this way, the charge/volume is accumulated without the need to track each points partial assignments.</p> </li> <li> <p>Basin Labels: Because the weight method provides fractional assignments, it is difficult to represent each points basin assignment. We opt to assign each point to its neighbor with the highest flux. This results in basin labels for each point, but they are only about as accurate as the <code>ongrid</code> method.</p> </li> <li> <p>Unknown Bug-fix: We have found that in some cases, particularly in non-cubic systems, the results of our method vary from the original. In particular we often find fewer local maxima (prior to any maxima reduction). As an example, the Henkelman code finds 8 local maxima in our test system while our own code finds 6. After careful examination, we are quite sure the 6 maxima are correct. We are unsure what causes this bug, but it also appears to affect the calculated positions of the basin maxima in the <code>BCF.dat</code> output for all systems and slightly affect the calculated charges in many systems.</p> </li> </ul>"},{"location":"api_reference/core/bader/","title":"Bader","text":"<p>Class for running Bader analysis on a regular grid. For information on each method, see our docs</p> <p>Parameters:</p> Name Type Description Default <code>charge_grid</code> <code>Grid</code> <p>A Grid object with the charge density that will be integrated.</p> required <code>reference_grid</code> <code>Grid | None</code> <p>A Grid object whose values will be used to construct the basins. If None, defaults to the charge_grid.</p> <code>None</code> <code>method</code> <code>str | Method</code> <p>The algorithm to use for generating bader basins.</p> <code>weight</code> <code>vacuum_tol</code> <code>float | bool</code> <p>If a float is provided, this is the value below which a point will be considered part of the vacuum. If a bool is provided, no vacuum will be used on False, and the default tolerance will be used on True.</p> <code>0.001</code> <code>normalize_vacuum</code> <code>bool | None</code> <p>Whether or not the reference data needs to be converted to real space units for vacuum tolerance comparison. This should be True for charge densities and False for the ELF. If None, the setting will be guessed from the reference grid's data type.</p> <code>None</code> <code>basin_tol</code> <code>float</code> <p>The value below which a basin will not be considered significant. This is used only used to avoid writing out data that is likely not valuable.</p> <code>0.001</code> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>class Bader:\n    \"\"\"\n    Class for running Bader analysis on a regular grid. For information on each\n    method, see our [docs](https://sweav02.github.io/baderkit/)\n\n    Parameters\n    ----------\n    charge_grid : Grid\n        A Grid object with the charge density that will be integrated.\n    reference_grid : Grid | None\n        A Grid object whose values will be used to construct the basins. If\n        None, defaults to the charge_grid.\n    method : str | Method, optional\n        The algorithm to use for generating bader basins.\n    vacuum_tol: float | bool, optional\n        If a float is provided, this is the value below which a point will\n        be considered part of the vacuum. If a bool is provided, no vacuum\n        will be used on False, and the default tolerance will be used on True.\n    normalize_vacuum: bool, optional\n        Whether or not the reference data needs to be converted to real space\n        units for vacuum tolerance comparison. This should be True for charge\n        densities and False for the ELF. If None, the setting will be guessed\n        from the reference grid's data type.\n    basin_tol: float, optional\n        The value below which a basin will not be considered significant. This\n        is used only used to avoid writing out data that is likely not valuable.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        charge_grid: Grid,\n        reference_grid: Grid | None = None,\n        method: str | Method = Method.weight,\n        vacuum_tol: float | bool = 1.0e-3,\n        normalize_vacuum: bool | None = None,\n        basin_tol: float = 1.0e-3,\n    ):\n\n        # ensure th method is valid\n        valid_methods = [m.value for m in Method]\n        if isinstance(method, Method):\n            self._method = method\n        elif method in valid_methods:\n            self._method = Method(method)\n        else:\n            raise ValueError(\n                f\"Invalid method '{method}'. Available options are: {valid_methods}\"\n            )\n\n        self._charge_grid = charge_grid\n\n        # if no reference is provided, use the base charge grid\n        if reference_grid is None:\n            reference_grid = charge_grid.copy()\n        self._reference_grid = reference_grid\n\n        # guess whether the reference should be scaled for vacuum tolerance comparison\n        if normalize_vacuum is None:\n            if reference_grid.data_type == \"elf\":\n                normalize_vacuum = False\n            else:\n                normalize_vacuum = True\n\n        # if vacuum tolerance is True, set it to the same default as above\n        if vacuum_tol is True:\n            self._vacuum_tol = 1.0e-3\n        else:\n            self._vacuum_tol = vacuum_tol\n        self._normalize_vacuum = normalize_vacuum\n        self._basin_tol = basin_tol\n\n        # set hidden class variables. This allows us to cache properties and\n        # still be able to recalculate them if needed, though that should only\n        # be done by advanced users\n        self._reset_properties()\n\n        # whether or not to use overdetermined gradients in neargrid methods.\n        self._use_overdetermined = False\n\n    ###########################################################################\n    # Set Properties\n    ###########################################################################\n    def _reset_properties(\n        self,\n        include_properties: list[str] = None,\n        exclude_properties: list[str] = [],\n    ):\n        # if include properties is not provided, we wnat to reset everything\n        if include_properties is None:\n            include_properties = [\n                # assigned by run_bader\n                \"basin_labels\",\n                \"basin_maxima_frac\",\n                \"basin_maxima_charge_values\",\n                \"basin_maxima_ref_values\",\n                \"basin_maxima_vox\",\n                \"basin_charges\",\n                \"basin_volumes\",\n                \"vacuum_charge\",\n                \"vacuum_volume\",\n                \"significant_basins\",\n                \"vacuum_mask\",\n                \"num_vacuum\",\n                # Assigned by calling the property\n                \"basin_min_surface_distances\",\n                \"basin_avg_surface_distances\",\n                \"basin_edges\",\n                \"atom_edges\",\n                \"structure\",\n                # Assigned by run_atom_assignment\n                \"basin_atoms\",\n                \"basin_atom_dists\",\n                \"atom_labels\",\n                \"atom_charges\",\n                \"atom_volumes\",\n                \"atom_min_surface_distances\",\n                \"atom_avg_surface_distances\" \"total_electron_number\",\n            ]\n        # get our final list of properties\n        reset_properties = [\n            i for i in include_properties if i not in exclude_properties\n        ]\n        # set corresponding hidden variable to None\n        for prop in reset_properties:\n            setattr(self, f\"_{prop}\", None)\n\n    @property\n    def charge_grid(self) -&gt; Grid:\n        \"\"\"\n\n        Returns\n        -------\n        Grid\n            A Grid object with the charge density that will be integrated.\n\n        \"\"\"\n        return self._charge_grid\n\n    @charge_grid.setter\n    def charge_grid(self, value: Grid):\n        self._charge_grid = value\n        self._reset_properties()\n\n    @property\n    def reference_grid(self) -&gt; Grid:\n        \"\"\"\n\n        Returns\n        -------\n        Grid\n            A grid object whose values will be used to construct the basins.\n\n        \"\"\"\n        return self._reference_grid\n\n    @reference_grid.setter\n    def reference_grid(self, value: Grid):\n        self._reference_grid = value\n        self._reset_properties()\n\n    @property\n    def method(self) -&gt; str:\n        \"\"\"\n\n        Returns\n        -------\n        str\n            The algorithm to use for generating bader basins. If None, defaults\n            to neargrid.\n\n        \"\"\"\n        return self._method\n\n    @method.setter\n    def method(self, value: str | Method):\n        # Support both Method instances and their string values\n        valid_values = [m.value for m in Method]\n        if isinstance(value, Method):\n            self._method = value\n        elif value in valid_values:\n            self._method = Method(value)\n        else:\n            raise ValueError(\n                f\"Invalid method '{value}'. Available options are: {valid_values}\"\n            )\n        self._reset_properties(exclude_properties=[\"vacuum_mask\", \"num_vacuum\"])\n\n    @property\n    def vacuum_tol(self) -&gt; float | bool:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The value below which a point will be considered part of the vacuum.\n            The default is 0.001.\n\n        \"\"\"\n        return self._vacuum_tol\n\n    @vacuum_tol.setter\n    def vacuum_tol(self, value: float | bool):\n        self._vacuum_tol = value\n        self._reset_properties()\n        # TODO: only reset everything if the vacuum actually changes\n\n    @property\n    def normalize_vacuum(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            Whether or not the reference data needs to be converted to real space\n            units for vacuum tolerance comparison. This should be set to True if\n            the data follows VASP's CHGCAR standards, but False if the data should\n            be compared as is (e.g. in ELFCARs)\n\n        \"\"\"\n        return self._normalize_vacuum\n\n    @normalize_vacuum.setter\n    def normalize_vacuum(self, value: bool) -&gt; bool:\n        self._normalize_vacuum = value\n        self._reset_properties()\n        # TODO: only reset everything if the vacuum actually changes\n\n    @property\n    def basin_tol(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The value below which a basin will not be considered significant. This\n            is used to avoid writing out data that is likely not valuable.\n            The default is 0.001.\n\n        \"\"\"\n        return self._basin_tol\n\n    @basin_tol.setter\n    def basin_tol(self, value: float):\n        self._basin_tol = value\n        self._reset_properties(include_properties=[\"significant_basins\"])\n\n    ###########################################################################\n    # Calculated Properties\n    ###########################################################################\n\n    @property\n    def basin_labels(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            A 3D array of the same shape as the reference grid with entries\n            representing the basin the voxel belongs to. Note that for some\n            methods (e.g. weight) the voxels have weights for each basin.\n            These will be stored in the basin_weights property.\n\n        \"\"\"\n        if self._basin_labels is None:\n            self.run_bader()\n        return self._basin_labels\n\n    @property\n    def basin_maxima_frac(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The fractional coordinates of each attractor.\n\n        \"\"\"\n        if self._basin_maxima_frac is None:\n            self.run_bader()\n        return self._basin_maxima_frac\n\n    @property\n    def basin_maxima_charge_values(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The charge data value at each maximum. If the maximum is\n            off grid, this value will be interpolated.\n\n        \"\"\"\n        if self._basin_maxima_charge_values is None:\n            self._basin_maxima_charge_values = self.charge_grid.values_at(\n                self.basin_maxima_frac\n            )\n        return self._basin_maxima_charge_values\n\n    @property\n    def basin_maxima_ref_values(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The reference data value at each maximum. If the maximum is\n            off grid, this value will be interpolated.\n\n        \"\"\"\n        if self._basin_maxima_ref_values is None:\n            # we get these values during each bader method anyways, so\n            # we run this here.\n            self.run_bader()\n        return self._basin_maxima_ref_values\n\n    @property\n    def basin_maxima_vox(self) -&gt; NDArray[int]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[int]\n            The voxel coordinates of each attractor. There may be more of these\n            than the fractional coordinates, as some maxima sit exactly between\n            several voxels.\n\n        \"\"\"\n        if self._basin_maxima_vox is None:\n            self.run_bader()\n        return self._basin_maxima_vox\n\n    @property\n    def basin_charges(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The charges assigned to each attractor.\n\n        \"\"\"\n        if self._basin_charges is None:\n            self.run_bader()\n        return self._basin_charges\n\n    @property\n    def basin_volumes(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The volume assigned to each attractor.\n\n        \"\"\"\n        if self._basin_volumes is None:\n            self.run_bader()\n        return self._basin_volumes\n\n    @property\n    def basin_min_surface_distances(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The distance from each basin maxima to the nearest point on\n            the basins surface\n\n        \"\"\"\n        if self._basin_min_surface_distances is None:\n            self._get_basin_surface_distances()\n        return self._basin_min_surface_distances\n\n    @property\n    def basin_avg_surface_distances(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The avg distance from each basin maxima to the edges of its basin\n\n        \"\"\"\n        if self._basin_avg_surface_distances is None:\n            self._get_basin_surface_distances()\n        return self._basin_avg_surface_distances\n\n    @property\n    def basin_atoms(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The atom index of each basin is assigned to.\n\n        \"\"\"\n        if self._basin_atoms is None:\n            self.run_atom_assignment()\n        return self._basin_atoms\n\n    @property\n    def basin_atom_dists(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The distance from each attractor to the nearest atom\n\n        \"\"\"\n        if self._basin_atom_dists is None:\n            self.run_atom_assignment()\n        return self._basin_atom_dists\n\n    @property\n    def significant_basins(self) -&gt; NDArray[bool]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[bool]\n            A 1D mask with an entry for each basin that is True where basins\n            are significant.\n\n        \"\"\"\n        if self._significant_basins is None:\n            self._significant_basins = self.basin_charges &gt; self.basin_tol\n        return self._significant_basins\n\n    @property\n    def atom_labels(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            A 3D array of the same shape as the reference grid with entries\n            representing the atoms the voxel belongs to.\n\n            Note that for some methods (e.g. weight) some voxels have fractional\n            assignments for each basin and this will not represent exactly how\n            charges are assigned.\n\n        \"\"\"\n        if self._atom_labels is None:\n            self.run_atom_assignment()\n        return self._atom_labels\n\n    @property\n    def atom_charges(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The charge assigned to each atom\n\n        \"\"\"\n        if self._atom_charges is None:\n            self.run_atom_assignment()\n        return self._atom_charges\n\n    @property\n    def atom_volumes(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The volume assigned to each atom\n\n        \"\"\"\n        if self._atom_volumes is None:\n            self.run_atom_assignment()\n        return self._atom_volumes\n\n    @property\n    def atom_min_surface_distances(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The distance from each atom to the nearest point on the atoms surface.\n\n        \"\"\"\n        if self._atom_min_surface_distances is None:\n            self._get_atom_surface_distances()\n        return self._atom_min_surface_distances\n\n    @property\n    def atom_avg_surface_distances(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The avg distance from each atom to the edges of its basin\n\n        \"\"\"\n        if self._atom_avg_surface_distances is None:\n            self._get_basin_surface_distances()\n        return self._atom_avg_surface_distances\n\n    @property\n    def structure(self) -&gt; Structure:\n        \"\"\"\n\n        Returns\n        -------\n        Structure\n            The pymatgen structure basins are assigned to.\n\n        \"\"\"\n        if self._structure is None:\n            self._structure = self.reference_grid.structure.copy()\n            self._structure.relabel_sites(ignore_uniq=True)\n        return self._structure\n\n    @property\n    def basin_edges(self) -&gt; NDArray[np.bool_]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[np.bool_]\n            A mask with the same shape as the input grids that is True at points\n            on basin edges.\n\n        \"\"\"\n        if self._basin_edges is None:\n            self._basin_edges = get_edges(\n                labeled_array=self.basin_labels,\n                vacuum_mask=np.zeros(self.basin_labels.shape, dtype=np.bool_),\n                neighbor_transforms=self.reference_grid.point_neighbor_transforms[0],\n            )\n        return self._basin_edges\n\n    @property\n    def atom_edges(self) -&gt; NDArray[np.bool_]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[np.bool_]\n            A mask with the same shape as the input grids that is True at points\n            on atom edges.\n\n        \"\"\"\n        if self._atom_edges is None:\n            self._atom_edges = get_edges(\n                labeled_array=self.atom_labels,\n                vacuum_mask=np.zeros(self.atom_labels.shape, dtype=np.bool_),\n                neighbor_transforms=self.reference_grid.point_neighbor_transforms[0],\n            )\n        return self._atom_edges\n\n    @property\n    def vacuum_charge(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The charge assigned to the vacuum.\n\n        \"\"\"\n        if self._vacuum_charge is None:\n            self.run_bader()\n        return self._vacuum_charge\n\n    @property\n    def vacuum_volume(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total volume assigned to the vacuum.\n\n        \"\"\"\n        if self._vacuum_volume is None:\n            self.run_bader()\n        return self._vacuum_volume\n\n    @property\n    def vacuum_mask(self) -&gt; NDArray[bool]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[bool]\n            A mask representing the voxels that belong to the vacuum.\n\n        \"\"\"\n        if self._vacuum_mask is None:\n            # if vacuum tolerance is set to False, ignore vacuum\n            if self.vacuum_tol is False:\n                self._vacuum_mask = np.zeros_like(\n                    self.reference_grid.total, dtype=np.bool_\n                )\n            else:\n                if self.normalize_vacuum:\n                    self._vacuum_mask = self.reference_grid.total &lt; (\n                        self.vacuum_tol * self.structure.volume\n                    )\n                else:\n                    self._vacuum_mask = self.reference_grid.total &lt; self.vacuum_tol\n        return self._vacuum_mask\n\n    @property\n    def num_vacuum(self) -&gt; int:\n        \"\"\"\n\n        Returns\n        -------\n        int\n            The number of vacuum points in the array\n\n        \"\"\"\n        if self._num_vacuum is None:\n            self._num_vacuum = np.count_nonzero(self.vacuum_mask)\n        return self._num_vacuum\n\n    @property\n    def total_electron_number(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The total number of electrons in the system calculated from the\n            atom charges and vacuum charge. If this does not match the true\n            total electron number within reasonable floating point error,\n            there is a major problem.\n\n        \"\"\"\n\n        return self.atom_charges.sum() + self.vacuum_charge\n\n    @staticmethod\n    def all_methods() -&gt; list[str]:\n        \"\"\"\n\n        Returns\n        -------\n        list[str]\n            A list of the available methods.\n\n        \"\"\"\n\n        return [i.value for i in Method]\n\n    @property\n    def results_summary(self) -&gt; dict:\n        \"\"\"\n\n        Returns\n        -------\n        results_dict : dict\n            A dictionary summary of all results\n\n        \"\"\"\n        results_dict = {\n            \"method\": self.method,\n            \"basin_maxima_frac\": self.basin_maxima_frac,\n            \"basin_maxima_vox\": self.basin_maxima_vox,\n            \"basin_charges\": self.basin_charges,\n            \"basin_volumes\": self.basin_volumes,\n            \"basin_min_surface_distances\": self.basin_min_surface_distances,\n            \"basin_avg_surface_distances\": self.basin_avg_surface_distances,\n            \"basin_atoms\": self.basin_atoms,\n            \"basin_atom_dists\": self.basin_atom_dists,\n            \"atom_charges\": self.atom_charges,\n            \"atom_volumes\": self.atom_volumes,\n            \"atom_min_surface_distances\": self.atom_min_surface_distances,\n            \"atom_avg_surface_distances\": self.atom_avg_surface_distances,\n            \"structure\": self.structure,\n            \"vacuum_charge\": self.vacuum_charge,\n            \"vacuum_volume\": self.vacuum_volume,\n            \"significant_basins\": self.significant_basins,\n            \"total_electron_num\": self.total_electron_number,\n        }\n        return results_dict\n\n    def run_bader(self) -&gt; None:\n        \"\"\"\n        Runs the entire Bader process and saves results to class variables.\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        t0 = time.time()\n        logging.info(f\"Beginning Bader Algorithm Using '{self.method.name}' Method\")\n        # Normalize the method name to a module and class name\n        module_name = self.method.replace(\n            \"-\", \"_\"\n        )  # 'pseudo-neargrid' -&gt; 'pseudo_neargrid'\n        class_name = (\n            \"\".join(part.capitalize() for part in module_name.split(\"_\")) + \"Method\"\n        )\n\n        # import method\n        mod = importlib.import_module(f\"baderkit.core.methods.{module_name}\")\n        Method = getattr(mod, class_name)\n\n        # Instantiate and run the selected method\n        method = Method(\n            charge_grid=self.charge_grid,\n            reference_grid=self.reference_grid,\n            vacuum_mask=self.vacuum_mask,\n            num_vacuum=self.num_vacuum,\n        )\n        if self._use_overdetermined:\n            method._use_overdetermined = True\n        results = method.run()\n\n        for key, value in results.items():\n            setattr(self, f\"_{key}\", value)\n        t1 = time.time()\n        logging.info(\"Bader Algorithm Complete\")\n        logging.info(f\"Time: {round(t1-t0,2)}\")\n\n    def assign_basins_to_structure(self, structure: Structure):\n\n        # Get basin and atom frac coords\n        basins = self.basin_maxima_frac  # (N_basins, 3)\n        atoms = structure.frac_coords  # (N_atoms, 3)\n\n        # get lattice matrix and number of atoms/basins\n        L = structure.lattice.matrix  # (3, 3)\n        N_basins = len(basins)\n\n        # Vectorized deltas, minimum\u2011image wrapping\n        diffs = atoms[None, :, :] - basins[:, None, :]\n        diffs += np.where(diffs &lt;= -0.5, 1, 0)\n        diffs -= np.where(diffs &gt;= 0.5, 1, 0)\n\n        # Cartesian diffs &amp; distances\n        cart = np.einsum(\"bij,jk-&gt;bik\", diffs, L)\n        dists = np.linalg.norm(cart, axis=2)\n\n        # Basin\u2192atom assignment &amp; distances\n        basin_atoms = np.argmin(dists, axis=1)  # (N_basins,)\n        basin_atom_dists = dists[np.arange(N_basins), basin_atoms]  # (N_basins,)\n\n        # Atom labels per grid point\n        # NOTE: append -1 so that vacuum gets assigned to -1 in the atom_labels\n        # array\n        basin_atoms = np.insert(basin_atoms, len(basin_atoms), -1)\n        atom_labels = basin_atoms[self.basin_labels]\n\n        return basin_atoms, basin_atom_dists, atom_labels\n\n    def run_atom_assignment(self):\n        \"\"\"\n        Assigns bader basins to this Bader objects structure.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # ensure bader has run (otherwise our time will include the bader time)\n        self.basin_maxima_frac\n\n        # Default structure\n        structure = self.structure\n\n        t0 = time.time()\n        logging.info(\"Assigning Atom Properties\")\n        # get basin assignments for this bader objects structure\n        basin_atoms, basin_atom_dists, atom_labels = self.assign_basins_to_structure(\n            structure\n        )\n\n        # Sum up charges/volumes per atom in one shot. slice with -1 is necessary\n        # to prevent no negative value error\n        atom_charges = np.bincount(\n            basin_atoms[:-1], weights=self.basin_charges, minlength=len(structure)\n        )\n        atom_volumes = np.bincount(\n            basin_atoms[:-1], weights=self.basin_volumes, minlength=len(structure)\n        )\n\n        # Store everything\n        self._basin_atoms = basin_atoms[:-1]\n        self._basin_atom_dists = basin_atom_dists\n        self._atom_labels = atom_labels\n        self._atom_charges = atom_charges\n        self._atom_volumes = atom_volumes\n        logging.info(\"Atom Assignment Finished\")\n        t1 = time.time()\n        logging.info(f\"Time: {round(t1-t0, 2)}\")\n\n    def _get_atom_surface_distances(self):\n        \"\"\"\n        Calculates the distance from each atom to the nearest surface. This is\n        automatically called during the atom assignment and generally should\n        not be called manually.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        self._atom_min_surface_distances, self._atom_avg_surface_distances = (\n            get_min_avg_surface_dists(\n                labels=self.atom_labels,\n                frac_coords=self.structure.frac_coords,\n                edge_mask=self.atom_edges,\n                matrix=self.reference_grid.matrix,\n                max_value=np.max(self.structure.lattice.abc) * 2,\n            )\n        )\n\n    def _get_basin_surface_distances(self):\n        \"\"\"\n        Calculates the distance from each basin maxima to the nearest surface.\n        This is automatically called during the atom assignment and generally\n        should not be called manually.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # get the minimum distances\n        self._basin_min_surface_distances, self._basin_avg_surface_distances = (\n            get_min_avg_surface_dists(\n                labels=self.basin_labels,\n                frac_coords=self.basin_maxima_frac,\n                edge_mask=self.basin_edges,\n                matrix=self.reference_grid.matrix,\n                max_value=np.max(self.structure.lattice.abc) * 2,\n            )\n        )\n\n    @classmethod\n    def from_vasp(\n        cls,\n        charge_filename: Path | str = \"CHGCAR\",\n        reference_filename: Path | None | str = None,\n        total_only: bool = True,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Creates a Bader class object from VASP files.\n\n        Parameters\n        ----------\n        charge_filename : Path | str, optional\n            The path to the CHGCAR like file that will be used for summing charge.\n            The default is \"CHGCAR\".\n        reference_filename : Path | None | str, optional\n            The path to CHGCAR like file that will be used for partitioning.\n            If None, the charge file will be used for partitioning.\n        total_only: bool\n            If true, only the first set of data in the file will be read. This\n            increases speed and reduced memory usage as the other data is typically\n            not used.\n            Defaults to True.\n        **kwargs : dict\n            Keyword arguments to pass to the Bader class.\n\n        Returns\n        -------\n        Self\n            A Bader class object.\n\n        \"\"\"\n        charge_grid = Grid.from_vasp(charge_filename, total_only=total_only)\n        if reference_filename is None:\n            reference_grid = None\n        else:\n            reference_grid = Grid.from_vasp(reference_filename, total_only=total_only)\n\n        return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n\n    @classmethod\n    def from_cube(\n        cls,\n        charge_filename: Path | str,\n        reference_filename: Path | None | str = None,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Creates a Bader class object from .cube files.\n\n        Parameters\n        ----------\n        charge_filename : Path | str, optional\n            The path to the .cube file that will be used for summing charge.\n        reference_filename : Path | None | str, optional\n            The path to .cube file that will be used for partitioning.\n            If None, the charge file will be used for partitioning.\n        **kwargs : dict\n            Keyword arguments to pass to the Bader class.\n\n        Returns\n        -------\n        Self\n            A Bader class object.\n\n        \"\"\"\n        charge_grid = Grid.from_cube(charge_filename)\n        if reference_filename is None:\n            reference_grid = None\n        else:\n            reference_grid = Grid.from_cube(reference_filename)\n        return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n\n    @classmethod\n    def from_dynamic(\n        cls,\n        charge_filename: Path | str,\n        reference_filename: Path | None | str = None,\n        format: Literal[\"vasp\", \"cube\", None] = None,\n        total_only: bool = True,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Creates a Bader class object from VASP or .cube files. If no format is\n        provided the method will automatically try and determine the file type\n        from the name\n\n        Parameters\n        ----------\n        charge_filename : Path | str\n            The path to the file containing the charge density that will be\n            integrated.\n        reference_filename : Path | None | str, optional\n            The path to the file that will be used for partitioning.\n            If None, the charge file will be used for partitioning.\n        format : Literal[\"vasp\", \"cube\", None], optional\n            The format of the grids to read in. If None, the formats will be\n            guessed from the file names.\n        total_only: bool\n            If true, only the first set of data in the file will be read. This\n            increases speed and reduced memory usage as the other data is typically\n            not used. This is only used if the file format is determined to be\n            VASP, as cube files are assumed to contain only one set of data.\n            Defaults to True.\n        **kwargs : dict\n            Keyword arguments to pass to the Bader class.\n\n        Returns\n        -------\n        Self\n            A Bader class object.\n\n        \"\"\"\n\n        charge_grid = Grid.from_dynamic(\n            charge_filename, format=format, total_only=total_only\n        )\n        if reference_filename is None:\n            reference_grid = None\n        else:\n            reference_grid = Grid.from_dynamic(\n                reference_filename, format=format, total_only=total_only\n            )\n        return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n\n    def copy(self) -&gt; Self:\n        \"\"\"\n\n        Returns\n        -------\n        Self\n            A deep copy of this Bader object.\n\n        \"\"\"\n        return copy.deepcopy(self)\n\n    def write_basin_volumes(\n        self,\n        basin_indices: NDArray,\n        directory: str | Path = None,\n        write_reference: bool = False,\n        output_format: str | Format = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes bader basins to vasp-like files. Points belonging to the basin\n        will have values from the charge or reference grid, and all other points\n        will be 0.\n\n        Parameters\n        ----------\n        basin_indices : NDArray\n            The list of basin indices to write\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # get the data to use\n        if write_reference:\n            data_array = self.reference_grid.total\n            data_type = self.reference_grid.data_type\n        else:\n            data_array = self.charge_grid.total\n            data_type = self.charge_grid.data_type\n\n        if directory is None:\n            directory = Path(\".\")\n        for basin in basin_indices:\n            # get a mask everywhere but the requested basin\n            mask = self.basin_labels != basin\n            # copy data to avoid overwriting. Set data off of basin to 0\n            data_array_copy = data_array.copy()\n            data_array_copy[mask] = 0.0\n            grid = Grid(\n                structure=self.structure,\n                data={\"total\": data_array_copy},\n                data_type=data_type,\n            )\n            file_path = directory / f\"{grid.data_type.prefix}_b{basin}\"\n            # write file\n            grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n\n    def write_all_basin_volumes(\n        self,\n        directory: str | Path = None,\n        write_reference: bool = False,\n        output_format: str | Format = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes all bader basins to vasp-like files. Points belonging to the basin\n        will have values from the charge or reference grid, and all other points\n        will be 0.\n\n        Parameters\n        ----------\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        basin_indices = np.where(self.significant_basins)[0]\n        self.write_basin_volumes(\n            basin_indices=basin_indices,\n            directory=directory,\n            write_reference=write_reference,\n            output_format=output_format,\n            **writer_kwargs,\n        )\n\n    def write_basin_volumes_sum(\n        self,\n        basin_indices: NDArray,\n        directory: str | Path = None,\n        write_reference: bool = False,\n        output_format: str | Format = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes the union of the provided bader basins to vasp-like files.\n        Points belonging to the basins will have values from the charge or\n        reference grid, and all other points will be 0.\n\n        Parameters\n        ----------\n        basin_indices : NDArray\n            The list of basin indices to sum and write\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # get the data to use\n        if write_reference:\n            data_array = self.reference_grid.total\n            data_type = self.reference_grid.data_type\n        else:\n            data_array = self.charge_grid.total\n            data_type = self.charge_grid.data_type\n\n        if directory is None:\n            directory = Path(\".\")\n        # create a mask including each of the requested basins\n        mask = np.isin(self.basin_labels, basin_indices)\n        # copy data to avoid overwriting. Set data off of basin to 0\n        data_array_copy = data_array.copy()\n        data_array_copy[~mask] = 0.0\n        grid = Grid(\n            structure=self.structure,\n            data={\"total\": data_array_copy},\n            data_type=data_type,\n        )\n        file_path = directory / f\"{grid.data_type.prefix}_bsum\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n\n    def write_atom_volumes(\n        self,\n        atom_indices: NDArray,\n        directory: str | Path = None,\n        write_reference: bool = False,\n        output_format: str | Format = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes atomic basins to vasp-like files. Points belonging to the atom\n        will have values from the charge or reference grid, and all other points\n        will be 0.\n\n        Parameters\n        ----------\n        atom_indices : NDArray\n            The list of atom indices to write\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # get the data to use\n        if write_reference:\n            data_array = self.reference_grid.total\n            data_type = self.reference_grid.data_type\n        else:\n            data_array = self.charge_grid.total\n            data_type = self.charge_grid.data_type\n\n        if directory is None:\n            directory = Path(\".\")\n        for atom_index in atom_indices:\n            # get a mask everywhere but the requested basin\n            mask = self.atom_labels != atom_index\n            # copy data to avoid overwriting. Set data off of basin to 0\n            data_array_copy = data_array.copy()\n            data_array_copy[mask] = 0.0\n            grid = Grid(\n                structure=self.structure,\n                data={\"total\": data_array_copy},\n                data_type=data_type,\n            )\n            file_path = directory / f\"{grid.data_type.prefix}_a{atom_index}\"\n            # write file\n            grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n\n    def write_all_atom_volumes(\n        self,\n        directory: str | Path = None,\n        write_reference: bool = False,\n        output_format: str | Format = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes all atomic basins to vasp-like files. Points belonging to the atom\n        will have values from the charge or reference grid, and all other points\n        will be 0.\n\n        Parameters\n        ----------\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        atom_indices = np.array(range(len(self.structure)))\n        self.write_atom_volumes(\n            atom_indices=atom_indices,\n            directory=directory,\n            write_reference=write_reference,\n            output_format=output_format,\n            **writer_kwargs,\n        )\n\n    def write_atom_volumes_sum(\n        self,\n        atom_indices: NDArray,\n        directory: str | Path = None,\n        write_reference: bool = False,\n        output_format: str | Format = None,\n        **writer_kwargs,\n    ):\n        \"\"\"\n        Writes the union of the provided atom basins to vasp-like files.\n        Points belonging to the atoms will have values from the charge or\n        reference grid, and all other points will be 0.\n\n        Parameters\n        ----------\n        atom_indices : NDArray\n            The list of atom indices to sum and write\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n        write_reference : bool, optional\n            Whether or not to write the reference data rather than the charge data.\n            Default is False.\n        output_format : str | Format, optional\n            The format to write with. If None, writes to source format stored in\n            the Grid objects metadata.\n            Defaults to None.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # get the data to use\n        if write_reference:\n            data_array = self.reference_grid.total\n            data_type = self.reference_grid.data_type\n        else:\n            data_array = self.charge_grid.total\n            data_type = self.charge_grid.data_type\n\n        if directory is None:\n            directory = Path(\".\")\n        mask = np.isin(self.atom_labels, atom_indices)\n        data_array_copy = data_array.copy()\n        data_array_copy[~mask] = 0.0\n        grid = Grid(\n            structure=self.structure,\n            data={\"total\": data_array_copy},\n            data_type=data_type,\n        )\n        file_path = directory / f\"{grid.data_type.prefix}_asum\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n\n    def get_atom_results_dataframe(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Collects a summary of results for the atoms in a pandas DataFrame.\n\n        Returns\n        -------\n        atoms_df : pd.DataFrame\n            A table summarizing the atomic basins.\n\n        \"\"\"\n        # Get atom results summary\n        atom_frac_coords = self.structure.frac_coords\n        atoms_df = pd.DataFrame(\n            {\n                \"label\": self.structure.labels,\n                \"x\": atom_frac_coords[:, 0],\n                \"y\": atom_frac_coords[:, 1],\n                \"z\": atom_frac_coords[:, 2],\n                \"charge\": self.atom_charges,\n                \"volume\": self.atom_volumes,\n                \"surface_dist\": self.atom_min_surface_distances,\n            }\n        )\n        return atoms_df\n\n    def get_basin_results_dataframe(self):\n        \"\"\"\n        Collects a summary of results for the basins in a pandas DataFrame.\n\n        Returns\n        -------\n        basin_df : pd.DataFrame\n            A table summarizing the basins.\n\n        \"\"\"\n        subset = self.significant_basins\n        basin_frac_coords = self.basin_maxima_frac[subset]\n        basin_df = pd.DataFrame(\n            {\n                \"atoms\": np.array(self.structure.labels)[self.basin_atoms[subset]],\n                \"x\": basin_frac_coords[:, 0],\n                \"y\": basin_frac_coords[:, 1],\n                \"z\": basin_frac_coords[:, 2],\n                \"charge\": self.basin_charges[subset],\n                \"volume\": self.basin_volumes[subset],\n                \"surface_dist\": self.basin_min_surface_distances[subset],\n                \"atom_dist\": self.basin_atom_dists[subset],\n            }\n        )\n        return basin_df\n\n    def write_results_summary(\n        self,\n        directory: Path | str | None = None,\n    ):\n        \"\"\"\n        Writes a summary of atom and basin results to .tsv files.\n\n        Parameters\n        ----------\n        directory : str | Path\n            The directory to write the files in. If None, the active directory\n            is used.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        if directory is None:\n            directory = Path(\".\")\n\n        # Get atom results summary\n        atoms_df = self.get_atom_results_dataframe()\n        formatted_atoms_df = atoms_df.copy()\n        numeric_cols = formatted_atoms_df.select_dtypes(include=\"number\").columns\n        formatted_atoms_df[numeric_cols] = formatted_atoms_df[numeric_cols].map(\n            lambda x: f\"{x:.5f}\"\n        )\n\n        # Get basin results summary\n        basin_df = self.get_basin_results_dataframe()\n        formatted_basin_df = basin_df.copy()\n        numeric_cols = formatted_basin_df.select_dtypes(include=\"number\").columns\n        formatted_basin_df[numeric_cols] = formatted_basin_df[numeric_cols].map(\n            lambda x: f\"{x:.5f}\"\n        )\n\n        # Determine max width per column including header\n        atom_col_widths = {\n            col: max(len(col), formatted_atoms_df[col].map(len).max())\n            for col in atoms_df.columns\n        }\n        basin_col_widths = {\n            col: max(len(col), formatted_basin_df[col].map(len).max())\n            for col in basin_df.columns\n        }\n\n        # Write to file with aligned columns using tab as separator\n        for df, col_widths, name in zip(\n            [formatted_atoms_df, formatted_basin_df],\n            [atom_col_widths, basin_col_widths],\n            [\"bader_atom_summary.tsv\", \"bader_basin_summary.tsv\"],\n        ):\n            # Note what we're writing in log\n            if \"atom\" in name:\n                logging.info(f\"Writing Atom Summary to {name}\")\n            else:\n                logging.info(f\"Writing Basin Summary to {name}\")\n\n            # write output summaries\n            with open(directory / name, \"w\") as f:\n                # Write header\n                header = \"\\t\".join(f\"{col:&lt;{col_widths[col]}}\" for col in df.columns)\n                f.write(header + \"\\n\")\n\n                # Write rows\n                for _, row in df.iterrows():\n                    line = \"\\t\".join(\n                        f\"{val:&lt;{col_widths[col]}}\" for col, val in row.items()\n                    )\n                    f.write(line + \"\\n\")\n                # write vacuum summary to atom file\n                if name == \"bader_atom_summary.tsv\":\n                    f.write(\"\\n\")\n                    f.write(f\"Vacuum Charge:\\t\\t{self.vacuum_charge:.5f}\\n\")\n                    f.write(f\"Vacuum Volume:\\t\\t{self.vacuum_volume:.5f}\\n\")\n                    f.write(f\"Total Electrons:\\t{self.total_electron_number:.5f}\\n\")\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.atom_avg_surface_distances","title":"<code>atom_avg_surface_distances</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The avg distance from each atom to the edges of its basin</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.atom_charges","title":"<code>atom_charges</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The charge assigned to each atom</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.atom_edges","title":"<code>atom_edges</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool_]</code> <p>A mask with the same shape as the input grids that is True at points on atom edges.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.atom_labels","title":"<code>atom_labels</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>A 3D array of the same shape as the reference grid with entries representing the atoms the voxel belongs to.</p> <p>Note that for some methods (e.g. weight) some voxels have fractional assignments for each basin and this will not represent exactly how charges are assigned.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.atom_min_surface_distances","title":"<code>atom_min_surface_distances</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The distance from each atom to the nearest point on the atoms surface.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.atom_volumes","title":"<code>atom_volumes</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The volume assigned to each atom</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_atom_dists","title":"<code>basin_atom_dists</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The distance from each attractor to the nearest atom</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_atoms","title":"<code>basin_atoms</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The atom index of each basin is assigned to.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_avg_surface_distances","title":"<code>basin_avg_surface_distances</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The avg distance from each basin maxima to the edges of its basin</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_charges","title":"<code>basin_charges</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The charges assigned to each attractor.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_edges","title":"<code>basin_edges</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool_]</code> <p>A mask with the same shape as the input grids that is True at points on basin edges.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_labels","title":"<code>basin_labels</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>A 3D array of the same shape as the reference grid with entries representing the basin the voxel belongs to. Note that for some methods (e.g. weight) the voxels have weights for each basin. These will be stored in the basin_weights property.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_maxima_charge_values","title":"<code>basin_maxima_charge_values</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The charge data value at each maximum. If the maximum is off grid, this value will be interpolated.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_maxima_frac","title":"<code>basin_maxima_frac</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The fractional coordinates of each attractor.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_maxima_ref_values","title":"<code>basin_maxima_ref_values</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The reference data value at each maximum. If the maximum is off grid, this value will be interpolated.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_maxima_vox","title":"<code>basin_maxima_vox</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[int]</code> <p>The voxel coordinates of each attractor. There may be more of these than the fractional coordinates, as some maxima sit exactly between several voxels.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_min_surface_distances","title":"<code>basin_min_surface_distances</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The distance from each basin maxima to the nearest point on the basins surface</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_tol","title":"<code>basin_tol</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The value below which a basin will not be considered significant. This is used to avoid writing out data that is likely not valuable. The default is 0.001.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.basin_volumes","title":"<code>basin_volumes</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The volume assigned to each attractor.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.charge_grid","title":"<code>charge_grid</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>Grid</code> <p>A Grid object with the charge density that will be integrated.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.method","title":"<code>method</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The algorithm to use for generating bader basins. If None, defaults to neargrid.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.normalize_vacuum","title":"<code>normalize_vacuum</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>Whether or not the reference data needs to be converted to real space units for vacuum tolerance comparison. This should be set to True if the data follows VASP's CHGCAR standards, but False if the data should be compared as is (e.g. in ELFCARs)</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.num_vacuum","title":"<code>num_vacuum</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The number of vacuum points in the array</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.reference_grid","title":"<code>reference_grid</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>Grid</code> <p>A grid object whose values will be used to construct the basins.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.results_summary","title":"<code>results_summary</code>  <code>property</code>","text":"<p>Returns:</p> Name Type Description <code>results_dict</code> <code>dict</code> <p>A dictionary summary of all results</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.significant_basins","title":"<code>significant_basins</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool]</code> <p>A 1D mask with an entry for each basin that is True where basins are significant.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.structure","title":"<code>structure</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Structure</code> <p>The pymatgen structure basins are assigned to.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.total_electron_number","title":"<code>total_electron_number</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total number of electrons in the system calculated from the atom charges and vacuum charge. If this does not match the true total electron number within reasonable floating point error, there is a major problem.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.vacuum_charge","title":"<code>vacuum_charge</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The charge assigned to the vacuum.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.vacuum_mask","title":"<code>vacuum_mask</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool]</code> <p>A mask representing the voxels that belong to the vacuum.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.vacuum_tol","title":"<code>vacuum_tol</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The value below which a point will be considered part of the vacuum. The default is 0.001.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.vacuum_volume","title":"<code>vacuum_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The total volume assigned to the vacuum.</p>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.all_methods","title":"<code>all_methods()</code>  <code>staticmethod</code>","text":"<p>Returns:</p> Type Description <code>list[str]</code> <p>A list of the available methods.</p> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>@staticmethod\ndef all_methods() -&gt; list[str]:\n    \"\"\"\n\n    Returns\n    -------\n    list[str]\n        A list of the available methods.\n\n    \"\"\"\n\n    return [i.value for i in Method]\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.copy","title":"<code>copy()</code>","text":"<p>Returns:</p> Type Description <code>Self</code> <p>A deep copy of this Bader object.</p> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"\n\n    Returns\n    -------\n    Self\n        A deep copy of this Bader object.\n\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.from_cube","title":"<code>from_cube(charge_filename, reference_filename=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a Bader class object from .cube files.</p> <p>Parameters:</p> Name Type Description Default <code>charge_filename</code> <code>Path | str</code> <p>The path to the .cube file that will be used for summing charge.</p> required <code>reference_filename</code> <code>Path | None | str</code> <p>The path to .cube file that will be used for partitioning. If None, the charge file will be used for partitioning.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the Bader class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A Bader class object.</p> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>@classmethod\ndef from_cube(\n    cls,\n    charge_filename: Path | str,\n    reference_filename: Path | None | str = None,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Creates a Bader class object from .cube files.\n\n    Parameters\n    ----------\n    charge_filename : Path | str, optional\n        The path to the .cube file that will be used for summing charge.\n    reference_filename : Path | None | str, optional\n        The path to .cube file that will be used for partitioning.\n        If None, the charge file will be used for partitioning.\n    **kwargs : dict\n        Keyword arguments to pass to the Bader class.\n\n    Returns\n    -------\n    Self\n        A Bader class object.\n\n    \"\"\"\n    charge_grid = Grid.from_cube(charge_filename)\n    if reference_filename is None:\n        reference_grid = None\n    else:\n        reference_grid = Grid.from_cube(reference_filename)\n    return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.from_dynamic","title":"<code>from_dynamic(charge_filename, reference_filename=None, format=None, total_only=True, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a Bader class object from VASP or .cube files. If no format is provided the method will automatically try and determine the file type from the name</p> <p>Parameters:</p> Name Type Description Default <code>charge_filename</code> <code>Path | str</code> <p>The path to the file containing the charge density that will be integrated.</p> required <code>reference_filename</code> <code>Path | None | str</code> <p>The path to the file that will be used for partitioning. If None, the charge file will be used for partitioning.</p> <code>None</code> <code>format</code> <code>Literal['vasp', 'cube', None]</code> <p>The format of the grids to read in. If None, the formats will be guessed from the file names.</p> <code>None</code> <code>total_only</code> <code>bool</code> <p>If true, only the first set of data in the file will be read. This increases speed and reduced memory usage as the other data is typically not used. This is only used if the file format is determined to be VASP, as cube files are assumed to contain only one set of data. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the Bader class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A Bader class object.</p> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>@classmethod\ndef from_dynamic(\n    cls,\n    charge_filename: Path | str,\n    reference_filename: Path | None | str = None,\n    format: Literal[\"vasp\", \"cube\", None] = None,\n    total_only: bool = True,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Creates a Bader class object from VASP or .cube files. If no format is\n    provided the method will automatically try and determine the file type\n    from the name\n\n    Parameters\n    ----------\n    charge_filename : Path | str\n        The path to the file containing the charge density that will be\n        integrated.\n    reference_filename : Path | None | str, optional\n        The path to the file that will be used for partitioning.\n        If None, the charge file will be used for partitioning.\n    format : Literal[\"vasp\", \"cube\", None], optional\n        The format of the grids to read in. If None, the formats will be\n        guessed from the file names.\n    total_only: bool\n        If true, only the first set of data in the file will be read. This\n        increases speed and reduced memory usage as the other data is typically\n        not used. This is only used if the file format is determined to be\n        VASP, as cube files are assumed to contain only one set of data.\n        Defaults to True.\n    **kwargs : dict\n        Keyword arguments to pass to the Bader class.\n\n    Returns\n    -------\n    Self\n        A Bader class object.\n\n    \"\"\"\n\n    charge_grid = Grid.from_dynamic(\n        charge_filename, format=format, total_only=total_only\n    )\n    if reference_filename is None:\n        reference_grid = None\n    else:\n        reference_grid = Grid.from_dynamic(\n            reference_filename, format=format, total_only=total_only\n        )\n    return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.from_vasp","title":"<code>from_vasp(charge_filename='CHGCAR', reference_filename=None, total_only=True, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a Bader class object from VASP files.</p> <p>Parameters:</p> Name Type Description Default <code>charge_filename</code> <code>Path | str</code> <p>The path to the CHGCAR like file that will be used for summing charge. The default is \"CHGCAR\".</p> <code>'CHGCAR'</code> <code>reference_filename</code> <code>Path | None | str</code> <p>The path to CHGCAR like file that will be used for partitioning. If None, the charge file will be used for partitioning.</p> <code>None</code> <code>total_only</code> <code>bool</code> <p>If true, only the first set of data in the file will be read. This increases speed and reduced memory usage as the other data is typically not used. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the Bader class.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A Bader class object.</p> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>@classmethod\ndef from_vasp(\n    cls,\n    charge_filename: Path | str = \"CHGCAR\",\n    reference_filename: Path | None | str = None,\n    total_only: bool = True,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Creates a Bader class object from VASP files.\n\n    Parameters\n    ----------\n    charge_filename : Path | str, optional\n        The path to the CHGCAR like file that will be used for summing charge.\n        The default is \"CHGCAR\".\n    reference_filename : Path | None | str, optional\n        The path to CHGCAR like file that will be used for partitioning.\n        If None, the charge file will be used for partitioning.\n    total_only: bool\n        If true, only the first set of data in the file will be read. This\n        increases speed and reduced memory usage as the other data is typically\n        not used.\n        Defaults to True.\n    **kwargs : dict\n        Keyword arguments to pass to the Bader class.\n\n    Returns\n    -------\n    Self\n        A Bader class object.\n\n    \"\"\"\n    charge_grid = Grid.from_vasp(charge_filename, total_only=total_only)\n    if reference_filename is None:\n        reference_grid = None\n    else:\n        reference_grid = Grid.from_vasp(reference_filename, total_only=total_only)\n\n    return cls(charge_grid=charge_grid, reference_grid=reference_grid, **kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.get_atom_results_dataframe","title":"<code>get_atom_results_dataframe()</code>","text":"<p>Collects a summary of results for the atoms in a pandas DataFrame.</p> <p>Returns:</p> Name Type Description <code>atoms_df</code> <code>DataFrame</code> <p>A table summarizing the atomic basins.</p> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>def get_atom_results_dataframe(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Collects a summary of results for the atoms in a pandas DataFrame.\n\n    Returns\n    -------\n    atoms_df : pd.DataFrame\n        A table summarizing the atomic basins.\n\n    \"\"\"\n    # Get atom results summary\n    atom_frac_coords = self.structure.frac_coords\n    atoms_df = pd.DataFrame(\n        {\n            \"label\": self.structure.labels,\n            \"x\": atom_frac_coords[:, 0],\n            \"y\": atom_frac_coords[:, 1],\n            \"z\": atom_frac_coords[:, 2],\n            \"charge\": self.atom_charges,\n            \"volume\": self.atom_volumes,\n            \"surface_dist\": self.atom_min_surface_distances,\n        }\n    )\n    return atoms_df\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.get_basin_results_dataframe","title":"<code>get_basin_results_dataframe()</code>","text":"<p>Collects a summary of results for the basins in a pandas DataFrame.</p> <p>Returns:</p> Name Type Description <code>basin_df</code> <code>DataFrame</code> <p>A table summarizing the basins.</p> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>def get_basin_results_dataframe(self):\n    \"\"\"\n    Collects a summary of results for the basins in a pandas DataFrame.\n\n    Returns\n    -------\n    basin_df : pd.DataFrame\n        A table summarizing the basins.\n\n    \"\"\"\n    subset = self.significant_basins\n    basin_frac_coords = self.basin_maxima_frac[subset]\n    basin_df = pd.DataFrame(\n        {\n            \"atoms\": np.array(self.structure.labels)[self.basin_atoms[subset]],\n            \"x\": basin_frac_coords[:, 0],\n            \"y\": basin_frac_coords[:, 1],\n            \"z\": basin_frac_coords[:, 2],\n            \"charge\": self.basin_charges[subset],\n            \"volume\": self.basin_volumes[subset],\n            \"surface_dist\": self.basin_min_surface_distances[subset],\n            \"atom_dist\": self.basin_atom_dists[subset],\n        }\n    )\n    return basin_df\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.run_atom_assignment","title":"<code>run_atom_assignment()</code>","text":"<p>Assigns bader basins to this Bader objects structure.</p> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>def run_atom_assignment(self):\n    \"\"\"\n    Assigns bader basins to this Bader objects structure.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # ensure bader has run (otherwise our time will include the bader time)\n    self.basin_maxima_frac\n\n    # Default structure\n    structure = self.structure\n\n    t0 = time.time()\n    logging.info(\"Assigning Atom Properties\")\n    # get basin assignments for this bader objects structure\n    basin_atoms, basin_atom_dists, atom_labels = self.assign_basins_to_structure(\n        structure\n    )\n\n    # Sum up charges/volumes per atom in one shot. slice with -1 is necessary\n    # to prevent no negative value error\n    atom_charges = np.bincount(\n        basin_atoms[:-1], weights=self.basin_charges, minlength=len(structure)\n    )\n    atom_volumes = np.bincount(\n        basin_atoms[:-1], weights=self.basin_volumes, minlength=len(structure)\n    )\n\n    # Store everything\n    self._basin_atoms = basin_atoms[:-1]\n    self._basin_atom_dists = basin_atom_dists\n    self._atom_labels = atom_labels\n    self._atom_charges = atom_charges\n    self._atom_volumes = atom_volumes\n    logging.info(\"Atom Assignment Finished\")\n    t1 = time.time()\n    logging.info(f\"Time: {round(t1-t0, 2)}\")\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.run_bader","title":"<code>run_bader()</code>","text":"<p>Runs the entire Bader process and saves results to class variables.</p> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>def run_bader(self) -&gt; None:\n    \"\"\"\n    Runs the entire Bader process and saves results to class variables.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    t0 = time.time()\n    logging.info(f\"Beginning Bader Algorithm Using '{self.method.name}' Method\")\n    # Normalize the method name to a module and class name\n    module_name = self.method.replace(\n        \"-\", \"_\"\n    )  # 'pseudo-neargrid' -&gt; 'pseudo_neargrid'\n    class_name = (\n        \"\".join(part.capitalize() for part in module_name.split(\"_\")) + \"Method\"\n    )\n\n    # import method\n    mod = importlib.import_module(f\"baderkit.core.methods.{module_name}\")\n    Method = getattr(mod, class_name)\n\n    # Instantiate and run the selected method\n    method = Method(\n        charge_grid=self.charge_grid,\n        reference_grid=self.reference_grid,\n        vacuum_mask=self.vacuum_mask,\n        num_vacuum=self.num_vacuum,\n    )\n    if self._use_overdetermined:\n        method._use_overdetermined = True\n    results = method.run()\n\n    for key, value in results.items():\n        setattr(self, f\"_{key}\", value)\n    t1 = time.time()\n    logging.info(\"Bader Algorithm Complete\")\n    logging.info(f\"Time: {round(t1-t0,2)}\")\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_all_atom_volumes","title":"<code>write_all_atom_volumes(directory=None, write_reference=False, output_format=None, **writer_kwargs)</code>","text":"<p>Writes all atomic basins to vasp-like files. Points belonging to the atom will have values from the charge or reference grid, and all other points will be 0.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>False</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>def write_all_atom_volumes(\n    self,\n    directory: str | Path = None,\n    write_reference: bool = False,\n    output_format: str | Format = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes all atomic basins to vasp-like files. Points belonging to the atom\n    will have values from the charge or reference grid, and all other points\n    will be 0.\n\n    Parameters\n    ----------\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    atom_indices = np.array(range(len(self.structure)))\n    self.write_atom_volumes(\n        atom_indices=atom_indices,\n        directory=directory,\n        write_reference=write_reference,\n        output_format=output_format,\n        **writer_kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_all_basin_volumes","title":"<code>write_all_basin_volumes(directory=None, write_reference=False, output_format=None, **writer_kwargs)</code>","text":"<p>Writes all bader basins to vasp-like files. Points belonging to the basin will have values from the charge or reference grid, and all other points will be 0.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>False</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>def write_all_basin_volumes(\n    self,\n    directory: str | Path = None,\n    write_reference: bool = False,\n    output_format: str | Format = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes all bader basins to vasp-like files. Points belonging to the basin\n    will have values from the charge or reference grid, and all other points\n    will be 0.\n\n    Parameters\n    ----------\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    basin_indices = np.where(self.significant_basins)[0]\n    self.write_basin_volumes(\n        basin_indices=basin_indices,\n        directory=directory,\n        write_reference=write_reference,\n        output_format=output_format,\n        **writer_kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_atom_volumes","title":"<code>write_atom_volumes(atom_indices, directory=None, write_reference=False, output_format=None, **writer_kwargs)</code>","text":"<p>Writes atomic basins to vasp-like files. Points belonging to the atom will have values from the charge or reference grid, and all other points will be 0.</p> <p>Parameters:</p> Name Type Description Default <code>atom_indices</code> <code>NDArray</code> <p>The list of atom indices to write</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>False</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>def write_atom_volumes(\n    self,\n    atom_indices: NDArray,\n    directory: str | Path = None,\n    write_reference: bool = False,\n    output_format: str | Format = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes atomic basins to vasp-like files. Points belonging to the atom\n    will have values from the charge or reference grid, and all other points\n    will be 0.\n\n    Parameters\n    ----------\n    atom_indices : NDArray\n        The list of atom indices to write\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # get the data to use\n    if write_reference:\n        data_array = self.reference_grid.total\n        data_type = self.reference_grid.data_type\n    else:\n        data_array = self.charge_grid.total\n        data_type = self.charge_grid.data_type\n\n    if directory is None:\n        directory = Path(\".\")\n    for atom_index in atom_indices:\n        # get a mask everywhere but the requested basin\n        mask = self.atom_labels != atom_index\n        # copy data to avoid overwriting. Set data off of basin to 0\n        data_array_copy = data_array.copy()\n        data_array_copy[mask] = 0.0\n        grid = Grid(\n            structure=self.structure,\n            data={\"total\": data_array_copy},\n            data_type=data_type,\n        )\n        file_path = directory / f\"{grid.data_type.prefix}_a{atom_index}\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_atom_volumes_sum","title":"<code>write_atom_volumes_sum(atom_indices, directory=None, write_reference=False, output_format=None, **writer_kwargs)</code>","text":"<p>Writes the union of the provided atom basins to vasp-like files. Points belonging to the atoms will have values from the charge or reference grid, and all other points will be 0.</p> <p>Parameters:</p> Name Type Description Default <code>atom_indices</code> <code>NDArray</code> <p>The list of atom indices to sum and write</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>False</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>def write_atom_volumes_sum(\n    self,\n    atom_indices: NDArray,\n    directory: str | Path = None,\n    write_reference: bool = False,\n    output_format: str | Format = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes the union of the provided atom basins to vasp-like files.\n    Points belonging to the atoms will have values from the charge or\n    reference grid, and all other points will be 0.\n\n    Parameters\n    ----------\n    atom_indices : NDArray\n        The list of atom indices to sum and write\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # get the data to use\n    if write_reference:\n        data_array = self.reference_grid.total\n        data_type = self.reference_grid.data_type\n    else:\n        data_array = self.charge_grid.total\n        data_type = self.charge_grid.data_type\n\n    if directory is None:\n        directory = Path(\".\")\n    mask = np.isin(self.atom_labels, atom_indices)\n    data_array_copy = data_array.copy()\n    data_array_copy[~mask] = 0.0\n    grid = Grid(\n        structure=self.structure,\n        data={\"total\": data_array_copy},\n        data_type=data_type,\n    )\n    file_path = directory / f\"{grid.data_type.prefix}_asum\"\n    # write file\n    grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_basin_volumes","title":"<code>write_basin_volumes(basin_indices, directory=None, write_reference=False, output_format=None, **writer_kwargs)</code>","text":"<p>Writes bader basins to vasp-like files. Points belonging to the basin will have values from the charge or reference grid, and all other points will be 0.</p> <p>Parameters:</p> Name Type Description Default <code>basin_indices</code> <code>NDArray</code> <p>The list of basin indices to write</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>False</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>def write_basin_volumes(\n    self,\n    basin_indices: NDArray,\n    directory: str | Path = None,\n    write_reference: bool = False,\n    output_format: str | Format = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes bader basins to vasp-like files. Points belonging to the basin\n    will have values from the charge or reference grid, and all other points\n    will be 0.\n\n    Parameters\n    ----------\n    basin_indices : NDArray\n        The list of basin indices to write\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # get the data to use\n    if write_reference:\n        data_array = self.reference_grid.total\n        data_type = self.reference_grid.data_type\n    else:\n        data_array = self.charge_grid.total\n        data_type = self.charge_grid.data_type\n\n    if directory is None:\n        directory = Path(\".\")\n    for basin in basin_indices:\n        # get a mask everywhere but the requested basin\n        mask = self.basin_labels != basin\n        # copy data to avoid overwriting. Set data off of basin to 0\n        data_array_copy = data_array.copy()\n        data_array_copy[mask] = 0.0\n        grid = Grid(\n            structure=self.structure,\n            data={\"total\": data_array_copy},\n            data_type=data_type,\n        )\n        file_path = directory / f\"{grid.data_type.prefix}_b{basin}\"\n        # write file\n        grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_basin_volumes_sum","title":"<code>write_basin_volumes_sum(basin_indices, directory=None, write_reference=False, output_format=None, **writer_kwargs)</code>","text":"<p>Writes the union of the provided bader basins to vasp-like files. Points belonging to the basins will have values from the charge or reference grid, and all other points will be 0.</p> <p>Parameters:</p> Name Type Description Default <code>basin_indices</code> <code>NDArray</code> <p>The list of basin indices to sum and write</p> required <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <code>write_reference</code> <code>bool</code> <p>Whether or not to write the reference data rather than the charge data. Default is False.</p> <code>False</code> <code>output_format</code> <code>str | Format</code> <p>The format to write with. If None, writes to source format stored in the Grid objects metadata. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>def write_basin_volumes_sum(\n    self,\n    basin_indices: NDArray,\n    directory: str | Path = None,\n    write_reference: bool = False,\n    output_format: str | Format = None,\n    **writer_kwargs,\n):\n    \"\"\"\n    Writes the union of the provided bader basins to vasp-like files.\n    Points belonging to the basins will have values from the charge or\n    reference grid, and all other points will be 0.\n\n    Parameters\n    ----------\n    basin_indices : NDArray\n        The list of basin indices to sum and write\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n    write_reference : bool, optional\n        Whether or not to write the reference data rather than the charge data.\n        Default is False.\n    output_format : str | Format, optional\n        The format to write with. If None, writes to source format stored in\n        the Grid objects metadata.\n        Defaults to None.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # get the data to use\n    if write_reference:\n        data_array = self.reference_grid.total\n        data_type = self.reference_grid.data_type\n    else:\n        data_array = self.charge_grid.total\n        data_type = self.charge_grid.data_type\n\n    if directory is None:\n        directory = Path(\".\")\n    # create a mask including each of the requested basins\n    mask = np.isin(self.basin_labels, basin_indices)\n    # copy data to avoid overwriting. Set data off of basin to 0\n    data_array_copy = data_array.copy()\n    data_array_copy[~mask] = 0.0\n    grid = Grid(\n        structure=self.structure,\n        data={\"total\": data_array_copy},\n        data_type=data_type,\n    )\n    file_path = directory / f\"{grid.data_type.prefix}_bsum\"\n    # write file\n    grid.write(filename=file_path, output_format=output_format, **writer_kwargs)\n</code></pre>"},{"location":"api_reference/core/bader/#src.baderkit.core.bader.Bader.write_results_summary","title":"<code>write_results_summary(directory=None)</code>","text":"<p>Writes a summary of atom and basin results to .tsv files.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The directory to write the files in. If None, the active directory is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/bader.py</code> <pre><code>def write_results_summary(\n    self,\n    directory: Path | str | None = None,\n):\n    \"\"\"\n    Writes a summary of atom and basin results to .tsv files.\n\n    Parameters\n    ----------\n    directory : str | Path\n        The directory to write the files in. If None, the active directory\n        is used.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    if directory is None:\n        directory = Path(\".\")\n\n    # Get atom results summary\n    atoms_df = self.get_atom_results_dataframe()\n    formatted_atoms_df = atoms_df.copy()\n    numeric_cols = formatted_atoms_df.select_dtypes(include=\"number\").columns\n    formatted_atoms_df[numeric_cols] = formatted_atoms_df[numeric_cols].map(\n        lambda x: f\"{x:.5f}\"\n    )\n\n    # Get basin results summary\n    basin_df = self.get_basin_results_dataframe()\n    formatted_basin_df = basin_df.copy()\n    numeric_cols = formatted_basin_df.select_dtypes(include=\"number\").columns\n    formatted_basin_df[numeric_cols] = formatted_basin_df[numeric_cols].map(\n        lambda x: f\"{x:.5f}\"\n    )\n\n    # Determine max width per column including header\n    atom_col_widths = {\n        col: max(len(col), formatted_atoms_df[col].map(len).max())\n        for col in atoms_df.columns\n    }\n    basin_col_widths = {\n        col: max(len(col), formatted_basin_df[col].map(len).max())\n        for col in basin_df.columns\n    }\n\n    # Write to file with aligned columns using tab as separator\n    for df, col_widths, name in zip(\n        [formatted_atoms_df, formatted_basin_df],\n        [atom_col_widths, basin_col_widths],\n        [\"bader_atom_summary.tsv\", \"bader_basin_summary.tsv\"],\n    ):\n        # Note what we're writing in log\n        if \"atom\" in name:\n            logging.info(f\"Writing Atom Summary to {name}\")\n        else:\n            logging.info(f\"Writing Basin Summary to {name}\")\n\n        # write output summaries\n        with open(directory / name, \"w\") as f:\n            # Write header\n            header = \"\\t\".join(f\"{col:&lt;{col_widths[col]}}\" for col in df.columns)\n            f.write(header + \"\\n\")\n\n            # Write rows\n            for _, row in df.iterrows():\n                line = \"\\t\".join(\n                    f\"{val:&lt;{col_widths[col]}}\" for col, val in row.items()\n                )\n                f.write(line + \"\\n\")\n            # write vacuum summary to atom file\n            if name == \"bader_atom_summary.tsv\":\n                f.write(\"\\n\")\n                f.write(f\"Vacuum Charge:\\t\\t{self.vacuum_charge:.5f}\\n\")\n                f.write(f\"Vacuum Volume:\\t\\t{self.vacuum_volume:.5f}\\n\")\n                f.write(f\"Total Electrons:\\t{self.total_electron_number:.5f}\\n\")\n</code></pre>"},{"location":"api_reference/core/grid/","title":"Grid","text":"<p>               Bases: <code>VolumetricData</code></p> <p>A representation of the charge density, ELF, or other volumetric data. This class is a wraparound for Pymatgen's VolumetricData class with additional properties and methods.</p> See Also <p>:class:<code>~pymatgen.io.vasp.outputs.VolumetricData</code>     The parent class that provides basic volumetric data handling.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>The crystal structure associated with the volumetric data. Represents the lattice and atomic coordinates using the <code>Structure</code> class.</p> required <code>data</code> <code>dict[str, NDArray[float]]</code> <p>A dictionary containing the volumetric data. Keys include: - <code>\"total\"</code>: A 3D NumPy array representing the total spin density. If the     data is ELF, represents the spin up ELF for spin-polarized calculations     and the total ELF otherwise. - <code>\"diff\"</code> (optional): A 3D NumPy array representing the spin-difference   density (spin up - spin down). If the data is ELF, represents the   spin down ELF.</p> required <code>data_aug</code> <code>NDArray[float]</code> <p>Any extra information associated with volumetric data (typically augmentation charges)</p> <code>None</code> <code>source_format</code> <code>Format</code> <p>The file format this grid was created from, 'vasp', 'cube', 'hdf5', or None.</p> <code>None</code> <code>data_type</code> <code>DataType</code> <p>The type of data stored in the Grid object, either 'charge' or 'elf'. If None, the data type will be guessed from the data range.</p> <code>charge</code> <code>distance_matrix</code> <code>NDArray[float]</code> <p>A pre-computed distance matrix if available. Useful so pass distance_matrices between sums, short-circuiting an otherwise expensive operation.</p> <code>None</code> <code>sig_figs</code> <code>int</code> <p>The number of sig figs the data has. If None, this will be guessed.</p> <code>None</code> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>class Grid(VolumetricData):\n    \"\"\"\n    A representation of the charge density, ELF, or other volumetric data.\n    This class is a wraparound for Pymatgen's VolumetricData class with additional\n    properties and methods.\n\n    See Also\n    --------\n    :class:`~pymatgen.io.vasp.outputs.VolumetricData`\n        The parent class that provides basic volumetric data handling.\n\n    Parameters\n    ----------\n    structure : Structure\n        The crystal structure associated with the volumetric data.\n        Represents the lattice and atomic coordinates using the `Structure` class.\n    data : (dict[str, NDArray[float]])\n        A dictionary containing the volumetric data. Keys include:\n        - `\"total\"`: A 3D NumPy array representing the total spin density. If the\n            data is ELF, represents the spin up ELF for spin-polarized calculations\n            and the total ELF otherwise.\n        - `\"diff\"` (optional): A 3D NumPy array representing the spin-difference\n          density (spin up - spin down). If the data is ELF, represents the\n          spin down ELF.\n    data_aug : NDArray[float], optional\n        Any extra information associated with volumetric data\n        (typically augmentation charges)\n    source_format : Format, optional\n        The file format this grid was created from, 'vasp', 'cube', 'hdf5', or None.\n    data_type : DataType, optional\n        The type of data stored in the Grid object, either 'charge' or 'elf'. If\n        None, the data type will be guessed from the data range.\n    distance_matrix : NDArray[float], optional\n        A pre-computed distance matrix if available.\n        Useful so pass distance_matrices between sums,\n        short-circuiting an otherwise expensive operation.\n    sig_figs : int, optional\n        The number of sig figs the data has. If None, this will be guessed.\n    \"\"\"\n\n    def __init__(\n        self,\n        structure: Structure,\n        data: dict,\n        data_aug: dict = None,\n        source_format: Format = None,\n        data_type: DataType = DataType.charge,\n        distance_matrix: NDArray[float] = None,\n        sig_figs: int = None,\n        **kwargs,\n    ):\n        # The following is copied directly from pymatgen, but replaces their\n        # creation of a RegularGridInterpolator to avoid some overhead\n        self.structure = Structure.from_dict(\n            structure.as_dict()\n        )  # convert to baderkit structure\n        self.is_spin_polarized = len(data) &gt;= 2\n        self.is_soc = len(data) &gt;= 4\n        # convert data to numpy arrays in case they were jsanitized as lists\n        self.data = {k: np.array(v) for k, v in data.items()}\n        self.dim = self.data[\"total\"].shape\n        self.data_aug = data_aug or {}\n        self.ngridpts = self.dim[0] * self.dim[1] * self.dim[2]\n        # lazy init the spin data since this is not always needed.\n        self._spin_data: dict[Spin, float] = {}\n        self._distance_matrix = distance_matrix or {}\n        self.xpoints = np.linspace(0.0, 1.0, num=self.dim[0])\n        self.ypoints = np.linspace(0.0, 1.0, num=self.dim[1])\n        self.zpoints = np.linspace(0.0, 1.0, num=self.dim[2])\n        self.name = \"VolumetricData\"\n\n        # The rest of this is new for BaderKit methods\n        if source_format is None:\n            source_format = Format.vasp\n        self.source_format = Format(source_format)\n\n        if sig_figs is None:\n            sig_figs = infer_significant_figures(self.data[\"total\"])\n        self.sig_figs = sig_figs\n\n        # custom interpolator setting\n        self._cubic_spline_coeffs = None\n\n        if data_type is None:\n            # attempt to guess data type from data range\n            if self.total.max() &lt;= 1 and self.total.min() &gt;= 0:\n                data_type = DataType.elf\n            else:\n                data_type = DataType.charge\n            logging.info(f\"Data type set as {data_type.value} from data range\")\n        self.data_type = data_type\n\n        # assign cached properties\n        self._reset_cache()\n\n    def _reset_cache(self):\n        self._grid_indices = None\n        self._flat_grid_indices = None\n        self._point_dists = None\n        self._max_point_dist = None\n        self._grid_neighbor_transforms = None\n        self._symmetry_data = None\n        self._maxima_mask = None\n        self._minima_mask = None\n\n    @property\n    def total(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            For charge densities, returns the total charge (spin-up + spin-down).\n            For ELF returns the spin-up or single spin ELF.\n\n        \"\"\"\n        return self.data[\"total\"]\n\n    @total.setter\n    def total(self, new_total: NDArray[float]):\n        self.data[\"total\"] = new_total\n        # reset cache\n        self._reset_cache()\n\n    @property\n    def diff(self) -&gt; NDArray[float] | None:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            For charge densities, returns the magnetized charge (spin-up - spin-down).\n            For ELF returns the spin-down ELF. If the file was not from a spin\n            polarized calculation, this will be None.\n\n        \"\"\"\n        return self.data.get(\"diff\")\n\n    @diff.setter\n    def diff(self, new_diff):\n        self.data[\"diff\"] = new_diff\n        # reset cache\n        self._reset_cache()\n\n    @property\n    def shape(self) -&gt; NDArray[int]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[int]\n            The number of points along each axis of the grid.\n\n        \"\"\"\n        return np.array(self.total.shape)\n\n    @property\n    def matrix(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            A 3x3 matrix defining the a, b, and c sides of the unit cell. Each\n            row is the corresponding lattice vector in cartesian space.\n\n        \"\"\"\n        return self.structure.lattice.matrix\n\n    @property\n    def grid_indices(self) -&gt; NDArray[int]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[int]\n            The indices for all points on the grid. Uses 'C' ordering.\n\n        \"\"\"\n        if self._grid_indices is None:\n            self._grid_indices = np.indices(self.shape).reshape(3, -1).T\n        return self._grid_indices\n\n    @property\n    def flat_grid_indices(self) -&gt; NDArray[int]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[int]\n            An array of the same shape as the grid where each entry is the index\n            of that voxel if you were to flatten/ravel the grid. Uses 'C' ordering.\n\n        \"\"\"\n        if self._flat_grid_indices is None:\n            self._flat_grid_indices = np.arange(\n                np.prod(self.shape), dtype=np.int64\n            ).reshape(self.shape)\n        return self._flat_grid_indices\n\n    @property\n    def cubic_spline_coeffs(self) -&gt; NDArray[float]:\n        if self._cubic_spline_coeffs is None:\n            self._cubic_spline_coeffs = spline_filter(\n                self.total, order=3, mode=\"grid-wrap\"\n            )\n\n        return self._cubic_spline_coeffs\n\n    # TODO: Do this with numba to reduce memory and probably increase speed\n    @property\n    def point_dists(self) -&gt; NDArray[float]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[float]\n            The distance from each point to the origin in cartesian coordinates.\n\n        \"\"\"\n        if self._point_dists is None:\n            cart_coords = self.grid_to_cart(self.grid_indices)\n            a, b, c = self.matrix\n            corners = [\n                np.array([0, 0, 0]),\n                a,\n                b,\n                c,\n                a + b,\n                a + c,\n                b + c,\n                a + b + c,\n            ]\n            distances = []\n            for corner in corners:\n                voxel_distances = np.linalg.norm(cart_coords - corner, axis=1).round(6)\n                distances.append(voxel_distances)\n            min_distances = np.min(np.column_stack(distances), axis=1)\n            self._point_dists = min_distances.reshape(self.shape)\n        return self._point_dists\n\n    @property\n    def point_volume(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The volume of a single point in the grid.\n\n        \"\"\"\n        volume = self.structure.volume\n        return volume / self.ngridpts\n\n    @property\n    def max_point_dist(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The maximum distance from the center of a point to one of its corners. This\n            assumes the voxel is the same shape as the lattice.\n\n        \"\"\"\n        if self._max_point_dist is None:\n            # We need to find the coordinates that make up a single voxel. This\n            # is just the cartesian coordinates of the unit cell divided by\n            # its grid size\n            a, b, c = self.matrix\n            end = [0, 0, 0]\n            vox_a = [x / self.shape[0] for x in a]\n            vox_b = [x / self.shape[1] for x in b]\n            vox_c = [x / self.shape[2] for x in c]\n            # We want the three other vertices on the other side of the voxel. These\n            # can be found by adding the vectors in a cycle (e.g. a+b, b+c, c+a)\n            vox_a1 = [x + x1 for x, x1 in zip(vox_a, vox_b)]\n            vox_b1 = [x + x1 for x, x1 in zip(vox_b, vox_c)]\n            vox_c1 = [x + x1 for x, x1 in zip(vox_c, vox_a)]\n            # The final vertex can be found by adding the last unsummed vector to any\n            # of these\n            end1 = [x + x1 for x, x1 in zip(vox_a1, vox_c)]\n            # The center of the voxel sits exactly between the two ends\n            center = [(x + x1) / 2 for x, x1 in zip(end, end1)]\n            # Shift each point here so that the origin is the center of the\n            # voxel.\n            voxel_vertices = []\n            for vector in [\n                center,\n                end,\n                vox_a,\n                vox_b,\n                vox_c,\n                vox_a1,\n                vox_b1,\n                vox_c1,\n                end,\n            ]:\n                new_vector = [(x - x1) for x, x1 in zip(vector, center)]\n                voxel_vertices.append(new_vector)\n\n            # Now we need to find the maximum distance from the center of the voxel\n            # to one of its edges. This should be at one of the vertices.\n            # We can't say for sure which one is the largest distance so we find all\n            # of their distances and return the maximum\n            self._max_point_dist = max(\n                [np.linalg.norm(vector) for vector in voxel_vertices]\n            )\n        return self._max_point_dist\n\n    @cached_property\n    def point_neighbor_voronoi_transforms(\n        self,\n    ) -&gt; tuple[NDArray, NDArray, NDArray, NDArray]:\n        \"\"\"\n\n        Returns\n        -------\n        tuple[NDArray, NDArray, NDArray, NDArray]\n            The transformations, neighbor distances, areas, and vertices of the\n            voronoi surface between any point and its neighbors in the grid.\n            This is used in the 'weight' method for Bader analysis.\n\n        \"\"\"\n        # I go out to 2 voxels away here. I think 1 would probably be fine, but\n        # this doesn't take much more time and I'm certain this will capture the\n        # full voronoi cell.\n        voxel_positions = np.array(list(itertools.product([-2, -1, 0, 1, 2], repeat=3)))\n        center = math.floor(len(voxel_positions) / 2)\n        cart_positions = self.grid_to_cart(voxel_positions)\n        voronoi = Voronoi(cart_positions)\n        site_neighbors = []\n        facet_vertices = []\n        facet_areas = []\n\n        def facet_area(vertices):\n            # You can use a 2D or 3D area formula for a polygon\n            # Here we assume the vertices are in a 2D plane for simplicity\n            # For 3D, a more complicated approach (e.g., convex hull or triangulation) is needed\n            p0 = np.array(vertices[0])\n            area = 0\n            for i in range(1, len(vertices) - 1):\n                p1 = np.array(vertices[i])\n                p2 = np.array(vertices[i + 1])\n                area += np.linalg.norm(np.cross(p1 - p0, p2 - p0)) / 2.0\n            return area\n\n        for i, neighbor_pair in enumerate(voronoi.ridge_points):\n            if center in neighbor_pair:\n                neighbor = [i for i in neighbor_pair if i != center][0]\n                vertex_indices = voronoi.ridge_vertices[i]\n                vertices = voronoi.vertices[vertex_indices]\n                area = facet_area(vertices)\n                site_neighbors.append(neighbor)\n                facet_vertices.append(vertices)\n                facet_areas.append(area)\n        transforms = voxel_positions[np.array(site_neighbors)]\n        cart_transforms = cart_positions[np.array(site_neighbors)]\n        transform_dists = np.linalg.norm(cart_transforms, axis=1)\n        return transforms, transform_dists, np.array(facet_areas), facet_vertices\n\n    @cached_property\n    def point_neighbor_transforms(self) -&gt; (NDArray[int], NDArray[float]):\n        \"\"\"\n\n        Returns\n        -------\n        (NDArray[int], NDArray[float])\n            A tuple where the first entry is a 26x3 array of transformations in\n            from any point to its neighbors and the second is the\n            distance to each of these neighbors in cartesian space.\n\n        \"\"\"\n        neighbors = np.array(\n            [i for i in itertools.product([-1, 0, 1], repeat=3) if i != (0, 0, 0)]\n        ).astype(np.int64)\n        cart_coords = self.grid_to_cart(neighbors)\n        dists = np.linalg.norm(cart_coords, axis=1)\n\n        return neighbors, dists\n\n    @cached_property\n    def point_neighbor_face_tranforms(self) -&gt; (NDArray[int], NDArray[float]):\n        \"\"\"\n\n        Returns\n        -------\n        (NDArray[int], NDArray[float])\n            A tuple where the first entry is a 6x3 array of transformations in\n            voxel space from any voxel to its face sharing neighbors and the\n            second is the distance to each of these neighbors in cartesian space.\n\n        \"\"\"\n        all_neighbors, all_dists = self.point_neighbor_transforms\n        faces = []\n        dists = []\n        for i in range(len(all_neighbors)):\n            if np.sum(np.abs(all_neighbors[i])) == 1:\n                faces.append(all_neighbors[i])\n                dists.append(all_dists[i])\n        return np.array(faces).astype(int), np.array(dists)\n\n    @property\n    def grid_neighbor_transforms(self) -&gt; list:\n        \"\"\"\n        The transforms for translating a grid index to neighboring unit\n        cells. This is necessary for the many voxels that will not be directly\n        within an atoms partitioning.\n\n        Returns\n        -------\n        list\n            A list of voxel grid_neighbor_transforms unique to the grid dimensions.\n\n        \"\"\"\n        if self._grid_neighbor_transforms is None:\n            a, b, c = self.shape\n            grid_neighbor_transforms = [\n                (t, u, v)\n                for t, u, v in itertools.product([-a, 0, a], [-b, 0, b], [-c, 0, c])\n            ]\n            # sort grid_neighbor_transforms. There may be a better way of sorting them. I\n            # noticed that generally the correct site was found most commonly\n            # for the original site and generally was found at grid_neighbor_transforms that\n            # were either all negative/0 or positive/0\n            grid_neighbor_transforms_sorted = []\n            for item in grid_neighbor_transforms:\n                if all(val &lt;= 0 for val in item):\n                    grid_neighbor_transforms_sorted.append(item)\n                elif all(val &gt;= 0 for val in item):\n                    grid_neighbor_transforms_sorted.append(item)\n            for item in grid_neighbor_transforms:\n                if item not in grid_neighbor_transforms_sorted:\n                    grid_neighbor_transforms_sorted.append(item)\n            grid_neighbor_transforms_sorted.insert(\n                0, grid_neighbor_transforms_sorted.pop(7)\n            )\n            self._grid_neighbor_transforms = grid_neighbor_transforms_sorted\n        return self._grid_neighbor_transforms\n\n    @property\n    def grid_resolution(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The number of voxels per unit volume.\n\n        \"\"\"\n        volume = self.structure.volume\n        number_of_voxels = self.ngridpts\n        return number_of_voxels / volume\n\n    @property\n    def symmetry_data(self):\n        \"\"\"\n\n        Returns\n        -------\n        TYPE\n            The pymatgen symmetry dataset for the Grid's Structure object\n\n        \"\"\"\n        if self._symmetry_data is None:\n            self._symmetry_data = SpacegroupAnalyzer(\n                self.structure\n            ).get_symmetry_dataset()\n        return self._symmetry_data\n\n    @property\n    def equivalent_atoms(self) -&gt; NDArray[int]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[int]\n            The equivalent atoms in the Structure.\n\n        \"\"\"\n        return self.symmetry_data.equivalent_atoms\n\n    @property\n    def maxima_mask(self) -&gt; NDArray[bool]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[bool]\n            A mask with the same dimensions as the data that is True at local\n            maxima. Adjacent points with the same value will both be labeled as\n            True.\n        \"\"\"\n        if self._maxima_mask is None:\n            # avoid circular import\n            from baderkit.core.methods.shared_numba import get_maxima\n\n            self._maxima_mask = get_maxima(\n                self.total,\n                neighbor_transforms=self.point_neighbor_transforms[0],\n                vacuum_mask=np.zeros_like(self.total, dtype=np.bool_),\n            )\n        return self._maxima_mask\n\n    @property\n    def minima_mask(self) -&gt; NDArray[bool]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[bool]\n            A mask with the same dimensions as the data that is True at local\n            minima. Adjacent points with the same value will both be labeled as\n            True.\n        \"\"\"\n        if self._minima_mask is None:\n            # avoid circular import\n            from baderkit.core.methods.shared_numba import get_maxima\n\n            self._minima_mask = get_maxima(\n                self.total,\n                neighbor_transforms=self.point_neighbor_transforms[0],\n                vacuum_mask=np.zeros_like(self.total, dtype=np.bool_),\n                use_minima=True,\n            )\n        return self._minima_mask\n\n    def value_at(\n        self,\n        x: float,\n        y: float,\n        z: float,\n        method: str = \"cubic\",\n    ):\n        \"\"\"Get a data value from self.data at a given point (x, y, z) in terms\n        of fractional lattice parameters. Will be interpolated using the\n        provided method.\n\n        Parameters\n        ----------\n        x : float\n            Fraction of lattice vector a.\n        y: float\n            Fraction of lattice vector b.\n        z: float\n            Fraction of lattice vector c.\n        method : float\n            The method to use for interpolation. nearest, linear, or cubic. The\n            cubic method will calculate and store spline coefficients in an\n            array the same size as the grid, which increases memory usage\n\n        Returns\n        -------\n        float\n            Value from self.data (potentially interpolated) corresponding to\n            the point (x, y, z).\n        \"\"\"\n        if method == \"cubic\":\n            data = self.cubic_spline_coeffs\n        else:\n            data = self.total\n\n        interpolator = Interpolator(\n            data=data,\n            method=method,\n        )\n        # interpolate value\n        return interpolator([x, y, z])[0]\n\n    def values_at(\n        self,\n        frac_coords: NDArray[float],\n        method: str = \"cubic\",\n    ) -&gt; list[float]:\n        \"\"\"\n        Interpolates the value of the data at each fractional coordinate in a\n        given list or array.\n\n        Parameters\n        ----------\n        frac_coords : NDArray\n            The fractional coordinates to interpolate values at with shape\n            N, 3.\n        method : float\n            The method to use for interpolation. nearest, linear, or cubic. The\n            cubic method will calculate and store spline coefficients in an\n            array the same size as the grid, which increases memory usage\n\n        Returns\n        -------\n        list[float]\n            The interpolated value at each fractional coordinate.\n\n        \"\"\"\n        if method == \"cubic\":\n            data = self.cubic_spline_coeffs\n        else:\n            data = self.total\n\n        interpolator = Interpolator(data=data, method=method)\n        # interpolate values\n        return interpolator(frac_coords)\n\n    def linear_slice(\n        self, p1: NDArray[float], p2: NDArray[float], n: int = 100, method=\"cubic\"\n    ):\n        \"\"\"\n        Interpolates the data between two fractional coordinates.\n\n        Parameters\n        ----------\n        p1 : NDArray[float]\n            The fractional coordinates of the first point\n        p2 : NDArray[float]\n            The fractional coordinates of the second point\n        n : int, optional\n            The number of points to collect along the line\n        method : float\n            The method to use for interpolation. nearest, linear, or cubic. The\n            cubic method will calculate and store spline coefficients in an\n            array the same size as the grid, which increases memory usage\n\n        Returns:\n            List of n data points (mostly interpolated) representing a linear slice of the\n            data from point p1 to point p2.\n        \"\"\"\n        if type(p1) not in {list, np.ndarray}:\n            raise TypeError(\n                f\"type of p1 should be list or np.ndarray, got {type(p1).__name__}\"\n            )\n        if len(p1) != 3:\n            raise ValueError(f\"length of p1 should be 3, got {len(p1)}\")\n        if type(p2) not in {list, np.ndarray}:\n            raise TypeError(\n                f\"type of p2 should be list or np.ndarray, got {type(p2).__name__}\"\n            )\n        if len(p2) != 3:\n            raise ValueError(f\"length of p2 should be 3, got {len(p2)}\")\n\n        x_pts = np.linspace(p1[0], p2[0], num=n)\n        y_pts = np.linspace(p1[1], p2[1], num=n)\n        z_pts = np.linspace(p1[2], p2[2], num=n)\n        frac_coords = np.column_stack((x_pts, y_pts, z_pts))\n        return self.values_at(frac_coords, method)\n\n    def get_box_around_point(self, point: NDArray, neighbor_size: int = 1) -&gt; NDArray:\n        \"\"\"\n        Gets a box around a given point taking into account wrapping at cell\n        boundaries.\n\n        Parameters\n        ----------\n        point : NDArray\n            The indices of the point to get a box around.\n        neighbor_size : int, optional\n            The size of the box on either side of the point. The default is 1.\n\n        Returns\n        -------\n        NDArray\n            A slice of the grid taken around the provided point.\n\n        \"\"\"\n\n        slices = []\n        for dim, c in zip(self.shape, point):\n            idx = np.arange(c - neighbor_size, c + 2) % dim\n            idx = idx.astype(int)\n            slices.append(idx)\n        return self.total[np.ix_(slices[0], slices[1], slices[2])]\n\n    @staticmethod\n    def get_2x_supercell(data: NDArray | None = None) -&gt; NDArray:\n        \"\"\"\n        Duplicates data to make a 2x2x2 supercell\n\n        Parameters\n        ----------\n        data : NDArray | None, optional\n            The data to duplicate. The default is None.\n\n        Returns\n        -------\n        NDArray\n            A new array with the data doubled in each direction\n        \"\"\"\n        new_data = np.tile(data, (2, 2, 2))\n        return new_data\n\n    def get_points_in_radius(\n        self,\n        point: NDArray,\n        radius: float,\n    ) -&gt; NDArray[int]:\n        \"\"\"\n        Gets the indices of the points in a radius around a point\n\n        Parameters\n        ----------\n        radius : float\n            The radius in cartesian distance units to find indices around the\n            point.\n        point : NDArray\n            The indices of the point to perform the operation on.\n\n        Returns\n        -------\n        NDArray[int]\n            The point indices in the sphere around the provided point.\n\n        \"\"\"\n        point = np.array(point)\n        # Get the distance from each point to the origin\n        point_distances = self.point_dists\n\n        # Get the indices that are within the radius\n        sphere_indices = np.where(point_distances &lt;= radius)\n        sphere_indices = np.column_stack(sphere_indices)\n\n        # Get indices relative to the point\n        sphere_indices = sphere_indices + point\n        # adjust points to wrap around grid\n        # line = [[round(float(a % b), 12) for a, b in zip(position, grid_data.shape)]]\n        new_x = (sphere_indices[:, 0] % self.shape[0]).astype(int)\n        new_y = (sphere_indices[:, 1] % self.shape[1]).astype(int)\n        new_z = (sphere_indices[:, 2] % self.shape[2]).astype(int)\n        sphere_indices = np.column_stack([new_x, new_y, new_z])\n        # return new_x, new_y, new_z\n        return sphere_indices\n\n    def get_transformation_in_radius(self, radius: float) -&gt; NDArray[int]:\n        \"\"\"\n        Gets the transformations required to move from a point to the points\n        surrounding it within the provided radius\n\n        Parameters\n        ----------\n        radius : float\n            The radius in cartesian distance units around the voxel.\n\n        Returns\n        -------\n        NDArray[int]\n            An array of transformations to add to a point to get to each of the\n            points within the radius surrounding it.\n\n        \"\"\"\n        # Get voxels around origin\n        voxel_distances = self.point_dists\n        # sphere_grid = np.where(voxel_distances &lt;= radius, True, False)\n        # eroded_grid = binary_erosion(sphere_grid)\n        # shell_indices = np.where(sphere_grid!=eroded_grid)\n        shell_indices = np.where(voxel_distances &lt;= radius)\n        # Now we want to translate these indices to next to the corner so that\n        # we can use them as transformations to move a voxel to the edge\n        final_shell_indices = []\n        for a, x in zip(self.shape, shell_indices):\n            new_x = x - a\n            abs_new_x = np.abs(new_x)\n            new_x_filter = abs_new_x &lt; x\n            final_x = np.where(new_x_filter, new_x, x)\n            final_shell_indices.append(final_x)\n\n        return np.column_stack(final_shell_indices)\n\n    def copy(self) -&gt; Self:\n        \"\"\"\n        Convenience method to get a copy of the current Grid.\n\n        Returns\n        -------\n        Self\n            A copy of the Grid.\n\n        \"\"\"\n        return Grid(\n            structure=self.structure.copy(),\n            data=self.data.copy(),\n            data_aug=self.data_aug.copy(),\n            source_format=self.source_format,\n            data_type=self.data_type,\n            distance_matrix=self._distance_matrix.copy(),\n        )\n\n    def regrid(\n        self,\n        desired_resolution: int = 1200,\n        new_shape: np.array = None,\n        order: int = 3,\n    ) -&gt; Self:\n        \"\"\"\n        Returns a new grid resized using scipy's ndimage.zoom method\n\n        Parameters\n        ----------\n        desired_resolution : int, optional\n            The desired resolution in voxels/A^3. The default is 1200.\n        new_shape : np.array, optional\n            The new array shape. Takes precedence over desired_resolution. The default is None.\n        order : int, optional\n            The order of spline interpolation to use. The default is 3.\n\n        Returns\n        -------\n        Self\n            A new Grid object near the desired resolution.\n        \"\"\"\n\n        # get the original grid size and lattice volume.\n        shape = self.shape\n        volume = self.structure.volume\n\n        if new_shape is None:\n            # calculate how much the number of voxels along each unit cell must be\n            # multiplied to reach the desired resolution.\n            scale_factor = ((desired_resolution * volume) / shape.prod()) ** (1 / 3)\n\n            # calculate the new grid shape. round up to the nearest integer for each\n            # side\n            new_shape = np.around(shape * scale_factor).astype(np.int32)\n\n        # get the factor to zoom by\n        zoom_factor = new_shape / shape\n\n        # zoom each piece of data\n        new_data = {}\n        for key, data in self.data.items():\n            new_data[key] = zoom(\n                data, zoom_factor, order=order, mode=\"grid-wrap\", grid_mode=True\n            )\n\n        # TODO: Add augment data?\n        return Grid(structure=self.structure, data=new_data)\n\n    def split_to_spin(self) -&gt; tuple[Self, Self]:\n        \"\"\"\n        Splits the grid to two Grid objects representing the spin up and spin down contributions\n\n        Returns\n        -------\n        tuple[Self, Self]\n            The spin-up and spin-down Grid objects.\n\n        \"\"\"\n\n        # first check if the grid has spin parts\n        assert (\n            self.is_spin_polarized\n        ), \"Only one set of data detected. The grid cannot be split into spin up and spin down\"\n        assert not self.is_soc\n\n        # Now we get the separate data parts. If the data is ELF, the parts are\n        # stored as total=spin up and diff = spin down\n        if self.data_type == \"elf\":\n            logging.info(\n                \"Splitting Grid using ELFCAR conventions (spin-up in 'total', spin-down in 'diff')\"\n            )\n            spin_up_data = self.total.copy()\n            spin_down_data = self.diff.copy()\n        elif self.data_type == \"charge\":\n            logging.info(\n                \"Splitting Grid using CHGCAR conventions (spin-up + spin-down in 'total', spin-up - spin-down in 'diff')\"\n            )\n            spin_data = self.spin_data\n            # pymatgen uses some custom class as keys here\n            for key in spin_data.keys():\n                if key.value == 1:\n                    spin_up_data = spin_data[key].copy()\n                elif key.value == -1:\n                    spin_down_data = spin_data[key].copy()\n\n        # convert to dicts\n        spin_up_data = {\"total\": spin_up_data}\n        spin_down_data = {\"total\": spin_down_data}\n\n        # get augment data\n        aug_up_data = (\n            {\"total\": self.data_aug[\"total\"]} if \"total\" in self.data_aug else {}\n        )\n        aug_down_data = (\n            {\"total\": self.data_aug[\"diff\"]} if \"diff\" in self.data_aug else {}\n        )\n\n        spin_up_grid = Grid(\n            structure=self.structure.copy(),\n            data=spin_up_data,\n            data_aug=aug_up_data,\n            data_type=self.data_type,\n            source_format=self.source_format,\n        )\n        spin_down_grid = Grid(\n            structure=self.structure.copy(),\n            data=spin_down_data,\n            data_aug=aug_down_data,\n            data_type=self.data_type,\n            source_format=self.source_format,\n        )\n\n        return spin_up_grid, spin_down_grid\n\n    @staticmethod\n    def label(input: NDArray, structure: NDArray = np.ones([3, 3, 3])) -&gt; NDArray[int]:\n        \"\"\"\n        Uses scipy's ndimage package to label an array, and corrects for\n        periodic boundaries\n\n        Parameters\n        ----------\n        input : NDArray\n            The array to label.\n        structure : NDArray, optional\n            The structureing elemetn defining feature connections.\n            The default is np.ones([3, 3, 3]).\n\n        Returns\n        -------\n        NDArray[int]\n            An array of the same shape as the original with labels for each unique\n            feature.\n\n        \"\"\"\n\n        if structure is not None:\n            labeled_array, _ = label(input, structure)\n            if len(np.unique(labeled_array)) == 1:\n                # there is one feature or no features\n                return labeled_array\n            # Features connected through opposite sides of the unit cell should\n            # have the same label, but they don't currently. To handle this, we\n            # pad our featured grid, re-label it, and check if the new labels\n            # contain multiple of our previous labels.\n            padded_featured_grid = np.pad(labeled_array, 1, \"wrap\")\n            relabeled_array, label_num = label(padded_featured_grid, structure)\n        else:\n            labeled_array, _ = label(input)\n            padded_featured_grid = np.pad(labeled_array, 1, \"wrap\")\n            relabeled_array, label_num = label(padded_featured_grid)\n\n        # We want to keep track of which features are connected to each other\n        unique_connections = [[] for i in range(len(np.unique(labeled_array)))]\n\n        for i in np.unique(relabeled_array):\n            # for i in range(label_num):\n            # Get the list of features that are in this super feature\n            mask = relabeled_array == i\n            connected_features = list(np.unique(padded_featured_grid[mask]))\n            # Iterate over these features. If they exist in a connection that we\n            # already have, we want to extend the connection to include any other\n            # features in this super feature\n            for j in connected_features:\n\n                unique_connections[j].extend([k for k in connected_features if k != j])\n\n                unique_connections[j] = list(np.unique(unique_connections[j]))\n\n        # create set/list to keep track of which features have already been connected\n        # to others and the full list of connections\n        already_connected = set()\n        reduced_connections = []\n\n        # loop over each shared connection\n        for i in range(len(unique_connections)):\n            if i in already_connected:\n                # we've already done these connections, so we skip\n                continue\n            # create sets of connections to compare with as we add more\n            connections = set()\n            new_connections = set(unique_connections[i])\n            while connections != new_connections:\n                # loop over the connections we've found so far. As we go, add\n                # any features we encounter to our set.\n                connections = new_connections.copy()\n                for j in connections:\n                    already_connected.add(j)\n                    new_connections.update(unique_connections[j])\n\n            # If we found any connections, append them to our list of reduced connections\n            if connections:\n                reduced_connections.append(sorted(new_connections))\n\n        # For each set of connections in our reduced set, relabel all values to\n        # the lowest one.\n        for connections in reduced_connections:\n            connected_features = np.unique(connections)\n            lowest_idx = connected_features[0]\n            for higher_idx in connected_features[1:]:\n                labeled_array = np.where(\n                    labeled_array == higher_idx, lowest_idx, labeled_array\n                )\n\n        # Now we reduce the feature labels so that they start at 0\n        for i, j in enumerate(np.unique(labeled_array)):\n            labeled_array = np.where(labeled_array == j, i, labeled_array)\n\n        return labeled_array\n\n    def linear_add(self, other: Self, scale_factor=1.0) -&gt; Self:\n        \"\"\"\n        Method to do a linear sum of volumetric objects. Used by + and -\n        operators as well. Returns a VolumetricData object containing the\n        linear sum.\n\n        Parameters\n        ----------\n        other : Grid\n            Another Grid object\n        scale_factor : float\n            Factor to scale the other data by\n\n        Returns\n        -------\n            Grid corresponding to self + scale_factor * other.\n        \"\"\"\n        if self.structure != other.structure:\n            logging.warn(\n                \"Structures are different. Make sure you know what you are doing...\",\n                stacklevel=2,\n            )\n        if list(self.data) != list(other.data):\n            raise ValueError(\n                \"Data have different keys! Maybe one is spin-polarized and the other is not?\"\n            )\n\n        # To add checks\n        data = {}\n        for k in self.data:\n            data[k] = self.data[k] + scale_factor * other.data[k]\n\n        new = deepcopy(self)\n        new.data = data.copy()\n        new.data_aug = {}  # TODO: Can this be added somehow?\n        return new\n\n    ###########################################################################\n    # The following is a series of methods that are useful for converting between\n    # voxel coordinates, fractional coordinates, and cartesian coordinates.\n    # Voxel coordinates go from 0 to grid_size-1. Fractional coordinates go\n    # from 0 to 1. Cartesian coordinates convert to real space based on the\n    # crystal lattice.\n    ###########################################################################\n    def get_voxel_coords_from_index(self, site: int) -&gt; NDArray[int]:\n        \"\"\"\n        Takes in an atom's site index and returns the equivalent voxel grid index.\n\n        Parameters\n        ----------\n        site : int\n            The index of the site to find the grid index for.\n\n        Returns\n        -------\n        NDArray[int]\n            A voxel grid index.\n\n        \"\"\"\n        return self.frac_to_grid(self.structure[site].frac_coords)\n\n    def get_voxel_coords_from_neigh_CrystalNN(self, neigh) -&gt; NDArray[int]:\n        \"\"\"\n        Gets the voxel grid index from a neighbor atom object from CrystalNN or\n        VoronoiNN\n\n        Parameters\n        ----------\n        neigh :\n            A neighbor type object from pymatgen.\n\n        Returns\n        -------\n        NDArray[int]\n            A voxel grid index as an array.\n\n        \"\"\"\n        grid_size = self.shape\n        frac = neigh[\"site\"].frac_coords\n        voxel_coords = [a * b for a, b in zip(grid_size, frac)]\n        # voxel positions go from 1 to (grid_size + 0.9999)\n        return np.array(voxel_coords)\n\n    def get_voxel_coords_from_neigh(self, neigh: dict) -&gt; NDArray[int]:\n        \"\"\"\n        Gets the voxel grid index from a neighbor atom object from the pymatgen\n        structure.get_neighbors class.\n\n        Parameters\n        ----------\n        neigh : dict\n            A neighbor dictionary from pymatgens structure.get_neighbors\n            method.\n\n        Returns\n        -------\n        NDArray[int]\n            A voxel grid index as an array.\n\n        \"\"\"\n\n        grid_size = self.shape\n        frac_coords = neigh.frac_coords\n        voxel_coords = [a * b for a, b in zip(grid_size, frac_coords)]\n        # voxel positions go from 1 to (grid_size + 0.9999)\n        return np.array(voxel_coords)\n\n    def cart_to_frac(self, cart_coords: NDArray | list) -&gt; NDArray[float]:\n        \"\"\"\n        Takes in a cartesian coordinate and returns the fractional coordinates.\n\n        Parameters\n        ----------\n        cart_coords : NDArray | list\n            An Nx3 Array or 1D array of length 3.\n\n        Returns\n        -------\n        NDArray[float]\n            Fractional coordinates as an Nx3 Array.\n\n        \"\"\"\n        inverse_matrix = np.linalg.inv(self.matrix)\n\n        return cart_coords @ inverse_matrix\n\n    def cart_to_grid(self, cart_coords: NDArray | list) -&gt; NDArray[int]:\n        \"\"\"\n        Takes in a cartesian coordinate and returns the voxel coordinates.\n\n        Parameters\n        ----------\n        cart_coords : NDArray | list\n            An Nx3 Array or 1D array of length 3.\n\n        Returns\n        -------\n        NDArray[int]\n            Voxel coordinates as an Nx3 Array.\n\n        \"\"\"\n        frac_coords = self.cart_to_frac(cart_coords)\n        voxel_coords = self.frac_to_grid(frac_coords)\n        return voxel_coords\n\n    def frac_to_cart(self, frac_coords: NDArray) -&gt; NDArray[float]:\n        \"\"\"\n        Takes in a fractional coordinate and returns the cartesian coordinates.\n\n        Parameters\n        ----------\n        frac_coords : NDArray | list\n            An Nx3 Array or 1D array of length 3.\n\n        Returns\n        -------\n        NDArray[float]\n            Cartesian coordinates as an Nx3 Array.\n\n        \"\"\"\n\n        return frac_coords @ self.matrix\n\n    def grid_to_frac(self, vox_coords: NDArray) -&gt; NDArray[float]:\n        \"\"\"\n        Takes in a voxel coordinates and returns the fractional coordinates.\n\n        Parameters\n        ----------\n        vox_coords : NDArray | list\n            An Nx3 Array or 1D array of length 3.\n\n        Returns\n        -------\n        NDArray[float]\n            Fractional coordinates as an Nx3 Array.\n\n        \"\"\"\n\n        return vox_coords / self.shape\n\n    def frac_to_grid(self, frac_coords: NDArray) -&gt; NDArray[int]:\n        \"\"\"\n        Takes in a fractional coordinates and returns the voxel coordinates.\n\n        Parameters\n        ----------\n        frac_coords : NDArray | list\n            An Nx3 Array or 1D array of length 3.\n\n        Returns\n        -------\n        NDArray[int]\n            Voxel coordinates as an Nx3 Array.\n\n        \"\"\"\n        return frac_coords * self.shape\n\n    def grid_to_cart(self, vox_coords: NDArray) -&gt; NDArray[float]:\n        \"\"\"\n        Takes in a voxel coordinates and returns the cartesian coordinates.\n\n        Parameters\n        ----------\n        vox_coords : NDArray | list\n            An Nx3 Array or 1D array of length 3.\n\n        Returns\n        -------\n        NDArray[float]\n            Cartesian coordinates as an Nx3 Array.\n\n        \"\"\"\n        frac_coords = self.grid_to_frac(vox_coords)\n        return self.frac_to_cart(frac_coords)\n\n    ###########################################################################\n    # Functions for loading from files or strings\n    ###########################################################################\n\n    @classmethod\n    def from_vasp(\n        cls,\n        grid_file: str | Path,\n        data_type: str | DataType = None,\n        total_only: bool = True,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Create a grid instance using a CHGCAR or ELFCAR file.\n\n        Parameters\n        ----------\n        grid_file : str | Path\n            The file the instance should be made from. Should be a VASP\n            CHGCAR or ELFCAR type file.\n        data_type: str | DataType\n            The type of data loaded from the file, either charge or elf. If\n            None, the type will be guessed from the data range.\n            Defaults to None.\n        total_only: bool\n            If true, only the first set of data in the file will be read. This\n            increases speed and reduced memory usage for methods that do not\n            use the spin data.\n            Defaults to True.\n\n        Returns\n        -------\n        Self\n            Grid from the specified file.\n\n        \"\"\"\n        logging.info(f\"Loading {grid_file}\")\n        t0 = time.time()\n        # get structure and data from file\n        grid_file = Path(grid_file)\n        # check that file exists\n        assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n        structure, data, data_aug, sig_figs = read_vasp(\n            grid_file, total_only=total_only\n        )\n        t1 = time.time()\n        logging.info(f\"Time: {round(t1-t0,2)}\")\n        return cls(\n            structure=structure,\n            data=data,\n            data_aug=data_aug,\n            data_type=data_type,\n            source_format=Format.vasp,\n            sig_figs=sig_figs,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_cube(\n        cls,\n        grid_file: str | Path,\n        data_type: str | DataType = None,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Create a grid instance using a gaussian cube file.\n\n        Parameters\n        ----------\n        grid_file : str | Path\n            The file the instance should be made from. Should be a gaussian\n            cube file.\n        data_type: str | DataType\n            The type of data loaded from the file, either charge or elf. If\n            None, the type will be guessed from the data range.\n            Defaults to None.\n\n        Returns\n        -------\n        Self\n            Grid from the specified file.\n\n        \"\"\"\n        logging.info(f\"Loading {grid_file}\")\n        t0 = time.time()\n        # make sure path is a Path object\n        grid_file = Path(grid_file)\n        # check that file exists\n        assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n        structure, data, ion_charges, origin, sig_figs = read_cube(grid_file)\n        # TODO: Also save the ion charges/origin for writing later\n        t1 = time.time()\n        logging.info(f\"Time: {round(t1-t0,2)}\")\n        return cls(\n            structure=structure,\n            data=data,\n            data_type=data_type,\n            source_format=Format.cube,\n            sig_figs=sig_figs,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_vasp_pymatgen(\n        cls,\n        grid_file: str | Path,\n        data_type: str | DataType = None,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Create a grid instance using a CHGCAR or ELFCAR file. Uses pymatgen's\n        parse_file method which is often surprisingly slow.\n\n        Parameters\n        ----------\n        grid_file : str | Path\n            The file the instance should be made from. Should be a VASP\n            CHGCAR or ELFCAR type file.\n        data_type: str | DataType\n            The type of data loaded from the file, either charge or elf. If\n            None, the type will be guessed from the data range.\n            Defaults to None.\n\n        Returns\n        -------\n        Self\n            Grid from the specified file.\n\n        \"\"\"\n        logging.info(f\"Loading {grid_file}\")\n        t0 = time.time()\n        # make sure path is a Path object\n        grid_file = Path(grid_file)\n        # check that file exists\n        assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n        # Create string to add structure to.\n        poscar, data, data_aug = cls.parse_file(grid_file)\n        t1 = time.time()\n        logging.info(f\"Time: {round(t1-t0,2)}\")\n        return cls(\n            structure=poscar.structure,\n            data=data,\n            data_aug=data_aug,\n            source_format=Format.vasp,\n            data_type=data_type,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_hdf5(\n        cls,\n        grid_file: str | Path,\n        data_type: str | DataType = None,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Create a grid instance using an hdf5 file.\n\n        Parameters\n        ----------\n        grid_file : str | Path\n            The file the instance should be made from. Should be a binary hdf5\n            file.\n        data_type: str | DataType\n            The type of data loaded from the file, either charge or elf. If\n            None, the type will be guessed from the data range.\n            Defaults to None.\n\n        Returns\n        -------\n        Self\n            Grid from the specified file.\n\n        \"\"\"\n        try:\n            import h5py\n        except:\n            raise ImportError(\n                \"\"\"\n                The `h5py` package is required to read/write to the hdf5 format.\n                Please install with `conda install h5py` or `pip install h5py`.\n                \"\"\"\n            )\n\n        logging.info(f\"Loading {grid_file}\")\n        t0 = time.time()\n        # make sure path is a Path object\n        grid_file = Path(grid_file)\n\n        # check that file exists\n        assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n        # load the file\n        pymatgen_grid = super().from_hdf5(filename=grid_file)\n        t1 = time.time()\n        logging.info(f\"Time: {round(t1-t0,2)}\")\n        return cls(\n            structure=pymatgen_grid.structure,\n            data=pymatgen_grid.data,\n            data_aug=pymatgen_grid.data_aug,\n            source_format=Format.hdf5,\n            data_type=data_type,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_dynamic(\n        cls,\n        grid_file: str | Path,\n        format: str | Format = None,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        Create a grid instance using a VASP or .cube file. If no format is provided\n        the format is guesed by the name of the file.\n\n        Parameters\n        ----------\n        grid_file : str | Path\n            The file the instance should be made from.\n        format : Format, optional\n            The format of the provided file. If None, a guess will be made based\n            on the name of the file. Setting this is identical to calling the\n            from methods for the corresponding file type. The default is None.\n\n        Returns\n        -------\n        Self\n            Grid from the specified file.\n\n        \"\"\"\n        grid_file = Path(grid_file)\n\n        # check that file exists\n        assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n\n        if format is None:\n            # guess format from file\n            format = detect_format(grid_file)\n\n        # make sure format is an available option\n        assert (\n            format in Format\n        ), \"Invalid provided format '{format}'. Options are: {[i.value for i in Format]}\"\n\n        # get the reading method corresponding to this output format\n        method_name = format.reader\n\n        # load from file\n        return getattr(cls, method_name)(grid_file, **kwargs)\n\n    def write_vasp(\n        self,\n        filename: Path | str,\n        vasp4_compatible: bool = False,\n    ):\n        \"\"\"\n        Writes the Grid to a VASP-like file at the provided path.\n\n        Parameters\n        ----------\n        filename : Path | str\n            The name of the file to write to.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        filename = Path(filename)\n        logging.info(f\"Writing {filename.name}\")\n        write_vasp_file(filename=filename, grid=self, vasp4_compatible=vasp4_compatible)\n\n    def write_cube(\n        self,\n        filename: Path | str,\n        **kwargs,\n    ):\n        \"\"\"\n        Writes the Grid to a Gaussian cube-like file at the provided path.\n\n        Parameters\n        ----------\n        filename : Path | str\n            The name of the file to write to.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        filename = Path(filename)\n        logging.info(f\"Writing {filename.name}\")\n        write_cube_file(\n            filename=filename,\n            grid=self,\n            **kwargs,\n        )\n\n    def to_hdf5(\n        self,\n        filename: Path | str,\n        **kwargs,\n    ):\n        try:\n            import h5py\n        except:\n            raise ImportError(\n                \"\"\"\n                The `h5py` package is required to read/write to the hdf5 format.\n                Please install with `conda install h5py` or `pip install h5py`.\n                \"\"\"\n            )\n        filename = Path(filename)\n        logging.info(f\"Writing {filename.name}\")\n        super().to_hdf5(filename)\n\n    def write(\n        self,\n        filename: Path | str,\n        output_format: Format | str = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Writes the Grid to the requested format file at the provided path. If no\n        format is provided, uses this Grid objects stored format.\n\n        Parameters\n        ----------\n        filename : Path | str\n            The name of the file to write to.\n        output_format : Format | str\n            The format to write with. If None, writes to source format stored in\n            this Grid objects metadata.\n            Defaults to None.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # If no provided format, get from metadata\n        if output_format is None:\n            output_format = self.source_format\n        # Make sure format is a Format object not a string\n        output_format = Format(output_format)\n        # get the writing method corresponding to this output format\n        method_name = output_format.writer\n        # write the grid\n        getattr(self, method_name)(filename, **kwargs)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.diff","title":"<code>diff</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>For charge densities, returns the magnetized charge (spin-up - spin-down). For ELF returns the spin-down ELF. If the file was not from a spin polarized calculation, this will be None.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.equivalent_atoms","title":"<code>equivalent_atoms</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[int]</code> <p>The equivalent atoms in the Structure.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.flat_grid_indices","title":"<code>flat_grid_indices</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[int]</code> <p>An array of the same shape as the grid where each entry is the index of that voxel if you were to flatten/ravel the grid. Uses 'C' ordering.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.grid_indices","title":"<code>grid_indices</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[int]</code> <p>The indices for all points on the grid. Uses 'C' ordering.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.grid_neighbor_transforms","title":"<code>grid_neighbor_transforms</code>  <code>property</code>","text":"<p>The transforms for translating a grid index to neighboring unit cells. This is necessary for the many voxels that will not be directly within an atoms partitioning.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of voxel grid_neighbor_transforms unique to the grid dimensions.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.grid_resolution","title":"<code>grid_resolution</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The number of voxels per unit volume.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.matrix","title":"<code>matrix</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>A 3x3 matrix defining the a, b, and c sides of the unit cell. Each row is the corresponding lattice vector in cartesian space.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.max_point_dist","title":"<code>max_point_dist</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The maximum distance from the center of a point to one of its corners. This assumes the voxel is the same shape as the lattice.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.maxima_mask","title":"<code>maxima_mask</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool]</code> <p>A mask with the same dimensions as the data that is True at local maxima. Adjacent points with the same value will both be labeled as True.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.minima_mask","title":"<code>minima_mask</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[bool]</code> <p>A mask with the same dimensions as the data that is True at local minima. Adjacent points with the same value will both be labeled as True.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.point_dists","title":"<code>point_dists</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>The distance from each point to the origin in cartesian coordinates.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.point_neighbor_face_tranforms","title":"<code>point_neighbor_face_tranforms</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>(NDArray[int], NDArray[float])</code> <p>A tuple where the first entry is a 6x3 array of transformations in voxel space from any voxel to its face sharing neighbors and the second is the distance to each of these neighbors in cartesian space.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.point_neighbor_transforms","title":"<code>point_neighbor_transforms</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>(NDArray[int], NDArray[float])</code> <p>A tuple where the first entry is a 26x3 array of transformations in from any point to its neighbors and the second is the distance to each of these neighbors in cartesian space.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.point_neighbor_voronoi_transforms","title":"<code>point_neighbor_voronoi_transforms</code>  <code>cached</code> <code>property</code>","text":"<p>Returns:</p> Type Description <code>tuple[NDArray, NDArray, NDArray, NDArray]</code> <p>The transformations, neighbor distances, areas, and vertices of the voronoi surface between any point and its neighbors in the grid. This is used in the 'weight' method for Bader analysis.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.point_volume","title":"<code>point_volume</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The volume of a single point in the grid.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>NDArray[int]</code> <p>The number of points along each axis of the grid.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.symmetry_data","title":"<code>symmetry_data</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>TYPE</code> <p>The pymatgen symmetry dataset for the Grid's Structure object</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.total","title":"<code>total</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>NDArray[float]</code> <p>For charge densities, returns the total charge (spin-up + spin-down). For ELF returns the spin-up or single spin ELF.</p>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.cart_to_frac","title":"<code>cart_to_frac(cart_coords)</code>","text":"<p>Takes in a cartesian coordinate and returns the fractional coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>cart_coords</code> <code>NDArray | list</code> <p>An Nx3 Array or 1D array of length 3.</p> required <p>Returns:</p> Type Description <code>NDArray[float]</code> <p>Fractional coordinates as an Nx3 Array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def cart_to_frac(self, cart_coords: NDArray | list) -&gt; NDArray[float]:\n    \"\"\"\n    Takes in a cartesian coordinate and returns the fractional coordinates.\n\n    Parameters\n    ----------\n    cart_coords : NDArray | list\n        An Nx3 Array or 1D array of length 3.\n\n    Returns\n    -------\n    NDArray[float]\n        Fractional coordinates as an Nx3 Array.\n\n    \"\"\"\n    inverse_matrix = np.linalg.inv(self.matrix)\n\n    return cart_coords @ inverse_matrix\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.cart_to_grid","title":"<code>cart_to_grid(cart_coords)</code>","text":"<p>Takes in a cartesian coordinate and returns the voxel coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>cart_coords</code> <code>NDArray | list</code> <p>An Nx3 Array or 1D array of length 3.</p> required <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>Voxel coordinates as an Nx3 Array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def cart_to_grid(self, cart_coords: NDArray | list) -&gt; NDArray[int]:\n    \"\"\"\n    Takes in a cartesian coordinate and returns the voxel coordinates.\n\n    Parameters\n    ----------\n    cart_coords : NDArray | list\n        An Nx3 Array or 1D array of length 3.\n\n    Returns\n    -------\n    NDArray[int]\n        Voxel coordinates as an Nx3 Array.\n\n    \"\"\"\n    frac_coords = self.cart_to_frac(cart_coords)\n    voxel_coords = self.frac_to_grid(frac_coords)\n    return voxel_coords\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.copy","title":"<code>copy()</code>","text":"<p>Convenience method to get a copy of the current Grid.</p> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the Grid.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"\n    Convenience method to get a copy of the current Grid.\n\n    Returns\n    -------\n    Self\n        A copy of the Grid.\n\n    \"\"\"\n    return Grid(\n        structure=self.structure.copy(),\n        data=self.data.copy(),\n        data_aug=self.data_aug.copy(),\n        source_format=self.source_format,\n        data_type=self.data_type,\n        distance_matrix=self._distance_matrix.copy(),\n    )\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.frac_to_cart","title":"<code>frac_to_cart(frac_coords)</code>","text":"<p>Takes in a fractional coordinate and returns the cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>frac_coords</code> <code>NDArray | list</code> <p>An Nx3 Array or 1D array of length 3.</p> required <p>Returns:</p> Type Description <code>NDArray[float]</code> <p>Cartesian coordinates as an Nx3 Array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def frac_to_cart(self, frac_coords: NDArray) -&gt; NDArray[float]:\n    \"\"\"\n    Takes in a fractional coordinate and returns the cartesian coordinates.\n\n    Parameters\n    ----------\n    frac_coords : NDArray | list\n        An Nx3 Array or 1D array of length 3.\n\n    Returns\n    -------\n    NDArray[float]\n        Cartesian coordinates as an Nx3 Array.\n\n    \"\"\"\n\n    return frac_coords @ self.matrix\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.frac_to_grid","title":"<code>frac_to_grid(frac_coords)</code>","text":"<p>Takes in a fractional coordinates and returns the voxel coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>frac_coords</code> <code>NDArray | list</code> <p>An Nx3 Array or 1D array of length 3.</p> required <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>Voxel coordinates as an Nx3 Array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def frac_to_grid(self, frac_coords: NDArray) -&gt; NDArray[int]:\n    \"\"\"\n    Takes in a fractional coordinates and returns the voxel coordinates.\n\n    Parameters\n    ----------\n    frac_coords : NDArray | list\n        An Nx3 Array or 1D array of length 3.\n\n    Returns\n    -------\n    NDArray[int]\n        Voxel coordinates as an Nx3 Array.\n\n    \"\"\"\n    return frac_coords * self.shape\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.from_cube","title":"<code>from_cube(grid_file, data_type=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a grid instance using a gaussian cube file.</p> <p>Parameters:</p> Name Type Description Default <code>grid_file</code> <code>str | Path</code> <p>The file the instance should be made from. Should be a gaussian cube file.</p> required <code>data_type</code> <code>str | DataType</code> <p>The type of data loaded from the file, either charge or elf. If None, the type will be guessed from the data range. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>Grid from the specified file.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@classmethod\ndef from_cube(\n    cls,\n    grid_file: str | Path,\n    data_type: str | DataType = None,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Create a grid instance using a gaussian cube file.\n\n    Parameters\n    ----------\n    grid_file : str | Path\n        The file the instance should be made from. Should be a gaussian\n        cube file.\n    data_type: str | DataType\n        The type of data loaded from the file, either charge or elf. If\n        None, the type will be guessed from the data range.\n        Defaults to None.\n\n    Returns\n    -------\n    Self\n        Grid from the specified file.\n\n    \"\"\"\n    logging.info(f\"Loading {grid_file}\")\n    t0 = time.time()\n    # make sure path is a Path object\n    grid_file = Path(grid_file)\n    # check that file exists\n    assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n    structure, data, ion_charges, origin, sig_figs = read_cube(grid_file)\n    # TODO: Also save the ion charges/origin for writing later\n    t1 = time.time()\n    logging.info(f\"Time: {round(t1-t0,2)}\")\n    return cls(\n        structure=structure,\n        data=data,\n        data_type=data_type,\n        source_format=Format.cube,\n        sig_figs=sig_figs,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.from_dynamic","title":"<code>from_dynamic(grid_file, format=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a grid instance using a VASP or .cube file. If no format is provided the format is guesed by the name of the file.</p> <p>Parameters:</p> Name Type Description Default <code>grid_file</code> <code>str | Path</code> <p>The file the instance should be made from.</p> required <code>format</code> <code>Format</code> <p>The format of the provided file. If None, a guess will be made based on the name of the file. Setting this is identical to calling the from methods for the corresponding file type. The default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>Grid from the specified file.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@classmethod\ndef from_dynamic(\n    cls,\n    grid_file: str | Path,\n    format: str | Format = None,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Create a grid instance using a VASP or .cube file. If no format is provided\n    the format is guesed by the name of the file.\n\n    Parameters\n    ----------\n    grid_file : str | Path\n        The file the instance should be made from.\n    format : Format, optional\n        The format of the provided file. If None, a guess will be made based\n        on the name of the file. Setting this is identical to calling the\n        from methods for the corresponding file type. The default is None.\n\n    Returns\n    -------\n    Self\n        Grid from the specified file.\n\n    \"\"\"\n    grid_file = Path(grid_file)\n\n    # check that file exists\n    assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n\n    if format is None:\n        # guess format from file\n        format = detect_format(grid_file)\n\n    # make sure format is an available option\n    assert (\n        format in Format\n    ), \"Invalid provided format '{format}'. Options are: {[i.value for i in Format]}\"\n\n    # get the reading method corresponding to this output format\n    method_name = format.reader\n\n    # load from file\n    return getattr(cls, method_name)(grid_file, **kwargs)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.from_hdf5","title":"<code>from_hdf5(grid_file, data_type=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a grid instance using an hdf5 file.</p> <p>Parameters:</p> Name Type Description Default <code>grid_file</code> <code>str | Path</code> <p>The file the instance should be made from. Should be a binary hdf5 file.</p> required <code>data_type</code> <code>str | DataType</code> <p>The type of data loaded from the file, either charge or elf. If None, the type will be guessed from the data range. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>Grid from the specified file.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@classmethod\ndef from_hdf5(\n    cls,\n    grid_file: str | Path,\n    data_type: str | DataType = None,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Create a grid instance using an hdf5 file.\n\n    Parameters\n    ----------\n    grid_file : str | Path\n        The file the instance should be made from. Should be a binary hdf5\n        file.\n    data_type: str | DataType\n        The type of data loaded from the file, either charge or elf. If\n        None, the type will be guessed from the data range.\n        Defaults to None.\n\n    Returns\n    -------\n    Self\n        Grid from the specified file.\n\n    \"\"\"\n    try:\n        import h5py\n    except:\n        raise ImportError(\n            \"\"\"\n            The `h5py` package is required to read/write to the hdf5 format.\n            Please install with `conda install h5py` or `pip install h5py`.\n            \"\"\"\n        )\n\n    logging.info(f\"Loading {grid_file}\")\n    t0 = time.time()\n    # make sure path is a Path object\n    grid_file = Path(grid_file)\n\n    # check that file exists\n    assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n    # load the file\n    pymatgen_grid = super().from_hdf5(filename=grid_file)\n    t1 = time.time()\n    logging.info(f\"Time: {round(t1-t0,2)}\")\n    return cls(\n        structure=pymatgen_grid.structure,\n        data=pymatgen_grid.data,\n        data_aug=pymatgen_grid.data_aug,\n        source_format=Format.hdf5,\n        data_type=data_type,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.from_vasp","title":"<code>from_vasp(grid_file, data_type=None, total_only=True, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a grid instance using a CHGCAR or ELFCAR file.</p> <p>Parameters:</p> Name Type Description Default <code>grid_file</code> <code>str | Path</code> <p>The file the instance should be made from. Should be a VASP CHGCAR or ELFCAR type file.</p> required <code>data_type</code> <code>str | DataType</code> <p>The type of data loaded from the file, either charge or elf. If None, the type will be guessed from the data range. Defaults to None.</p> <code>None</code> <code>total_only</code> <code>bool</code> <p>If true, only the first set of data in the file will be read. This increases speed and reduced memory usage for methods that do not use the spin data. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>Grid from the specified file.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@classmethod\ndef from_vasp(\n    cls,\n    grid_file: str | Path,\n    data_type: str | DataType = None,\n    total_only: bool = True,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Create a grid instance using a CHGCAR or ELFCAR file.\n\n    Parameters\n    ----------\n    grid_file : str | Path\n        The file the instance should be made from. Should be a VASP\n        CHGCAR or ELFCAR type file.\n    data_type: str | DataType\n        The type of data loaded from the file, either charge or elf. If\n        None, the type will be guessed from the data range.\n        Defaults to None.\n    total_only: bool\n        If true, only the first set of data in the file will be read. This\n        increases speed and reduced memory usage for methods that do not\n        use the spin data.\n        Defaults to True.\n\n    Returns\n    -------\n    Self\n        Grid from the specified file.\n\n    \"\"\"\n    logging.info(f\"Loading {grid_file}\")\n    t0 = time.time()\n    # get structure and data from file\n    grid_file = Path(grid_file)\n    # check that file exists\n    assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n    structure, data, data_aug, sig_figs = read_vasp(\n        grid_file, total_only=total_only\n    )\n    t1 = time.time()\n    logging.info(f\"Time: {round(t1-t0,2)}\")\n    return cls(\n        structure=structure,\n        data=data,\n        data_aug=data_aug,\n        data_type=data_type,\n        source_format=Format.vasp,\n        sig_figs=sig_figs,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.from_vasp_pymatgen","title":"<code>from_vasp_pymatgen(grid_file, data_type=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a grid instance using a CHGCAR or ELFCAR file. Uses pymatgen's parse_file method which is often surprisingly slow.</p> <p>Parameters:</p> Name Type Description Default <code>grid_file</code> <code>str | Path</code> <p>The file the instance should be made from. Should be a VASP CHGCAR or ELFCAR type file.</p> required <code>data_type</code> <code>str | DataType</code> <p>The type of data loaded from the file, either charge or elf. If None, the type will be guessed from the data range. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>Grid from the specified file.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@classmethod\ndef from_vasp_pymatgen(\n    cls,\n    grid_file: str | Path,\n    data_type: str | DataType = None,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    Create a grid instance using a CHGCAR or ELFCAR file. Uses pymatgen's\n    parse_file method which is often surprisingly slow.\n\n    Parameters\n    ----------\n    grid_file : str | Path\n        The file the instance should be made from. Should be a VASP\n        CHGCAR or ELFCAR type file.\n    data_type: str | DataType\n        The type of data loaded from the file, either charge or elf. If\n        None, the type will be guessed from the data range.\n        Defaults to None.\n\n    Returns\n    -------\n    Self\n        Grid from the specified file.\n\n    \"\"\"\n    logging.info(f\"Loading {grid_file}\")\n    t0 = time.time()\n    # make sure path is a Path object\n    grid_file = Path(grid_file)\n    # check that file exists\n    assert grid_file.exists(), f\"No file with name {grid_file} found in directory\"\n    # Create string to add structure to.\n    poscar, data, data_aug = cls.parse_file(grid_file)\n    t1 = time.time()\n    logging.info(f\"Time: {round(t1-t0,2)}\")\n    return cls(\n        structure=poscar.structure,\n        data=data,\n        data_aug=data_aug,\n        source_format=Format.vasp,\n        data_type=data_type,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.get_2x_supercell","title":"<code>get_2x_supercell(data=None)</code>  <code>staticmethod</code>","text":"<p>Duplicates data to make a 2x2x2 supercell</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArray | None</code> <p>The data to duplicate. The default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>A new array with the data doubled in each direction</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@staticmethod\ndef get_2x_supercell(data: NDArray | None = None) -&gt; NDArray:\n    \"\"\"\n    Duplicates data to make a 2x2x2 supercell\n\n    Parameters\n    ----------\n    data : NDArray | None, optional\n        The data to duplicate. The default is None.\n\n    Returns\n    -------\n    NDArray\n        A new array with the data doubled in each direction\n    \"\"\"\n    new_data = np.tile(data, (2, 2, 2))\n    return new_data\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.get_box_around_point","title":"<code>get_box_around_point(point, neighbor_size=1)</code>","text":"<p>Gets a box around a given point taking into account wrapping at cell boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>NDArray</code> <p>The indices of the point to get a box around.</p> required <code>neighbor_size</code> <code>int</code> <p>The size of the box on either side of the point. The default is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>A slice of the grid taken around the provided point.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def get_box_around_point(self, point: NDArray, neighbor_size: int = 1) -&gt; NDArray:\n    \"\"\"\n    Gets a box around a given point taking into account wrapping at cell\n    boundaries.\n\n    Parameters\n    ----------\n    point : NDArray\n        The indices of the point to get a box around.\n    neighbor_size : int, optional\n        The size of the box on either side of the point. The default is 1.\n\n    Returns\n    -------\n    NDArray\n        A slice of the grid taken around the provided point.\n\n    \"\"\"\n\n    slices = []\n    for dim, c in zip(self.shape, point):\n        idx = np.arange(c - neighbor_size, c + 2) % dim\n        idx = idx.astype(int)\n        slices.append(idx)\n    return self.total[np.ix_(slices[0], slices[1], slices[2])]\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.get_points_in_radius","title":"<code>get_points_in_radius(point, radius)</code>","text":"<p>Gets the indices of the points in a radius around a point</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>The radius in cartesian distance units to find indices around the point.</p> required <code>point</code> <code>NDArray</code> <p>The indices of the point to perform the operation on.</p> required <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>The point indices in the sphere around the provided point.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def get_points_in_radius(\n    self,\n    point: NDArray,\n    radius: float,\n) -&gt; NDArray[int]:\n    \"\"\"\n    Gets the indices of the points in a radius around a point\n\n    Parameters\n    ----------\n    radius : float\n        The radius in cartesian distance units to find indices around the\n        point.\n    point : NDArray\n        The indices of the point to perform the operation on.\n\n    Returns\n    -------\n    NDArray[int]\n        The point indices in the sphere around the provided point.\n\n    \"\"\"\n    point = np.array(point)\n    # Get the distance from each point to the origin\n    point_distances = self.point_dists\n\n    # Get the indices that are within the radius\n    sphere_indices = np.where(point_distances &lt;= radius)\n    sphere_indices = np.column_stack(sphere_indices)\n\n    # Get indices relative to the point\n    sphere_indices = sphere_indices + point\n    # adjust points to wrap around grid\n    # line = [[round(float(a % b), 12) for a, b in zip(position, grid_data.shape)]]\n    new_x = (sphere_indices[:, 0] % self.shape[0]).astype(int)\n    new_y = (sphere_indices[:, 1] % self.shape[1]).astype(int)\n    new_z = (sphere_indices[:, 2] % self.shape[2]).astype(int)\n    sphere_indices = np.column_stack([new_x, new_y, new_z])\n    # return new_x, new_y, new_z\n    return sphere_indices\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.get_transformation_in_radius","title":"<code>get_transformation_in_radius(radius)</code>","text":"<p>Gets the transformations required to move from a point to the points surrounding it within the provided radius</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>The radius in cartesian distance units around the voxel.</p> required <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>An array of transformations to add to a point to get to each of the points within the radius surrounding it.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def get_transformation_in_radius(self, radius: float) -&gt; NDArray[int]:\n    \"\"\"\n    Gets the transformations required to move from a point to the points\n    surrounding it within the provided radius\n\n    Parameters\n    ----------\n    radius : float\n        The radius in cartesian distance units around the voxel.\n\n    Returns\n    -------\n    NDArray[int]\n        An array of transformations to add to a point to get to each of the\n        points within the radius surrounding it.\n\n    \"\"\"\n    # Get voxels around origin\n    voxel_distances = self.point_dists\n    # sphere_grid = np.where(voxel_distances &lt;= radius, True, False)\n    # eroded_grid = binary_erosion(sphere_grid)\n    # shell_indices = np.where(sphere_grid!=eroded_grid)\n    shell_indices = np.where(voxel_distances &lt;= radius)\n    # Now we want to translate these indices to next to the corner so that\n    # we can use them as transformations to move a voxel to the edge\n    final_shell_indices = []\n    for a, x in zip(self.shape, shell_indices):\n        new_x = x - a\n        abs_new_x = np.abs(new_x)\n        new_x_filter = abs_new_x &lt; x\n        final_x = np.where(new_x_filter, new_x, x)\n        final_shell_indices.append(final_x)\n\n    return np.column_stack(final_shell_indices)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.get_voxel_coords_from_index","title":"<code>get_voxel_coords_from_index(site)</code>","text":"<p>Takes in an atom's site index and returns the equivalent voxel grid index.</p> <p>Parameters:</p> Name Type Description Default <code>site</code> <code>int</code> <p>The index of the site to find the grid index for.</p> required <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>A voxel grid index.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def get_voxel_coords_from_index(self, site: int) -&gt; NDArray[int]:\n    \"\"\"\n    Takes in an atom's site index and returns the equivalent voxel grid index.\n\n    Parameters\n    ----------\n    site : int\n        The index of the site to find the grid index for.\n\n    Returns\n    -------\n    NDArray[int]\n        A voxel grid index.\n\n    \"\"\"\n    return self.frac_to_grid(self.structure[site].frac_coords)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.get_voxel_coords_from_neigh","title":"<code>get_voxel_coords_from_neigh(neigh)</code>","text":"<p>Gets the voxel grid index from a neighbor atom object from the pymatgen structure.get_neighbors class.</p> <p>Parameters:</p> Name Type Description Default <code>neigh</code> <code>dict</code> <p>A neighbor dictionary from pymatgens structure.get_neighbors method.</p> required <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>A voxel grid index as an array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def get_voxel_coords_from_neigh(self, neigh: dict) -&gt; NDArray[int]:\n    \"\"\"\n    Gets the voxel grid index from a neighbor atom object from the pymatgen\n    structure.get_neighbors class.\n\n    Parameters\n    ----------\n    neigh : dict\n        A neighbor dictionary from pymatgens structure.get_neighbors\n        method.\n\n    Returns\n    -------\n    NDArray[int]\n        A voxel grid index as an array.\n\n    \"\"\"\n\n    grid_size = self.shape\n    frac_coords = neigh.frac_coords\n    voxel_coords = [a * b for a, b in zip(grid_size, frac_coords)]\n    # voxel positions go from 1 to (grid_size + 0.9999)\n    return np.array(voxel_coords)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.get_voxel_coords_from_neigh_CrystalNN","title":"<code>get_voxel_coords_from_neigh_CrystalNN(neigh)</code>","text":"<p>Gets the voxel grid index from a neighbor atom object from CrystalNN or VoronoiNN</p> <p>Parameters:</p> Name Type Description Default <code>neigh</code> <p>A neighbor type object from pymatgen.</p> required <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>A voxel grid index as an array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def get_voxel_coords_from_neigh_CrystalNN(self, neigh) -&gt; NDArray[int]:\n    \"\"\"\n    Gets the voxel grid index from a neighbor atom object from CrystalNN or\n    VoronoiNN\n\n    Parameters\n    ----------\n    neigh :\n        A neighbor type object from pymatgen.\n\n    Returns\n    -------\n    NDArray[int]\n        A voxel grid index as an array.\n\n    \"\"\"\n    grid_size = self.shape\n    frac = neigh[\"site\"].frac_coords\n    voxel_coords = [a * b for a, b in zip(grid_size, frac)]\n    # voxel positions go from 1 to (grid_size + 0.9999)\n    return np.array(voxel_coords)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.grid_to_cart","title":"<code>grid_to_cart(vox_coords)</code>","text":"<p>Takes in a voxel coordinates and returns the cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>vox_coords</code> <code>NDArray | list</code> <p>An Nx3 Array or 1D array of length 3.</p> required <p>Returns:</p> Type Description <code>NDArray[float]</code> <p>Cartesian coordinates as an Nx3 Array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def grid_to_cart(self, vox_coords: NDArray) -&gt; NDArray[float]:\n    \"\"\"\n    Takes in a voxel coordinates and returns the cartesian coordinates.\n\n    Parameters\n    ----------\n    vox_coords : NDArray | list\n        An Nx3 Array or 1D array of length 3.\n\n    Returns\n    -------\n    NDArray[float]\n        Cartesian coordinates as an Nx3 Array.\n\n    \"\"\"\n    frac_coords = self.grid_to_frac(vox_coords)\n    return self.frac_to_cart(frac_coords)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.grid_to_frac","title":"<code>grid_to_frac(vox_coords)</code>","text":"<p>Takes in a voxel coordinates and returns the fractional coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>vox_coords</code> <code>NDArray | list</code> <p>An Nx3 Array or 1D array of length 3.</p> required <p>Returns:</p> Type Description <code>NDArray[float]</code> <p>Fractional coordinates as an Nx3 Array.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def grid_to_frac(self, vox_coords: NDArray) -&gt; NDArray[float]:\n    \"\"\"\n    Takes in a voxel coordinates and returns the fractional coordinates.\n\n    Parameters\n    ----------\n    vox_coords : NDArray | list\n        An Nx3 Array or 1D array of length 3.\n\n    Returns\n    -------\n    NDArray[float]\n        Fractional coordinates as an Nx3 Array.\n\n    \"\"\"\n\n    return vox_coords / self.shape\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.label","title":"<code>label(input, structure=np.ones([3, 3, 3]))</code>  <code>staticmethod</code>","text":"<p>Uses scipy's ndimage package to label an array, and corrects for periodic boundaries</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>NDArray</code> <p>The array to label.</p> required <code>structure</code> <code>NDArray</code> <p>The structureing elemetn defining feature connections. The default is np.ones([3, 3, 3]).</p> <code>ones([3, 3, 3])</code> <p>Returns:</p> Type Description <code>NDArray[int]</code> <p>An array of the same shape as the original with labels for each unique feature.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>@staticmethod\ndef label(input: NDArray, structure: NDArray = np.ones([3, 3, 3])) -&gt; NDArray[int]:\n    \"\"\"\n    Uses scipy's ndimage package to label an array, and corrects for\n    periodic boundaries\n\n    Parameters\n    ----------\n    input : NDArray\n        The array to label.\n    structure : NDArray, optional\n        The structureing elemetn defining feature connections.\n        The default is np.ones([3, 3, 3]).\n\n    Returns\n    -------\n    NDArray[int]\n        An array of the same shape as the original with labels for each unique\n        feature.\n\n    \"\"\"\n\n    if structure is not None:\n        labeled_array, _ = label(input, structure)\n        if len(np.unique(labeled_array)) == 1:\n            # there is one feature or no features\n            return labeled_array\n        # Features connected through opposite sides of the unit cell should\n        # have the same label, but they don't currently. To handle this, we\n        # pad our featured grid, re-label it, and check if the new labels\n        # contain multiple of our previous labels.\n        padded_featured_grid = np.pad(labeled_array, 1, \"wrap\")\n        relabeled_array, label_num = label(padded_featured_grid, structure)\n    else:\n        labeled_array, _ = label(input)\n        padded_featured_grid = np.pad(labeled_array, 1, \"wrap\")\n        relabeled_array, label_num = label(padded_featured_grid)\n\n    # We want to keep track of which features are connected to each other\n    unique_connections = [[] for i in range(len(np.unique(labeled_array)))]\n\n    for i in np.unique(relabeled_array):\n        # for i in range(label_num):\n        # Get the list of features that are in this super feature\n        mask = relabeled_array == i\n        connected_features = list(np.unique(padded_featured_grid[mask]))\n        # Iterate over these features. If they exist in a connection that we\n        # already have, we want to extend the connection to include any other\n        # features in this super feature\n        for j in connected_features:\n\n            unique_connections[j].extend([k for k in connected_features if k != j])\n\n            unique_connections[j] = list(np.unique(unique_connections[j]))\n\n    # create set/list to keep track of which features have already been connected\n    # to others and the full list of connections\n    already_connected = set()\n    reduced_connections = []\n\n    # loop over each shared connection\n    for i in range(len(unique_connections)):\n        if i in already_connected:\n            # we've already done these connections, so we skip\n            continue\n        # create sets of connections to compare with as we add more\n        connections = set()\n        new_connections = set(unique_connections[i])\n        while connections != new_connections:\n            # loop over the connections we've found so far. As we go, add\n            # any features we encounter to our set.\n            connections = new_connections.copy()\n            for j in connections:\n                already_connected.add(j)\n                new_connections.update(unique_connections[j])\n\n        # If we found any connections, append them to our list of reduced connections\n        if connections:\n            reduced_connections.append(sorted(new_connections))\n\n    # For each set of connections in our reduced set, relabel all values to\n    # the lowest one.\n    for connections in reduced_connections:\n        connected_features = np.unique(connections)\n        lowest_idx = connected_features[0]\n        for higher_idx in connected_features[1:]:\n            labeled_array = np.where(\n                labeled_array == higher_idx, lowest_idx, labeled_array\n            )\n\n    # Now we reduce the feature labels so that they start at 0\n    for i, j in enumerate(np.unique(labeled_array)):\n        labeled_array = np.where(labeled_array == j, i, labeled_array)\n\n    return labeled_array\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.linear_add","title":"<code>linear_add(other, scale_factor=1.0)</code>","text":"<p>Method to do a linear sum of volumetric objects. Used by + and - operators as well. Returns a VolumetricData object containing the linear sum.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Grid</code> <p>Another Grid object</p> required <code>scale_factor</code> <code>float</code> <p>Factor to scale the other data by</p> <code>1.0</code> <p>Returns:</p> Type Description <code>    Grid corresponding to self + scale_factor * other.</code> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def linear_add(self, other: Self, scale_factor=1.0) -&gt; Self:\n    \"\"\"\n    Method to do a linear sum of volumetric objects. Used by + and -\n    operators as well. Returns a VolumetricData object containing the\n    linear sum.\n\n    Parameters\n    ----------\n    other : Grid\n        Another Grid object\n    scale_factor : float\n        Factor to scale the other data by\n\n    Returns\n    -------\n        Grid corresponding to self + scale_factor * other.\n    \"\"\"\n    if self.structure != other.structure:\n        logging.warn(\n            \"Structures are different. Make sure you know what you are doing...\",\n            stacklevel=2,\n        )\n    if list(self.data) != list(other.data):\n        raise ValueError(\n            \"Data have different keys! Maybe one is spin-polarized and the other is not?\"\n        )\n\n    # To add checks\n    data = {}\n    for k in self.data:\n        data[k] = self.data[k] + scale_factor * other.data[k]\n\n    new = deepcopy(self)\n    new.data = data.copy()\n    new.data_aug = {}  # TODO: Can this be added somehow?\n    return new\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.linear_slice","title":"<code>linear_slice(p1, p2, n=100, method='cubic')</code>","text":"<p>Interpolates the data between two fractional coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>NDArray[float]</code> <p>The fractional coordinates of the first point</p> required <code>p2</code> <code>NDArray[float]</code> <p>The fractional coordinates of the second point</p> required <code>n</code> <code>int</code> <p>The number of points to collect along the line</p> <code>100</code> <code>method</code> <code>float</code> <p>The method to use for interpolation. nearest, linear, or cubic. The cubic method will calculate and store spline coefficients in an array the same size as the grid, which increases memory usage</p> <code>'cubic'</code> <code>Returns</code> <p>List of n data points (mostly interpolated) representing a linear slice of the data from point p1 to point p2.</p> required Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def linear_slice(\n    self, p1: NDArray[float], p2: NDArray[float], n: int = 100, method=\"cubic\"\n):\n    \"\"\"\n    Interpolates the data between two fractional coordinates.\n\n    Parameters\n    ----------\n    p1 : NDArray[float]\n        The fractional coordinates of the first point\n    p2 : NDArray[float]\n        The fractional coordinates of the second point\n    n : int, optional\n        The number of points to collect along the line\n    method : float\n        The method to use for interpolation. nearest, linear, or cubic. The\n        cubic method will calculate and store spline coefficients in an\n        array the same size as the grid, which increases memory usage\n\n    Returns:\n        List of n data points (mostly interpolated) representing a linear slice of the\n        data from point p1 to point p2.\n    \"\"\"\n    if type(p1) not in {list, np.ndarray}:\n        raise TypeError(\n            f\"type of p1 should be list or np.ndarray, got {type(p1).__name__}\"\n        )\n    if len(p1) != 3:\n        raise ValueError(f\"length of p1 should be 3, got {len(p1)}\")\n    if type(p2) not in {list, np.ndarray}:\n        raise TypeError(\n            f\"type of p2 should be list or np.ndarray, got {type(p2).__name__}\"\n        )\n    if len(p2) != 3:\n        raise ValueError(f\"length of p2 should be 3, got {len(p2)}\")\n\n    x_pts = np.linspace(p1[0], p2[0], num=n)\n    y_pts = np.linspace(p1[1], p2[1], num=n)\n    z_pts = np.linspace(p1[2], p2[2], num=n)\n    frac_coords = np.column_stack((x_pts, y_pts, z_pts))\n    return self.values_at(frac_coords, method)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.regrid","title":"<code>regrid(desired_resolution=1200, new_shape=None, order=3)</code>","text":"<p>Returns a new grid resized using scipy's ndimage.zoom method</p> <p>Parameters:</p> Name Type Description Default <code>desired_resolution</code> <code>int</code> <p>The desired resolution in voxels/A^3. The default is 1200.</p> <code>1200</code> <code>new_shape</code> <code>array</code> <p>The new array shape. Takes precedence over desired_resolution. The default is None.</p> <code>None</code> <code>order</code> <code>int</code> <p>The order of spline interpolation to use. The default is 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new Grid object near the desired resolution.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def regrid(\n    self,\n    desired_resolution: int = 1200,\n    new_shape: np.array = None,\n    order: int = 3,\n) -&gt; Self:\n    \"\"\"\n    Returns a new grid resized using scipy's ndimage.zoom method\n\n    Parameters\n    ----------\n    desired_resolution : int, optional\n        The desired resolution in voxels/A^3. The default is 1200.\n    new_shape : np.array, optional\n        The new array shape. Takes precedence over desired_resolution. The default is None.\n    order : int, optional\n        The order of spline interpolation to use. The default is 3.\n\n    Returns\n    -------\n    Self\n        A new Grid object near the desired resolution.\n    \"\"\"\n\n    # get the original grid size and lattice volume.\n    shape = self.shape\n    volume = self.structure.volume\n\n    if new_shape is None:\n        # calculate how much the number of voxels along each unit cell must be\n        # multiplied to reach the desired resolution.\n        scale_factor = ((desired_resolution * volume) / shape.prod()) ** (1 / 3)\n\n        # calculate the new grid shape. round up to the nearest integer for each\n        # side\n        new_shape = np.around(shape * scale_factor).astype(np.int32)\n\n    # get the factor to zoom by\n    zoom_factor = new_shape / shape\n\n    # zoom each piece of data\n    new_data = {}\n    for key, data in self.data.items():\n        new_data[key] = zoom(\n            data, zoom_factor, order=order, mode=\"grid-wrap\", grid_mode=True\n        )\n\n    # TODO: Add augment data?\n    return Grid(structure=self.structure, data=new_data)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.split_to_spin","title":"<code>split_to_spin()</code>","text":"<p>Splits the grid to two Grid objects representing the spin up and spin down contributions</p> <p>Returns:</p> Type Description <code>tuple[Self, Self]</code> <p>The spin-up and spin-down Grid objects.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def split_to_spin(self) -&gt; tuple[Self, Self]:\n    \"\"\"\n    Splits the grid to two Grid objects representing the spin up and spin down contributions\n\n    Returns\n    -------\n    tuple[Self, Self]\n        The spin-up and spin-down Grid objects.\n\n    \"\"\"\n\n    # first check if the grid has spin parts\n    assert (\n        self.is_spin_polarized\n    ), \"Only one set of data detected. The grid cannot be split into spin up and spin down\"\n    assert not self.is_soc\n\n    # Now we get the separate data parts. If the data is ELF, the parts are\n    # stored as total=spin up and diff = spin down\n    if self.data_type == \"elf\":\n        logging.info(\n            \"Splitting Grid using ELFCAR conventions (spin-up in 'total', spin-down in 'diff')\"\n        )\n        spin_up_data = self.total.copy()\n        spin_down_data = self.diff.copy()\n    elif self.data_type == \"charge\":\n        logging.info(\n            \"Splitting Grid using CHGCAR conventions (spin-up + spin-down in 'total', spin-up - spin-down in 'diff')\"\n        )\n        spin_data = self.spin_data\n        # pymatgen uses some custom class as keys here\n        for key in spin_data.keys():\n            if key.value == 1:\n                spin_up_data = spin_data[key].copy()\n            elif key.value == -1:\n                spin_down_data = spin_data[key].copy()\n\n    # convert to dicts\n    spin_up_data = {\"total\": spin_up_data}\n    spin_down_data = {\"total\": spin_down_data}\n\n    # get augment data\n    aug_up_data = (\n        {\"total\": self.data_aug[\"total\"]} if \"total\" in self.data_aug else {}\n    )\n    aug_down_data = (\n        {\"total\": self.data_aug[\"diff\"]} if \"diff\" in self.data_aug else {}\n    )\n\n    spin_up_grid = Grid(\n        structure=self.structure.copy(),\n        data=spin_up_data,\n        data_aug=aug_up_data,\n        data_type=self.data_type,\n        source_format=self.source_format,\n    )\n    spin_down_grid = Grid(\n        structure=self.structure.copy(),\n        data=spin_down_data,\n        data_aug=aug_down_data,\n        data_type=self.data_type,\n        source_format=self.source_format,\n    )\n\n    return spin_up_grid, spin_down_grid\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.value_at","title":"<code>value_at(x, y, z, method='cubic')</code>","text":"<p>Get a data value from self.data at a given point (x, y, z) in terms of fractional lattice parameters. Will be interpolated using the provided method.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>Fraction of lattice vector a.</p> required <code>y</code> <code>float</code> <p>Fraction of lattice vector b.</p> required <code>z</code> <code>float</code> <p>Fraction of lattice vector c.</p> required <code>method</code> <code>float</code> <p>The method to use for interpolation. nearest, linear, or cubic. The cubic method will calculate and store spline coefficients in an array the same size as the grid, which increases memory usage</p> <code>'cubic'</code> <p>Returns:</p> Type Description <code>float</code> <p>Value from self.data (potentially interpolated) corresponding to the point (x, y, z).</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def value_at(\n    self,\n    x: float,\n    y: float,\n    z: float,\n    method: str = \"cubic\",\n):\n    \"\"\"Get a data value from self.data at a given point (x, y, z) in terms\n    of fractional lattice parameters. Will be interpolated using the\n    provided method.\n\n    Parameters\n    ----------\n    x : float\n        Fraction of lattice vector a.\n    y: float\n        Fraction of lattice vector b.\n    z: float\n        Fraction of lattice vector c.\n    method : float\n        The method to use for interpolation. nearest, linear, or cubic. The\n        cubic method will calculate and store spline coefficients in an\n        array the same size as the grid, which increases memory usage\n\n    Returns\n    -------\n    float\n        Value from self.data (potentially interpolated) corresponding to\n        the point (x, y, z).\n    \"\"\"\n    if method == \"cubic\":\n        data = self.cubic_spline_coeffs\n    else:\n        data = self.total\n\n    interpolator = Interpolator(\n        data=data,\n        method=method,\n    )\n    # interpolate value\n    return interpolator([x, y, z])[0]\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.values_at","title":"<code>values_at(frac_coords, method='cubic')</code>","text":"<p>Interpolates the value of the data at each fractional coordinate in a given list or array.</p> <p>Parameters:</p> Name Type Description Default <code>frac_coords</code> <code>NDArray</code> <p>The fractional coordinates to interpolate values at with shape N, 3.</p> required <code>method</code> <code>float</code> <p>The method to use for interpolation. nearest, linear, or cubic. The cubic method will calculate and store spline coefficients in an array the same size as the grid, which increases memory usage</p> <code>'cubic'</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>The interpolated value at each fractional coordinate.</p> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def values_at(\n    self,\n    frac_coords: NDArray[float],\n    method: str = \"cubic\",\n) -&gt; list[float]:\n    \"\"\"\n    Interpolates the value of the data at each fractional coordinate in a\n    given list or array.\n\n    Parameters\n    ----------\n    frac_coords : NDArray\n        The fractional coordinates to interpolate values at with shape\n        N, 3.\n    method : float\n        The method to use for interpolation. nearest, linear, or cubic. The\n        cubic method will calculate and store spline coefficients in an\n        array the same size as the grid, which increases memory usage\n\n    Returns\n    -------\n    list[float]\n        The interpolated value at each fractional coordinate.\n\n    \"\"\"\n    if method == \"cubic\":\n        data = self.cubic_spline_coeffs\n    else:\n        data = self.total\n\n    interpolator = Interpolator(data=data, method=method)\n    # interpolate values\n    return interpolator(frac_coords)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.write","title":"<code>write(filename, output_format=None, **kwargs)</code>","text":"<p>Writes the Grid to the requested format file at the provided path. If no format is provided, uses this Grid objects stored format.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path | str</code> <p>The name of the file to write to.</p> required <code>output_format</code> <code>Format | str</code> <p>The format to write with. If None, writes to source format stored in this Grid objects metadata. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def write(\n    self,\n    filename: Path | str,\n    output_format: Format | str = None,\n    **kwargs,\n):\n    \"\"\"\n    Writes the Grid to the requested format file at the provided path. If no\n    format is provided, uses this Grid objects stored format.\n\n    Parameters\n    ----------\n    filename : Path | str\n        The name of the file to write to.\n    output_format : Format | str\n        The format to write with. If None, writes to source format stored in\n        this Grid objects metadata.\n        Defaults to None.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # If no provided format, get from metadata\n    if output_format is None:\n        output_format = self.source_format\n    # Make sure format is a Format object not a string\n    output_format = Format(output_format)\n    # get the writing method corresponding to this output format\n    method_name = output_format.writer\n    # write the grid\n    getattr(self, method_name)(filename, **kwargs)\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.write_cube","title":"<code>write_cube(filename, **kwargs)</code>","text":"<p>Writes the Grid to a Gaussian cube-like file at the provided path.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path | str</code> <p>The name of the file to write to.</p> required <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def write_cube(\n    self,\n    filename: Path | str,\n    **kwargs,\n):\n    \"\"\"\n    Writes the Grid to a Gaussian cube-like file at the provided path.\n\n    Parameters\n    ----------\n    filename : Path | str\n        The name of the file to write to.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    filename = Path(filename)\n    logging.info(f\"Writing {filename.name}\")\n    write_cube_file(\n        filename=filename,\n        grid=self,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/core/grid/#src.baderkit.core.toolkit.grid.Grid.write_vasp","title":"<code>write_vasp(filename, vasp4_compatible=False)</code>","text":"<p>Writes the Grid to a VASP-like file at the provided path.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path | str</code> <p>The name of the file to write to.</p> required <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/core/toolkit/grid.py</code> <pre><code>def write_vasp(\n    self,\n    filename: Path | str,\n    vasp4_compatible: bool = False,\n):\n    \"\"\"\n    Writes the Grid to a VASP-like file at the provided path.\n\n    Parameters\n    ----------\n    filename : Path | str\n        The name of the file to write to.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    filename = Path(filename)\n    logging.info(f\"Writing {filename.name}\")\n    write_vasp_file(filename=filename, grid=self, vasp4_compatible=vasp4_compatible)\n</code></pre>"},{"location":"api_reference/plotting/bader/","title":"Bader","text":"<p>               Bases: <code>GridPlotter</code></p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>class BaderPlotter(GridPlotter):\n    def __init__(\n        self,\n        bader: Bader,\n        **grid_kwargs,\n    ):\n        \"\"\"\n        A convenience class for creating plots of individual Bader basins\n        using pyvista's package for VTK.\n\n        Parameters\n        ----------\n        bader : Bader\n            The Bader object to use for isolating basins and creating isosurfaces.\n            The structure will be pulled from the charge grid.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # apply StructurePlotter kwargs\n        grid = bader.charge_grid\n        super().__init__(grid=grid, **grid_kwargs)\n        self.bader = bader\n\n        # pad the label arrays then flatten them\n        padded_basins = np.pad(\n            bader.basin_labels, pad_width=((0, 1), (0, 1), (0, 1)), mode=\"wrap\"\n        )\n        padded_atoms = np.pad(\n            bader.atom_labels, pad_width=((0, 1), (0, 1), (0, 1)), mode=\"wrap\"\n        )\n        # padded_basins = bader.basin_labels\n        # padded_atoms = bader.atom_labels\n        self.flat_bader_basins = padded_basins.ravel(order=\"F\")\n        self.flat_atom_basins = padded_atoms.ravel(order=\"F\")\n\n        # get the initial empty list of visible atom labels and visible basin labels\n        self._visible_bader_basins = set(\n            [i for i, ai in enumerate(bader.basin_atoms) if ai == 0]\n        )\n        self._visible_atom_basins = set()\n        self.visible_bader_basins = [\n            i for i, ai in enumerate(bader.basin_atoms) if ai == 0\n        ]\n        self.visible_atom_basins = []\n        self._hidden_mask = np.zeros(len(self.flat_bader_basins), dtype=bool)\n\n    @property\n    def visible_bader_basins(self) -&gt; list[int]:\n        \"\"\"\n\n        Returns\n        -------\n        list[int]\n            A list of bader basin indices that are currently visible.\n\n        \"\"\"\n        return self._visible_bader_basins\n\n    @visible_bader_basins.setter\n    def visible_bader_basins(self, visible_bader_basins: set[int]):\n        # make sure input is set\n        visible_bader_basins = set(visible_bader_basins)\n        # set visible basins\n        self._visible_bader_basins = visible_bader_basins\n        # update plotter\n        self._update_plotter_mask()\n\n    @property\n    def visible_atom_basins(self) -&gt; list[int]:\n        \"\"\"\n\n        Returns\n        -------\n        list[int]\n            A list of atom indices whose basins are currently visible.\n\n        \"\"\"\n        return self._visible_atom_basins\n\n    @visible_atom_basins.setter\n    def visible_atom_basins(self, visible_atom_basins: set[int]):\n        # make sure input is set\n        visible_atom_basins = set(visible_atom_basins)\n        # update visible basins set\n        self._visible_atom_basins = visible_atom_basins\n        # update plotter\n        self._update_plotter_mask()\n\n    def _update_plotter_mask(self):\n        \"\"\"\n        Updates the mask indicating which areas of the grid should not be shown\n        then sets the regions to -1.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        hidden_mask = ~(\n            np.isin(self.flat_bader_basins, list(self._visible_bader_basins))\n            | np.isin(self.flat_atom_basins, list(self._visible_atom_basins))\n        )\n        self._hidden_mask = hidden_mask\n        # NOTE: using hide_cells works, but results in some funky artifacting.\n        # Maybe there's a way to get it to work, but for now I'm replacing it\n        # for visual quality\n        # self.structured_grid.hide_cells(self.hidden_mask, inplace=True)\n        # update structured_grid\n        temp_values = self.values.copy()\n        temp_values[hidden_mask] = -1\n        self.structured_grid = self._make_structured_grid(temp_values)\n        # update the surface\n        self.surface = self.structured_grid.extract_surface()\n        # update plotter\n        self.iso_val = self._iso_val\n</code></pre>"},{"location":"api_reference/plotting/bader/#src.baderkit.plotting.core.plotter.BaderPlotter.visible_atom_basins","title":"<code>visible_atom_basins</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>list[int]</code> <p>A list of atom indices whose basins are currently visible.</p>"},{"location":"api_reference/plotting/bader/#src.baderkit.plotting.core.plotter.BaderPlotter.visible_bader_basins","title":"<code>visible_bader_basins</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>list[int]</code> <p>A list of bader basin indices that are currently visible.</p>"},{"location":"api_reference/plotting/bader/#src.baderkit.plotting.core.plotter.BaderPlotter.__init__","title":"<code>__init__(bader, **grid_kwargs)</code>","text":"<p>A convenience class for creating plots of individual Bader basins using pyvista's package for VTK.</p> <p>Parameters:</p> Name Type Description Default <code>bader</code> <code>Bader</code> <p>The Bader object to use for isolating basins and creating isosurfaces. The structure will be pulled from the charge grid.</p> required <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def __init__(\n    self,\n    bader: Bader,\n    **grid_kwargs,\n):\n    \"\"\"\n    A convenience class for creating plots of individual Bader basins\n    using pyvista's package for VTK.\n\n    Parameters\n    ----------\n    bader : Bader\n        The Bader object to use for isolating basins and creating isosurfaces.\n        The structure will be pulled from the charge grid.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # apply StructurePlotter kwargs\n    grid = bader.charge_grid\n    super().__init__(grid=grid, **grid_kwargs)\n    self.bader = bader\n\n    # pad the label arrays then flatten them\n    padded_basins = np.pad(\n        bader.basin_labels, pad_width=((0, 1), (0, 1), (0, 1)), mode=\"wrap\"\n    )\n    padded_atoms = np.pad(\n        bader.atom_labels, pad_width=((0, 1), (0, 1), (0, 1)), mode=\"wrap\"\n    )\n    # padded_basins = bader.basin_labels\n    # padded_atoms = bader.atom_labels\n    self.flat_bader_basins = padded_basins.ravel(order=\"F\")\n    self.flat_atom_basins = padded_atoms.ravel(order=\"F\")\n\n    # get the initial empty list of visible atom labels and visible basin labels\n    self._visible_bader_basins = set(\n        [i for i, ai in enumerate(bader.basin_atoms) if ai == 0]\n    )\n    self._visible_atom_basins = set()\n    self.visible_bader_basins = [\n        i for i, ai in enumerate(bader.basin_atoms) if ai == 0\n    ]\n    self.visible_atom_basins = []\n    self._hidden_mask = np.zeros(len(self.flat_bader_basins), dtype=bool)\n</code></pre>"},{"location":"api_reference/plotting/grid/","title":"Grid","text":"<p>               Bases: <code>StructurePlotter</code></p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>class GridPlotter(StructurePlotter):\n    def __init__(\n        self,\n        grid: Grid,\n        **structure_kwargs,\n        # downscale: int | None = 400,\n    ):\n        \"\"\"\n        A convenience class for creating plots of crystal structures and isosurfaces\n        using pyvista's package for VTK.\n\n        Parameters\n        ----------\n        grid : Grid\n            The Grid object to use for isosurfaces. The structure will be pulled\n            from this grid.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # apply StructurePlotter kwargs\n        super().__init__(structure=grid.structure, **structure_kwargs)\n\n        # Grid specific items\n        # if downscale is not None:\n        #     if grid.voxel_resolution &gt; downscale:\n        #         # downscale the grid for speed\n        #         logging.info(\"Grid is above desired resolution. Downscaling.\")\n        #         grid = grid.regrid(downscale)\n        self.grid = grid\n        self._show_surface = True\n        self._show_caps = True\n        self._surface_opacity = 0.8\n        self._cap_opacity = 0.8\n        self._colormap = \"viridis\"\n        self._use_solid_surface_color = False\n        self._use_solid_cap_color = False\n        self._surface_color = \"#BA8E23\"\n        self._cap_color = \"#BA8E23\"\n\n        # wrap values around to get one extra voxel on the far side of each axis.\n        values = np.pad(grid.total, pad_width=((0, 1), (0, 1), (0, 1)), mode=\"wrap\")\n        self.shape = values.shape\n        self.values = values.ravel(order=\"F\")\n        self.min_val = self.values.min()\n        # make min val slightly above 0\n        self.min_val += +0.0000001 * self.min_val\n        self.max_val = self.values.max()\n        # determine default iso if not provided\n        self._iso_val = self.min_val  # np.mean(grid.total)\n        # generate the structured grid\n        indices = np.indices(self.shape).reshape(3, -1, order=\"F\").T\n        self.points = grid.grid_to_cart(indices)\n        self.structured_grid = self._make_structured_grid(self.values)\n        # generate the surface\n        self.surface = self.structured_grid.extract_surface()\n        # update plotter\n        self.plotter = self._create_grid_plot()\n\n    def _make_structured_grid(self, values: NDArray[float]) -&gt; pv.StructuredGrid:\n        \"\"\"\n        Creates a pyvista StructuredGrid object for making isosurfaces. This\n        should generally not be called directly.\n\n        Parameters\n        ----------\n        values : NDArray[float]\n            A 3xN array of values representing the data in the structured grid.\n            These should be raveled/reshaped using Fortran's conventions (order='F'')\n\n        Returns\n        -------\n        structured_grid : pv.StructuredGrid\n            A pyvista StructuredGrid with values representing the grid data.\n\n        \"\"\"\n        structured_grid = pv.StructuredGrid()\n        structured_grid.points = self.points\n        structured_grid.dimensions = self.shape\n        structured_grid[\"values\"] = values\n        return structured_grid\n\n    @property\n    def show_surface(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            whether or not to display the isosurface.\n\n        \"\"\"\n        return self._show_surface\n\n    @show_surface.setter\n    def show_surface(self, show_surface: bool):\n        if \"iso\" in self.plotter.actors.keys():\n            actor = self.plotter.actors[\"iso\"]\n            actor.visibility = show_surface\n        self._show_surface = show_surface\n\n    @property\n    def show_caps(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            Whether or not to display caps on the isosurface.\n\n        \"\"\"\n        return self._show_caps\n\n    @show_caps.setter\n    def show_caps(self, show_caps: bool):\n        if \"cap\" in self.plotter.actors.keys():\n            actor = self.plotter.actors[\"cap\"]\n            actor.visibility = show_caps\n        self._show_caps = show_caps\n\n    @property\n    def surface_opacity(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            Opacity of the isosurface.\n\n        \"\"\"\n        return self._surface_opacity\n\n    @surface_opacity.setter\n    def surface_opacity(self, surface_opacity: float):\n        if \"iso\" in self.plotter.actors.keys():\n            actor = self.plotter.actors[\"iso\"]\n            actor.prop.opacity = surface_opacity\n        self._surface_opacity = surface_opacity\n\n    @property\n    def cap_opacity(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            Opacity of the caps.\n\n        \"\"\"\n        return self._cap_opacity\n\n    @cap_opacity.setter\n    def cap_opacity(self, cap_opacity: float):\n        if \"cap\" in self.plotter.actors.keys():\n            actor = self.plotter.actors[\"cap\"]\n            actor.prop.opacity = cap_opacity\n        self._cap_opacity = cap_opacity\n\n    @property\n    def colormap(self) -&gt; str:\n        \"\"\"\n\n        Returns\n        -------\n        str\n            The colormap for the caps and isosurface. This is ignored when the\n            surface or caps are set to use solid colors. Valid options are those\n            available in matplotlib.\n\n        \"\"\"\n        return self._colormap\n\n    @colormap.setter\n    def colormap(self, colormap: str):\n        # update settings\n        self._colormap = colormap\n        if not self.use_solid_surface_color:\n            self._add_iso_mesh()\n        if not self.use_solid_cap_color:\n            self._add_cap_mesh()\n\n    @property\n    def use_solid_surface_color(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            whether or not to use a solid color for the isosurface.\n        \"\"\"\n        return self._use_solid_surface_color\n\n    # TODO: Figure out a way to set the cmap without remaking the surface?\n    @use_solid_surface_color.setter\n    def use_solid_surface_color(self, use_solid_surface_color: bool):\n        # update property\n        self._use_solid_surface_color = use_solid_surface_color\n        # remove surface and add it back with new color/cmap\n        self._add_iso_mesh()\n\n    @property\n    def use_solid_cap_color(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            whether or not to use a solid color for the caps.\n        \"\"\"\n        return self._use_solid_cap_color\n\n    @use_solid_cap_color.setter\n    def use_solid_cap_color(self, use_solid_cap_color: bool):\n        # update property\n        self._use_solid_cap_color = use_solid_cap_color\n        # remove cap and add it back with new color/cmap\n        self._add_cap_mesh()\n\n    @property\n    def surface_color(self) -&gt; str:\n        \"\"\"\n\n        Returns\n        -------\n        str\n            The color to use for the surface as a hex string. This is ignored if\n            the surface is not set to use solid colors.\n\n        \"\"\"\n        return self._surface_color\n\n    @surface_color.setter\n    def surface_color(self, surface_color: str):\n        self._surface_color = surface_color\n        if self.use_solid_surface_color:\n            self._add_iso_mesh()\n\n    @property\n    def cap_color(self):\n        \"\"\"\n\n        Returns\n        -------\n        str\n            The color to use for the caps as a hex string. This is ignored if\n            the caps are not set to use solid colors.\n\n        \"\"\"\n        return self._cap_color\n\n    @cap_color.setter\n    def cap_color(self, cap_color: str):\n        self._cap_color = cap_color\n        if self.use_solid_cap_color:\n            self._add_cap_mesh()\n\n    @property\n    def iso_val(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The value to set the isosurface to.\n\n        \"\"\"\n        return self._iso_val\n\n    @iso_val.setter\n    def iso_val(self, iso_val: float):\n        # make sure iso value is within range\n        iso_val = max(self.min_val, min(iso_val, self.max_val))\n        self._iso_val = iso_val\n        self._update_surface_mesh(iso_val)\n        self._add_iso_mesh()\n        self._add_cap_mesh()\n\n    def _update_surface_mesh(self, iso_value: float):\n        \"\"\"\n        Updates the surface meshes to the provided iso_value\n\n        Parameters\n        ----------\n        iso_value : float\n            The value to update the surface meshes to\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        self.iso = self.structured_grid.contour([iso_value])\n        self.cap = self.surface.contour_banded(\n            2, rng=[iso_value, self.max_val], generate_contour_edges=False\n        )\n\n    def _get_surface_kwargs(self) -&gt; dict:\n        \"\"\"\n        Generates the keyword arguments to use when adding the surface to\n        the plotter. We need this because setting a solid color vs. a colormap\n        requires different keywords\n\n        Returns\n        -------\n        dict\n            The keyword arguments for setting the surface mesh in the plotter.\n\n        \"\"\"\n        kwargs = {\n            \"opacity\": self.surface_opacity,\n            \"pbr\": True,\n            \"name\": \"iso\",\n        }\n        kwargs[\"color\"] = self.surface_color\n        if self.use_solid_surface_color:\n            kwargs[\"color\"] = self.surface_color\n        else:\n            kwargs[\"colormap\"] = self.colormap\n            kwargs[\"scalars\"] = \"values\"\n            kwargs[\"clim\"] = [self.min_val, self.max_val]\n            kwargs[\"show_scalar_bar\"] = False\n        return kwargs\n\n    def _get_cap_kwargs(self) -&gt; dict:\n        \"\"\"\n        Generates the keyword arguments to use when adding the caps to\n        the plotter. We need this because setting a solid color vs. a colormap\n        requires different keywords\n\n        Returns\n        -------\n        dict\n            The keyword arguments for setting the caps mesh in the plotter.\n\n        \"\"\"\n        kwargs = {\n            \"opacity\": self.cap_opacity,\n            \"pbr\": True,\n            \"name\": \"cap\",\n        }\n        if self.use_solid_cap_color:\n            kwargs[\"color\"] = self.cap_color\n        else:\n            kwargs[\"cmap\"] = self.colormap\n            kwargs[\"scalars\"] = \"values\"\n            kwargs[\"clim\"] = [self.min_val, self.max_val]\n            kwargs[\"show_scalar_bar\"] = False\n        return kwargs\n\n    def _add_iso_mesh(self):\n        \"\"\"\n        Removes the current isosurface mesh than adds a new one.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        if self.show_surface:\n            if \"iso\" in self.plotter.actors.keys():\n                self.plotter.remove_actor(\"iso\")\n            if len(self.iso[\"values\"]) &gt; 0:\n                self.plotter.add_mesh(self.iso, **self._get_surface_kwargs())\n\n    def _add_cap_mesh(self) -&gt; dict:\n        \"\"\"\n        Removes the current cap mesh than adds a new one.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        if self.show_caps:\n            if \"cap\" in self.plotter.actors.keys():\n                self.plotter.remove_actor(\"cap\")\n            if len(self.iso[\"values\"]) &gt; 0:\n                self.plotter.add_mesh(self.cap, **self._get_cap_kwargs())\n\n    def _create_grid_plot(self) -&gt; pv.Plotter():\n        \"\"\"\n        Generates a pyvista.Plotter object from the current class variables.\n        This is called when the class is first instanced and generally shouldn't\n        be called again.\n\n        Returns\n        -------\n        plotter : pv.Plotter\n            A pyvista Plotter object representing the provided Structure object.\n\n        \"\"\"\n        # get initial plotter with structure\n        plotter = self._create_structure_plot()\n        # generate initial surface meshes\n        self._update_surface_mesh(self.iso_val)\n        # Add iso mesh\n        if len(self.iso[\"values\"]) &gt; 0:\n            plotter.add_mesh(self.iso, **self._get_surface_kwargs())\n        # Add cap mesh\n        if len(self.cap[\"values\"]) &gt; 0:\n            plotter.add_mesh(self.cap, **self._get_cap_kwargs())\n        return plotter\n\n    def rebuild(self):\n        \"\"\"\n        Builds a new pyvista plotter object representing the current state of\n        the Plotter class.\n\n        Returns\n        -------\n        pv.Plotter\n            A pyvista Plotter object representing the current state of the\n            GridPlotter class.\n\n        \"\"\"\n        return self._create_grid_plot()\n</code></pre>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.cap_color","title":"<code>cap_color</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The color to use for the caps as a hex string. This is ignored if the caps are not set to use solid colors.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.cap_opacity","title":"<code>cap_opacity</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>Opacity of the caps.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.colormap","title":"<code>colormap</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The colormap for the caps and isosurface. This is ignored when the surface or caps are set to use solid colors. Valid options are those available in matplotlib.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.iso_val","title":"<code>iso_val</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The value to set the isosurface to.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.show_caps","title":"<code>show_caps</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to display caps on the isosurface.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.show_surface","title":"<code>show_surface</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>whether or not to display the isosurface.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.surface_color","title":"<code>surface_color</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The color to use for the surface as a hex string. This is ignored if the surface is not set to use solid colors.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.surface_opacity","title":"<code>surface_opacity</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>Opacity of the isosurface.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.use_solid_cap_color","title":"<code>use_solid_cap_color</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>whether or not to use a solid color for the caps.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.use_solid_surface_color","title":"<code>use_solid_surface_color</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>whether or not to use a solid color for the isosurface.</p>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.__init__","title":"<code>__init__(grid, **structure_kwargs)</code>","text":"<p>A convenience class for creating plots of crystal structures and isosurfaces using pyvista's package for VTK.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>Grid</code> <p>The Grid object to use for isosurfaces. The structure will be pulled from this grid.</p> required <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def __init__(\n    self,\n    grid: Grid,\n    **structure_kwargs,\n    # downscale: int | None = 400,\n):\n    \"\"\"\n    A convenience class for creating plots of crystal structures and isosurfaces\n    using pyvista's package for VTK.\n\n    Parameters\n    ----------\n    grid : Grid\n        The Grid object to use for isosurfaces. The structure will be pulled\n        from this grid.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # apply StructurePlotter kwargs\n    super().__init__(structure=grid.structure, **structure_kwargs)\n\n    # Grid specific items\n    # if downscale is not None:\n    #     if grid.voxel_resolution &gt; downscale:\n    #         # downscale the grid for speed\n    #         logging.info(\"Grid is above desired resolution. Downscaling.\")\n    #         grid = grid.regrid(downscale)\n    self.grid = grid\n    self._show_surface = True\n    self._show_caps = True\n    self._surface_opacity = 0.8\n    self._cap_opacity = 0.8\n    self._colormap = \"viridis\"\n    self._use_solid_surface_color = False\n    self._use_solid_cap_color = False\n    self._surface_color = \"#BA8E23\"\n    self._cap_color = \"#BA8E23\"\n\n    # wrap values around to get one extra voxel on the far side of each axis.\n    values = np.pad(grid.total, pad_width=((0, 1), (0, 1), (0, 1)), mode=\"wrap\")\n    self.shape = values.shape\n    self.values = values.ravel(order=\"F\")\n    self.min_val = self.values.min()\n    # make min val slightly above 0\n    self.min_val += +0.0000001 * self.min_val\n    self.max_val = self.values.max()\n    # determine default iso if not provided\n    self._iso_val = self.min_val  # np.mean(grid.total)\n    # generate the structured grid\n    indices = np.indices(self.shape).reshape(3, -1, order=\"F\").T\n    self.points = grid.grid_to_cart(indices)\n    self.structured_grid = self._make_structured_grid(self.values)\n    # generate the surface\n    self.surface = self.structured_grid.extract_surface()\n    # update plotter\n    self.plotter = self._create_grid_plot()\n</code></pre>"},{"location":"api_reference/plotting/grid/#src.baderkit.plotting.core.plotter.GridPlotter.rebuild","title":"<code>rebuild()</code>","text":"<p>Builds a new pyvista plotter object representing the current state of the Plotter class.</p> <p>Returns:</p> Type Description <code>Plotter</code> <p>A pyvista Plotter object representing the current state of the GridPlotter class.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def rebuild(self):\n    \"\"\"\n    Builds a new pyvista plotter object representing the current state of\n    the Plotter class.\n\n    Returns\n    -------\n    pv.Plotter\n        A pyvista Plotter object representing the current state of the\n        GridPlotter class.\n\n    \"\"\"\n    return self._create_grid_plot()\n</code></pre>"},{"location":"api_reference/plotting/structure/","title":"Structure","text":"Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>class StructurePlotter:\n\n    def __init__(\n        self,\n        structure: Structure,\n        off_screen: bool = False,\n        qt_plotter: bool = False,\n        qt_frame=None,\n        **kwargs,\n    ):\n        \"\"\"\n        A convenience class for creating plots of crystal structures using\n        pyvista's package for VTK.\n\n        Parameters\n        ----------\n        structure : Structure\n            The pymatgen Structure object to plot.\n        off_screen : bool, optional\n            Whether or not the plotter should be in offline mode. The default is False.\n        qt_plotter : bool, optional\n            Whether or not the plotter will use pyvistaqt for qt applications\n        qt_frame\n            If using pyvistaqt, the QFrame to link the plotter to.\n\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        # sort and relabel structure for consistency\n        structure = structure.copy()\n        structure.sort()\n        structure.relabel_sites()\n        # create initial class variables\n        self.structure = structure\n        self.off_screen = off_screen\n        self.qt_plotter = qt_plotter\n        self.qt_frame = qt_frame\n        self._visible_atoms = [i for i in range(len(self.structure))]\n        self._show_lattice = True\n        self._wrap_atoms = True\n        self._lattice_thickness = 0.1\n        self._atom_metallicness = 0.0\n        self._background = \"#FFFFFF\"\n        self._view_indices = [1, 0, 0]\n        self._camera_rotation = (0.0,)\n        self._show_axes = True\n        self._parallel_projection = True\n        self._radii = [s.specie.atomic_radius for s in structure]\n        self._colors = [ATOM_COLORS.get(s.specie.symbol, \"#FFFFFF\") for s in structure]\n        # generate initial plotter\n        self.plotter = self._create_structure_plot()\n        self.view_indices = [1, 0, 0]\n        self.up_indices = [0, 0, 1]\n\n    ###########################################################################\n    # Properties and Setters\n    ###########################################################################\n    @property\n    def visible_atoms(self) -&gt; list[int]:\n        \"\"\"\n\n        Returns\n        -------\n        list[int]\n            A list of atom indices to display in the plot.\n\n        \"\"\"\n        return self._visible_atoms\n\n    @visible_atoms.setter\n    def visible_atoms(self, visible_atoms: list[int]):\n        # update visibility of atoms\n        for i, site in enumerate(self.structure):\n            label = site.label\n            actor = self.plotter.actors[f\"{label}\"]\n            if i in visible_atoms:\n                actor.visibility = True\n            else:\n                actor.visibility = False\n        # set visible atoms\n        self._visible_atoms = visible_atoms\n\n    @property\n    def show_lattice(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            Whether or not to display the outline of the unit cell.\n\n        \"\"\"\n        return self._show_lattice\n\n    @show_lattice.setter\n    def show_lattice(self, show_lattice: bool):\n        actor = self.plotter.actors[\"lattice\"]\n        actor.visibility = show_lattice\n        self._show_lattice = show_lattice\n\n    # @property\n    # def wrap_atoms(self):\n    #     return self._wrap_atoms\n\n    # TODO: Make two sets of atoms with and without wraps?\n    # @wrap_atoms.setter\n    # def wrap_atoms(self, wrap_atoms: bool):\n    #     actor = self.plotter.\n\n    @property\n    def lattice_thickness(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The thickness of the lines outlining the unit cell.\n\n        \"\"\"\n        return self._lattice_thickness\n\n    @lattice_thickness.setter\n    def lattice_thickness(self, lattice_thickness: float):\n        actor = self.plotter.actors[\"lattice\"]\n        actor.prop.line_width = lattice_thickness\n        self._lattice_thickness = lattice_thickness\n\n    @property\n    def atom_metallicness(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The amount of metallic character in the atom display.\n\n        \"\"\"\n        return self._atom_metallicness\n\n    @atom_metallicness.setter\n    def atom_metallicness(self, atom_metallicness: float):\n        # update all atoms\n        for site in self.structure:\n            label = site.label\n            actor = self.plotter.actors[f\"{label}\"]\n            actor.prop.metallic = atom_metallicness\n        self._atom_metallicness = atom_metallicness\n\n    @property\n    def background(self) -&gt; str:\n        \"\"\"\n\n        Returns\n        -------\n        str\n            The color of the plot background as a hex code.\n\n        \"\"\"\n        return self._background\n\n    @background.setter\n    def background(self, background: str):\n        self.plotter.set_background(background)\n        self._background = background\n\n    @property\n    def show_axes(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            Whether or not to show the axis widget. Note this currently only\n            displays the cartesian axes.\n\n        \"\"\"\n        return self._show_axes\n\n    @show_axes.setter\n    def show_axes(self, show_axes: bool):\n        if show_axes:\n            self.plotter.add_axes()\n        else:\n            self.plotter.hide_axes()\n        self._show_axes = show_axes\n\n    @property\n    def parallel_projection(self) -&gt; bool:\n        \"\"\"\n\n        Returns\n        -------\n        bool\n            If True, a parallel projection scheme will be used rather than\n            perspective.\n\n        \"\"\"\n        return self._parallel_projection\n\n    @parallel_projection.setter\n    def parallel_projection(self, parallel_projection: bool):\n        if parallel_projection:\n            self.plotter.renderer.enable_parallel_projection()\n        else:\n            self.plotter.renderer.disable_parallel_projection()\n        self._parallel_projection = parallel_projection\n\n    @property\n    def radii(self) -&gt; list[float]:\n        \"\"\"\n\n        Returns\n        -------\n        list[float]\n            The radius to display for each atom in the structure. The actual\n            displayed radius will be 0.3*radius.\n\n        \"\"\"\n        return self._radii\n\n    @radii.setter\n    def radii(self, radii: list[float]):\n        # fix radii to be a list and make any negative values == 0.01\n        radii = list(radii)\n        for i, val in enumerate(radii):\n            if val &lt;= 0:\n                radii[i] = 0.01\n        # check which radii have changed and replace these atoms\n        old_radii = self.radii\n        # update radii\n        self._radii = radii\n        # for each site, check if the radius has changed and if it has remove it\n        # then remake\n        for i, (site, old_r, new_r, color) in enumerate(\n            zip(self.structure, old_radii, radii, self.colors)\n        ):\n            if old_r == new_r:\n                continue\n            # otherwise remove the actor, regenerate, and replot\n            self.plotter.remove_actor(f\"{site.label}\")\n            atom_mesh = self.get_site_mesh(i)\n            self.plotter.add_mesh(\n                atom_mesh,\n                color=color,\n                metallic=self.atom_metallicness,\n                pbr=True,  # enable physical based rendering\n                name=f\"{site.label}\",\n            )\n\n    @property\n    def colors(self) -&gt; list[str]:\n        \"\"\"\n\n        Returns\n        -------\n        list[str]\n            The colors to use for each atom as hex codes.\n\n        \"\"\"\n        return self._colors\n\n    @colors.setter\n    def colors(self, colors: list[str]):\n        # for each site, check if the radius has changed and if it has remove it\n        # then remake\n        for site, old_color, new_color in zip(self.structure, self.colors, colors):\n            if old_color == new_color:\n                continue\n            actor = self.plotter.actors[f\"{site.label}\"]\n            actor.prop.color = new_color\n        self._colors = colors\n\n    @property\n    def atom_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n\n        Returns\n        -------\n        atom_df : TYPE\n            A dataframe summarizing the properties of the atom meshes.\n\n        \"\"\"\n        # construct a pandas dataframe for each atom\n        visible = []\n        for i in range(len(self.structure)):\n            if i in self.visible_atoms:\n                visible.append(True)\n            else:\n                visible.append(False)\n        atom_df = pd.DataFrame(\n            {\n                \"Label\": self.structure.labels,\n                \"Visible\": visible,\n                \"Color\": self.colors,\n                \"Radius\": self.radii,\n            }\n        )\n        return atom_df\n\n    @atom_df.setter\n    def atom_df(self, atom_df: pd.DataFrame):\n        visible = atom_df[\"Visible\"]\n        visible_atoms = []\n        for i, val in enumerate(visible):\n            if val == True:\n                visible_atoms.append(i)\n        # set each property from the dataframe\n        self.visible_atoms = visible_atoms\n        self.colors = atom_df[\"Color\"]\n        self.radii = atom_df[\"Radius\"]\n\n    @property\n    def view_indices(self) -&gt; NDArray[int]:\n        \"\"\"\n\n        Returns\n        -------\n        NDArray[int]\n            The miller indices of the plane that the camera is perpendicular to.\n\n        \"\"\"\n        return self._view_indices\n\n    @view_indices.setter\n    def view_indices(self, view_indices: NDArray[int]):\n        assert len(view_indices) == 3 and all(\n            type(i) == int for i in view_indices\n        ), \"View indices must be an array or list of miller indices\"\n        h, k, l = view_indices\n        camera_position = self.get_camera_position_from_miller(\n            h, k, l, self.camera_rotation\n        )\n        self.camera_position = camera_position\n        # reset the camera zoom so that it fits the screen\n        self.plotter.reset_camera()\n        self._view_indices = view_indices\n\n    @property\n    def camera_rotation(self) -&gt; float:\n        \"\"\"\n\n        Returns\n        -------\n        float\n            The rotation of the camera from the default. The default is to set\n            the camera so that the upwards view is as close to the z axis as\n            possible, or the y axis if the view indices are perpendicular to z.\n\n        \"\"\"\n        return self._camera_rotation\n\n    @camera_rotation.setter\n    def camera_rotation(self, camera_rotation: float):\n        h, k, l = self.view_indices\n        camera_position = self.get_camera_position_from_miller(h, k, l, camera_rotation)\n        self.camera_position = camera_position\n        # reset the camera zoom so that it fits the screen\n        self.plotter.reset_camera()\n        self._camera_rotation = camera_rotation\n\n    @property\n    def camera_position(self) -&gt; list[tuple, tuple, tuple]:\n        \"\"\"\n\n        Returns\n        -------\n        list[tuple, tuple, tuple]\n            The set of tuples defining the camera position. In order, this is\n            the camera's position, the focal point, and the view up vector.\n\n        \"\"\"\n        pos = self.plotter.camera_position\n        # convert to list for serializability\n        return [list(pos[0]), list(pos[1]), list(pos[2])]\n\n    @camera_position.setter\n    def camera_position(self, camera_position: NDArray):\n        camera_position = np.array(camera_position).astype(float)\n        if camera_position.ndim == 1:\n            h, k, l = camera_position\n            camera_pos = self.get_camera_position_from_miller(h, k, l)\n            self.plotter.camera_position = camera_pos\n        else:\n            # convert to tuples\n            camera_position = [\n                tuple(camera_position[0]),\n                tuple(camera_position[1]),\n                tuple(camera_position[2]),\n            ]\n            self.plotter.camera_position = camera_position\n\n    @staticmethod\n    def get_edge_atom_fracs(frac_coord: NDArray, tol: float = 1e-08) -&gt; NDArray:\n        \"\"\"\n        Generates translationally equivalent atoms if coords are exactly on an edge\n        of the lattice\n\n        Parameters\n        ----------\n        frac_coord : NDArray\n            The fractiona coordinates of a single atom to wrap.\n        tol : float, optional\n            The tolerance in fractional coords to consider an atom on an edge\n            of the unit cell. The default is 1e-08.\n\n        Returns\n        -------\n        NDArray\n            The fractional coordinates of the atom wrapped at edges.\n\n        \"\"\"\n        transforms = [\n            [0, 1] if abs(x) &lt; tol else [0, -1] if abs(x - 1) &lt; tol else [0]\n            for x in frac_coord\n        ]\n\n        shifts = set(product(*transforms))\n        return [np.array(frac_coord) + np.array(shift) for shift in shifts]\n\n    def get_camera_position_from_miller(\n        self,\n        h: int,\n        k: int,\n        l: int,\n        rotation: float = 0,\n    ) -&gt; list[tuple, tuple, tuple]:\n        \"\"\"\n        Creates a camera position list from a list of miller indices.\n\n        Parameters\n        ----------\n        h : int\n            First miller index.\n        k : int\n            Second miller index.\n        l : int\n            Third miller index.\n        rotation: float\n            The rotation in degrees of the camera. The default of 0 will arrange\n            the camera as close to Z=1 as possible, or in the case that it this\n            is parallel, it will default to close to Y=1.\n\n        Returns\n        -------\n        list[tuple, tuple, tuple]\n            The set of tuples defining the camera position. In order, this is\n            the camera's position, the focal point, and the view up vector.\n\n        \"\"\"\n        # check for all 0s and adjust\n        if all([x == 0 for x in [h, k, l]]):\n            h, k, l = 1, 0, 0\n        # convert to vector perpendicular to the miller plane\n        view_direction = self.structure.get_cart_from_miller(h, k, l)\n        # Calculate a distance to the camera that doesn't clip any bodies. It's\n        # fine if this is very large as methods using this function should reset\n        # the camera after. We use half the sum of all lattice sides plus the largest\n        # atom radius as this should always be well outside the camera's range\n        camera_distance = sum(self.structure.lattice.lengths) + max(self.radii)\n\n        # Set focal point as center of lattice\n        matrix = self.structure.lattice.matrix\n        far_corner = np.sum(matrix, axis=0)\n        focal_point = far_corner / 2\n        # set the cameras position by adding the view direction to the focal point.\n        # The position is scaled by multiplying by the desired distance\n        camera_position = focal_point + view_direction * camera_distance\n\n        # Find an orthogonal vector that has the maximum z value. This is done\n        # using Gram-Schmidt orthogonalization.\n        z_axis = np.array([0, 0, 1])\n        view_up = z_axis - np.dot(z_axis, view_direction) * view_direction\n        norm_proj_z = np.linalg.norm(view_up)\n        if norm_proj_z &lt; 1e-14:\n            # fallback to y-axis if view direction is exactly perpendicular to\n            # the z direction\n            y_axis = np.array([0, 1, 0])\n            view_up = y_axis - np.dot(y_axis, view_direction) * view_direction\n\n        # Now we rotate the camera. We intentionally rotate counter clockwise to\n        # make the structure appear to rotate clockwise.\n        # convert degrees to radians\n        angle_rad = np.deg2rad(rotation)\n        view_up_rot = view_up * np.cos(angle_rad) + np.cross(\n            view_direction, view_up\n        ) * np.sin(angle_rad)\n        # return camera position\n        return [\n            tuple(camera_position),  # where the camera is\n            tuple(focal_point),  # where it's looking\n            tuple(view_up_rot),  # which direction is up\n        ]\n\n    def get_site_mesh(self, site_idx: int) -&gt; pv.PolyData:\n        \"\"\"\n        Generates a mesh for the provided site index.\n\n        Parameters\n        ----------\n        site_idx : int\n            The index of the atom to create the mesh for.\n\n        Returns\n        -------\n        pv.PolyData\n            A pyvista mesh representing an atom.\n\n        \"\"\"\n        site = self.structure[site_idx]\n        radius = self.radii[site_idx]\n        frac_coords = site.frac_coords\n        # wrap atom if on edge\n        if self._wrap_atoms:\n            all_frac_coords = self.get_edge_atom_fracs(frac_coords)\n        else:\n            all_frac_coords = [frac_coords]\n        # convert to cart coords\n        cart_coords = all_frac_coords @ self.structure.lattice.matrix\n        # generate meshes for each atom\n        spheres = []\n        for cart_coord in cart_coords:\n            spheres.append(\n                pv.Sphere(\n                    radius=radius * 0.3,\n                    center=cart_coord,\n                    theta_resolution=30,\n                    phi_resolution=30,\n                )\n            )\n        # merge all meshes\n        return pv.merge(spheres)\n\n    def get_all_site_meshes(self) -&gt; list[pv.PolyData]:\n        \"\"\"\n        Gets a list of pyvista meshes representing the atoms in the structure\n\n        Returns\n        -------\n        meshes : pv.PolyData\n            A list of pyvista meshes representing each atom.\n\n        \"\"\"\n        meshes = [self.get_site_mesh(i) for i in range(len(self.structure))]\n        return meshes\n\n    def get_lattice_mesh(self) -&gt; pv.PolyData:\n        \"\"\"\n        Generates the mesh representing the outline of the unit cell.\n\n        Returns\n        -------\n        pv.PolyData\n            A pyvista mesh representing the outline of the unit cell.\n\n        \"\"\"\n        # get the lattice matrix\n        a, b, c = self.structure.lattice.matrix\n        # get the corners of the matrix\n        corners = [np.array([0, 0, 0]), a, b, c, a + b, a + c, b + c, a + b + c]\n        # get the indices indicating edges of the lattice\n        edges = [\n            (0, 1),\n            (0, 2),\n            (0, 3),\n            (1, 4),\n            (1, 5),\n            (2, 4),\n            (2, 6),\n            (3, 5),\n            (3, 6),\n            (4, 7),\n            (5, 7),\n            (6, 7),\n        ]\n        # generate lines with pv\n        lines = []\n        for i, j in edges:\n            line = pv.Line(corners[i], corners[j])\n            lines.append(line)\n        # combine and return\n        return pv.merge(lines)\n\n    def _create_structure_plot(self) -&gt; pv.Plotter:\n        \"\"\"\n        Generates a pyvista.Plotter object from the current class variables.\n        This is called when the class is first instanced and generally shouldn't\n        be called again.\n\n        Returns\n        -------\n        plotter : pv.Plotter\n            A pyvista Plotter object representing the provided Structure object.\n\n        \"\"\"\n        if self.qt_plotter:\n            assert self.qt_frame is not None, \"A frame must be set to use qt\"\n            plotter = QtInteractor(self.qt_frame)\n        else:\n            plotter = pv.Plotter(off_screen=self.off_screen)\n        # set background\n        plotter.set_background(self.background)\n        # add atoms\n        atom_meshes = self.get_all_site_meshes()\n        for i, (site, atom_mesh, color) in enumerate(\n            zip(self.structure, atom_meshes, self.colors)\n        ):\n            actor = plotter.add_mesh(\n                atom_mesh,\n                color=color,\n                metallic=self.atom_metallicness,\n                pbr=True,  # enable physical based rendering\n                name=f\"{site.label}\",\n            )\n            if not i in self.visible_atoms:\n                actor.visibility = False\n\n        # add lattice if desired\n        lattice_mesh = self.get_lattice_mesh()\n        plotter.add_mesh(\n            lattice_mesh,\n            line_width=self.lattice_thickness,\n            color=\"k\",\n            name=\"lattice\",\n        )\n\n        # set camera perspective type\n        if self.parallel_projection:\n            plotter.renderer.enable_parallel_projection()\n\n        # reset camera to fit well\n        plotter.reset_camera()\n\n        return plotter\n\n    def show(self):\n        \"\"\"\n        Renders the plot to a window. After closing the window, a new instance\n        must be created to plot again. Pressing q pauses the rendering allowing\n        changes to be made without fully exiting.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        self.plotter.show(auto_close=False)\n\n    def update(self):\n        \"\"\"\n        Updates the pyvista plotter object when linked with a render window in\n        Trame. Generally this is not needed outside of Trame applications.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        self.plotter.update()\n\n    def rebuild(self) -&gt; pv.Plotter:\n        \"\"\"\n        Builds a new pyvista plotter object representing the current state of\n        the Plotter class.\n\n        Returns\n        -------\n        pv.Plotter\n            A pyvista Plotter object representing the current state of the\n            StructurePlotter class.\n\n        \"\"\"\n        return self._create_structure_plot()\n\n    def get_plot_html(self) -&gt; str:\n        \"\"\"\n        Creates an html string representing the current state of the StructurePlotter\n        class.\n\n        Returns\n        -------\n        str\n            The html string representing the current StructurePlotter class.\n\n        \"\"\"\n        if sys.platform == \"win32\":\n            # We can return the html directly without opening a subprocess. And\n            # we need to because the \"fork\" start method doesn't work\n            html_plotter = self.plotter.export_html(filename=None)\n            return html_plotter.read()\n        # BUG-FIX: On Linux and maybe MacOS, pyvista's export_html must be run\n        # as a main process. To do this within our streamlit apps, we use python's\n        # multiprocess to run the process as is done in [stpyvista](https://github.com/edsaac/stpyvista/blob/main/src/stpyvista/trame_backend.py)\n        queue = Queue(maxsize=1)\n        process = Process(target=_export_html, args=(queue, self.plotter))\n        process.start()\n        html_plotter = queue.get().read()\n        process.join()\n        return html_plotter\n\n    def get_plot_screenshot(\n        self,\n        filename: str | Path | io.BytesIO = None,\n        transparent_background: bool = None,\n        return_img: bool = True,\n        window_size: tuple[int, int] = None,\n        scale: int = None,\n    ) -&gt; NDArray[float]:\n        \"\"\"\n        Creates a screenshot of the current state of the StructurePlotter class.\n        This is a wraparound of pyvista's screenshot method\n\n        Parameters\n        ----------\n        filename: str | Path | io.BytesIO\n            Location to write image to. If None, no image is written.\n\n        transparent_background: bool\n            Whether to make the background transparent.\n            The default is looked up on the plotter\u2019s theme.\n\n        return_img: bool\n            If True, a numpy.ndarray of the image will be returned. Defaults to\n            True.\n\n        window_size: tuple[int, int]\n            Set the plotter\u2019s size to this (width, height) before taking the\n            screenshot.\n\n        scale: int\n            Set the factor to scale the window size to make a higher resolution image. If None this will use the image_scale property on this plotter which defaults to one.\n\n        Returns\n        -------\n        NDArray[float]\n            Array containing pixel RGB and alpha. Sized:\n\n            [Window height x Window width x 3] if transparent_background is set to False.\n\n            [Window height x Window width x 4] if transparent_background is set to True.\n\n        \"\"\"\n\n        if not self.qt_plotter:\n            plotter = self.rebuild()\n            plotter.camera = self.plotter.camera.copy()\n        else:\n            plotter = self.plotter\n\n        # enable off screen rendering momentarily\n        plotter.ren_win.SetOffScreenRendering(True)\n        screenshot = plotter.screenshot(\n            filename=filename,\n            transparent_background=transparent_background,\n            return_img=return_img,\n            window_size=window_size,\n            scale=scale,\n        )\n        plotter.ren_win.SetOffScreenRendering(False)\n        if not self.qt_plotter:\n            plotter.close()\n        return screenshot\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.atom_df","title":"<code>atom_df</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Name Type Description <code>atom_df</code> <code>TYPE</code> <p>A dataframe summarizing the properties of the atom meshes.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.atom_metallicness","title":"<code>atom_metallicness</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The amount of metallic character in the atom display.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.background","title":"<code>background</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The color of the plot background as a hex code.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.camera_position","title":"<code>camera_position</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>list[tuple, tuple, tuple]</code> <p>The set of tuples defining the camera position. In order, this is the camera's position, the focal point, and the view up vector.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.camera_rotation","title":"<code>camera_rotation</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The rotation of the camera from the default. The default is to set the camera so that the upwards view is as close to the z axis as possible, or the y axis if the view indices are perpendicular to z.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.colors","title":"<code>colors</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>list[str]</code> <p>The colors to use for each atom as hex codes.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.lattice_thickness","title":"<code>lattice_thickness</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The thickness of the lines outlining the unit cell.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.parallel_projection","title":"<code>parallel_projection</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>If True, a parallel projection scheme will be used rather than perspective.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.radii","title":"<code>radii</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>list[float]</code> <p>The radius to display for each atom in the structure. The actual displayed radius will be 0.3*radius.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.show_axes","title":"<code>show_axes</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to show the axis widget. Note this currently only displays the cartesian axes.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.show_lattice","title":"<code>show_lattice</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>bool</code> <p>Whether or not to display the outline of the unit cell.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.view_indices","title":"<code>view_indices</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>NDArray[int]</code> <p>The miller indices of the plane that the camera is perpendicular to.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.visible_atoms","title":"<code>visible_atoms</code>  <code>property</code> <code>writable</code>","text":"<p>Returns:</p> Type Description <code>list[int]</code> <p>A list of atom indices to display in the plot.</p>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.__init__","title":"<code>__init__(structure, off_screen=False, qt_plotter=False, qt_frame=None, **kwargs)</code>","text":"<p>A convenience class for creating plots of crystal structures using pyvista's package for VTK.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>The pymatgen Structure object to plot.</p> required <code>off_screen</code> <code>bool</code> <p>Whether or not the plotter should be in offline mode. The default is False.</p> <code>False</code> <code>qt_plotter</code> <code>bool</code> <p>Whether or not the plotter will use pyvistaqt for qt applications</p> <code>False</code> <code>qt_frame</code> <p>If using pyvistaqt, the QFrame to link the plotter to.</p> <code>None</code> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def __init__(\n    self,\n    structure: Structure,\n    off_screen: bool = False,\n    qt_plotter: bool = False,\n    qt_frame=None,\n    **kwargs,\n):\n    \"\"\"\n    A convenience class for creating plots of crystal structures using\n    pyvista's package for VTK.\n\n    Parameters\n    ----------\n    structure : Structure\n        The pymatgen Structure object to plot.\n    off_screen : bool, optional\n        Whether or not the plotter should be in offline mode. The default is False.\n    qt_plotter : bool, optional\n        Whether or not the plotter will use pyvistaqt for qt applications\n    qt_frame\n        If using pyvistaqt, the QFrame to link the plotter to.\n\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    # sort and relabel structure for consistency\n    structure = structure.copy()\n    structure.sort()\n    structure.relabel_sites()\n    # create initial class variables\n    self.structure = structure\n    self.off_screen = off_screen\n    self.qt_plotter = qt_plotter\n    self.qt_frame = qt_frame\n    self._visible_atoms = [i for i in range(len(self.structure))]\n    self._show_lattice = True\n    self._wrap_atoms = True\n    self._lattice_thickness = 0.1\n    self._atom_metallicness = 0.0\n    self._background = \"#FFFFFF\"\n    self._view_indices = [1, 0, 0]\n    self._camera_rotation = (0.0,)\n    self._show_axes = True\n    self._parallel_projection = True\n    self._radii = [s.specie.atomic_radius for s in structure]\n    self._colors = [ATOM_COLORS.get(s.specie.symbol, \"#FFFFFF\") for s in structure]\n    # generate initial plotter\n    self.plotter = self._create_structure_plot()\n    self.view_indices = [1, 0, 0]\n    self.up_indices = [0, 0, 1]\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_all_site_meshes","title":"<code>get_all_site_meshes()</code>","text":"<p>Gets a list of pyvista meshes representing the atoms in the structure</p> <p>Returns:</p> Name Type Description <code>meshes</code> <code>PolyData</code> <p>A list of pyvista meshes representing each atom.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_all_site_meshes(self) -&gt; list[pv.PolyData]:\n    \"\"\"\n    Gets a list of pyvista meshes representing the atoms in the structure\n\n    Returns\n    -------\n    meshes : pv.PolyData\n        A list of pyvista meshes representing each atom.\n\n    \"\"\"\n    meshes = [self.get_site_mesh(i) for i in range(len(self.structure))]\n    return meshes\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_camera_position_from_miller","title":"<code>get_camera_position_from_miller(h, k, l, rotation=0)</code>","text":"<p>Creates a camera position list from a list of miller indices.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>int</code> <p>First miller index.</p> required <code>k</code> <code>int</code> <p>Second miller index.</p> required <code>l</code> <code>int</code> <p>Third miller index.</p> required <code>rotation</code> <code>float</code> <p>The rotation in degrees of the camera. The default of 0 will arrange the camera as close to Z=1 as possible, or in the case that it this is parallel, it will default to close to Y=1.</p> <code>0</code> <p>Returns:</p> Type Description <code>list[tuple, tuple, tuple]</code> <p>The set of tuples defining the camera position. In order, this is the camera's position, the focal point, and the view up vector.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_camera_position_from_miller(\n    self,\n    h: int,\n    k: int,\n    l: int,\n    rotation: float = 0,\n) -&gt; list[tuple, tuple, tuple]:\n    \"\"\"\n    Creates a camera position list from a list of miller indices.\n\n    Parameters\n    ----------\n    h : int\n        First miller index.\n    k : int\n        Second miller index.\n    l : int\n        Third miller index.\n    rotation: float\n        The rotation in degrees of the camera. The default of 0 will arrange\n        the camera as close to Z=1 as possible, or in the case that it this\n        is parallel, it will default to close to Y=1.\n\n    Returns\n    -------\n    list[tuple, tuple, tuple]\n        The set of tuples defining the camera position. In order, this is\n        the camera's position, the focal point, and the view up vector.\n\n    \"\"\"\n    # check for all 0s and adjust\n    if all([x == 0 for x in [h, k, l]]):\n        h, k, l = 1, 0, 0\n    # convert to vector perpendicular to the miller plane\n    view_direction = self.structure.get_cart_from_miller(h, k, l)\n    # Calculate a distance to the camera that doesn't clip any bodies. It's\n    # fine if this is very large as methods using this function should reset\n    # the camera after. We use half the sum of all lattice sides plus the largest\n    # atom radius as this should always be well outside the camera's range\n    camera_distance = sum(self.structure.lattice.lengths) + max(self.radii)\n\n    # Set focal point as center of lattice\n    matrix = self.structure.lattice.matrix\n    far_corner = np.sum(matrix, axis=0)\n    focal_point = far_corner / 2\n    # set the cameras position by adding the view direction to the focal point.\n    # The position is scaled by multiplying by the desired distance\n    camera_position = focal_point + view_direction * camera_distance\n\n    # Find an orthogonal vector that has the maximum z value. This is done\n    # using Gram-Schmidt orthogonalization.\n    z_axis = np.array([0, 0, 1])\n    view_up = z_axis - np.dot(z_axis, view_direction) * view_direction\n    norm_proj_z = np.linalg.norm(view_up)\n    if norm_proj_z &lt; 1e-14:\n        # fallback to y-axis if view direction is exactly perpendicular to\n        # the z direction\n        y_axis = np.array([0, 1, 0])\n        view_up = y_axis - np.dot(y_axis, view_direction) * view_direction\n\n    # Now we rotate the camera. We intentionally rotate counter clockwise to\n    # make the structure appear to rotate clockwise.\n    # convert degrees to radians\n    angle_rad = np.deg2rad(rotation)\n    view_up_rot = view_up * np.cos(angle_rad) + np.cross(\n        view_direction, view_up\n    ) * np.sin(angle_rad)\n    # return camera position\n    return [\n        tuple(camera_position),  # where the camera is\n        tuple(focal_point),  # where it's looking\n        tuple(view_up_rot),  # which direction is up\n    ]\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_edge_atom_fracs","title":"<code>get_edge_atom_fracs(frac_coord, tol=1e-08)</code>  <code>staticmethod</code>","text":"<p>Generates translationally equivalent atoms if coords are exactly on an edge of the lattice</p> <p>Parameters:</p> Name Type Description Default <code>frac_coord</code> <code>NDArray</code> <p>The fractiona coordinates of a single atom to wrap.</p> required <code>tol</code> <code>float</code> <p>The tolerance in fractional coords to consider an atom on an edge of the unit cell. The default is 1e-08.</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>The fractional coordinates of the atom wrapped at edges.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>@staticmethod\ndef get_edge_atom_fracs(frac_coord: NDArray, tol: float = 1e-08) -&gt; NDArray:\n    \"\"\"\n    Generates translationally equivalent atoms if coords are exactly on an edge\n    of the lattice\n\n    Parameters\n    ----------\n    frac_coord : NDArray\n        The fractiona coordinates of a single atom to wrap.\n    tol : float, optional\n        The tolerance in fractional coords to consider an atom on an edge\n        of the unit cell. The default is 1e-08.\n\n    Returns\n    -------\n    NDArray\n        The fractional coordinates of the atom wrapped at edges.\n\n    \"\"\"\n    transforms = [\n        [0, 1] if abs(x) &lt; tol else [0, -1] if abs(x - 1) &lt; tol else [0]\n        for x in frac_coord\n    ]\n\n    shifts = set(product(*transforms))\n    return [np.array(frac_coord) + np.array(shift) for shift in shifts]\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_lattice_mesh","title":"<code>get_lattice_mesh()</code>","text":"<p>Generates the mesh representing the outline of the unit cell.</p> <p>Returns:</p> Type Description <code>PolyData</code> <p>A pyvista mesh representing the outline of the unit cell.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_lattice_mesh(self) -&gt; pv.PolyData:\n    \"\"\"\n    Generates the mesh representing the outline of the unit cell.\n\n    Returns\n    -------\n    pv.PolyData\n        A pyvista mesh representing the outline of the unit cell.\n\n    \"\"\"\n    # get the lattice matrix\n    a, b, c = self.structure.lattice.matrix\n    # get the corners of the matrix\n    corners = [np.array([0, 0, 0]), a, b, c, a + b, a + c, b + c, a + b + c]\n    # get the indices indicating edges of the lattice\n    edges = [\n        (0, 1),\n        (0, 2),\n        (0, 3),\n        (1, 4),\n        (1, 5),\n        (2, 4),\n        (2, 6),\n        (3, 5),\n        (3, 6),\n        (4, 7),\n        (5, 7),\n        (6, 7),\n    ]\n    # generate lines with pv\n    lines = []\n    for i, j in edges:\n        line = pv.Line(corners[i], corners[j])\n        lines.append(line)\n    # combine and return\n    return pv.merge(lines)\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_plot_html","title":"<code>get_plot_html()</code>","text":"<p>Creates an html string representing the current state of the StructurePlotter class.</p> <p>Returns:</p> Type Description <code>str</code> <p>The html string representing the current StructurePlotter class.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_plot_html(self) -&gt; str:\n    \"\"\"\n    Creates an html string representing the current state of the StructurePlotter\n    class.\n\n    Returns\n    -------\n    str\n        The html string representing the current StructurePlotter class.\n\n    \"\"\"\n    if sys.platform == \"win32\":\n        # We can return the html directly without opening a subprocess. And\n        # we need to because the \"fork\" start method doesn't work\n        html_plotter = self.plotter.export_html(filename=None)\n        return html_plotter.read()\n    # BUG-FIX: On Linux and maybe MacOS, pyvista's export_html must be run\n    # as a main process. To do this within our streamlit apps, we use python's\n    # multiprocess to run the process as is done in [stpyvista](https://github.com/edsaac/stpyvista/blob/main/src/stpyvista/trame_backend.py)\n    queue = Queue(maxsize=1)\n    process = Process(target=_export_html, args=(queue, self.plotter))\n    process.start()\n    html_plotter = queue.get().read()\n    process.join()\n    return html_plotter\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_plot_screenshot","title":"<code>get_plot_screenshot(filename=None, transparent_background=None, return_img=True, window_size=None, scale=None)</code>","text":"<p>Creates a screenshot of the current state of the StructurePlotter class. This is a wraparound of pyvista's screenshot method</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | Path | BytesIO</code> <p>Location to write image to. If None, no image is written.</p> <code>None</code> <code>transparent_background</code> <code>bool</code> <p>Whether to make the background transparent. The default is looked up on the plotter\u2019s theme.</p> <code>None</code> <code>return_img</code> <code>bool</code> <p>If True, a numpy.ndarray of the image will be returned. Defaults to True.</p> <code>True</code> <code>window_size</code> <code>tuple[int, int]</code> <p>Set the plotter\u2019s size to this (width, height) before taking the screenshot.</p> <code>None</code> <code>scale</code> <code>int</code> <p>Set the factor to scale the window size to make a higher resolution image. If None this will use the image_scale property on this plotter which defaults to one.</p> <code>None</code> <p>Returns:</p> Type Description <code>NDArray[float]</code> <p>Array containing pixel RGB and alpha. Sized:</p> <p>[Window height x Window width x 3] if transparent_background is set to False.</p> <p>[Window height x Window width x 4] if transparent_background is set to True.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_plot_screenshot(\n    self,\n    filename: str | Path | io.BytesIO = None,\n    transparent_background: bool = None,\n    return_img: bool = True,\n    window_size: tuple[int, int] = None,\n    scale: int = None,\n) -&gt; NDArray[float]:\n    \"\"\"\n    Creates a screenshot of the current state of the StructurePlotter class.\n    This is a wraparound of pyvista's screenshot method\n\n    Parameters\n    ----------\n    filename: str | Path | io.BytesIO\n        Location to write image to. If None, no image is written.\n\n    transparent_background: bool\n        Whether to make the background transparent.\n        The default is looked up on the plotter\u2019s theme.\n\n    return_img: bool\n        If True, a numpy.ndarray of the image will be returned. Defaults to\n        True.\n\n    window_size: tuple[int, int]\n        Set the plotter\u2019s size to this (width, height) before taking the\n        screenshot.\n\n    scale: int\n        Set the factor to scale the window size to make a higher resolution image. If None this will use the image_scale property on this plotter which defaults to one.\n\n    Returns\n    -------\n    NDArray[float]\n        Array containing pixel RGB and alpha. Sized:\n\n        [Window height x Window width x 3] if transparent_background is set to False.\n\n        [Window height x Window width x 4] if transparent_background is set to True.\n\n    \"\"\"\n\n    if not self.qt_plotter:\n        plotter = self.rebuild()\n        plotter.camera = self.plotter.camera.copy()\n    else:\n        plotter = self.plotter\n\n    # enable off screen rendering momentarily\n    plotter.ren_win.SetOffScreenRendering(True)\n    screenshot = plotter.screenshot(\n        filename=filename,\n        transparent_background=transparent_background,\n        return_img=return_img,\n        window_size=window_size,\n        scale=scale,\n    )\n    plotter.ren_win.SetOffScreenRendering(False)\n    if not self.qt_plotter:\n        plotter.close()\n    return screenshot\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.get_site_mesh","title":"<code>get_site_mesh(site_idx)</code>","text":"<p>Generates a mesh for the provided site index.</p> <p>Parameters:</p> Name Type Description Default <code>site_idx</code> <code>int</code> <p>The index of the atom to create the mesh for.</p> required <p>Returns:</p> Type Description <code>PolyData</code> <p>A pyvista mesh representing an atom.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def get_site_mesh(self, site_idx: int) -&gt; pv.PolyData:\n    \"\"\"\n    Generates a mesh for the provided site index.\n\n    Parameters\n    ----------\n    site_idx : int\n        The index of the atom to create the mesh for.\n\n    Returns\n    -------\n    pv.PolyData\n        A pyvista mesh representing an atom.\n\n    \"\"\"\n    site = self.structure[site_idx]\n    radius = self.radii[site_idx]\n    frac_coords = site.frac_coords\n    # wrap atom if on edge\n    if self._wrap_atoms:\n        all_frac_coords = self.get_edge_atom_fracs(frac_coords)\n    else:\n        all_frac_coords = [frac_coords]\n    # convert to cart coords\n    cart_coords = all_frac_coords @ self.structure.lattice.matrix\n    # generate meshes for each atom\n    spheres = []\n    for cart_coord in cart_coords:\n        spheres.append(\n            pv.Sphere(\n                radius=radius * 0.3,\n                center=cart_coord,\n                theta_resolution=30,\n                phi_resolution=30,\n            )\n        )\n    # merge all meshes\n    return pv.merge(spheres)\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.rebuild","title":"<code>rebuild()</code>","text":"<p>Builds a new pyvista plotter object representing the current state of the Plotter class.</p> <p>Returns:</p> Type Description <code>Plotter</code> <p>A pyvista Plotter object representing the current state of the StructurePlotter class.</p> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def rebuild(self) -&gt; pv.Plotter:\n    \"\"\"\n    Builds a new pyvista plotter object representing the current state of\n    the Plotter class.\n\n    Returns\n    -------\n    pv.Plotter\n        A pyvista Plotter object representing the current state of the\n        StructurePlotter class.\n\n    \"\"\"\n    return self._create_structure_plot()\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.show","title":"<code>show()</code>","text":"<p>Renders the plot to a window. After closing the window, a new instance must be created to plot again. Pressing q pauses the rendering allowing changes to be made without fully exiting.</p> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def show(self):\n    \"\"\"\n    Renders the plot to a window. After closing the window, a new instance\n    must be created to plot again. Pressing q pauses the rendering allowing\n    changes to be made without fully exiting.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    self.plotter.show(auto_close=False)\n</code></pre>"},{"location":"api_reference/plotting/structure/#src.baderkit.plotting.core.plotter.StructurePlotter.update","title":"<code>update()</code>","text":"<p>Updates the pyvista plotter object when linked with a render window in Trame. Generally this is not needed outside of Trame applications.</p> <p>Returns:</p> Type Description <code>None.</code> Source code in <code>src/baderkit/plotting/core/plotter.py</code> <pre><code>def update(self):\n    \"\"\"\n    Updates the pyvista plotter object when linked with a render window in\n    Trame. Generally this is not needed outside of Trame applications.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    self.plotter.update()\n</code></pre>"},{"location":"example_scripts/custom_file_formats/","title":"Custom Data Formats","text":"<p>BaderKit only provides convenience functions for loading VASP <code>CHGCAR</code>-like files or Gaussian <code>cube</code>-like files. However, as long as you can read in your charge density into a NumPy array, you can still use BaderKit by constructing the <code>Structure</code>,  <code>Grid</code>, and <code>Bader</code> classes manually.</p> <pre><code># import \nfrom baderkit.core import Bader, Grid, Structure\nimport numpy as np\n\n# Create a PyMatGen Structure object. This is usually easiest to do from a\n# file, but can also be made manually.\nstructure = Structure.from_file(filename = \"mystructure.cif\", fmt = \"cif\")\n\n# Load your data, however you can, into a numpy array.\ncharge_data = np.array([\n[[1,2,3],[3,4,5],[6,7,8]],\n[[1,2,3],[3,4,5],[6,7,8]],\n[[1,2,3],[3,4,5],[6,7,8]],\n])\n\n# Create a data dictionary\ndata = {\"total\": charge_data}\n\n# create Grid objects for the charge-density (and reference file if needed)\ncharge_grid = Grid(structure=structure, data=data)\n\n# Create the Bader object\nbader = Bader(charge_grid = charge_grid)\n</code></pre> <p>Warning</p> <p>The charge density data must follow VASP's conventions, i.e. it should be stored as </p> <p>data(r) = n(r) x V<sub>grid</sub> x V<sub>cell</sub></p> <p>where</p> <ul> <li>n(r) = charge density in 1/Ang at point r</li> <li>V<sub>grid</sub> = the total number of grid points</li> <li>V<sub>cell</sub> = the volume of the simulation cell</li> </ul> <p>See VASP's wiki for more details.</p>"},{"location":"example_scripts/spin_polarized_calculations/","title":"Spin Separated Calculations","text":"<p>BaderKit runs on whatever set of data is stored in the <code>total</code> property of the <code>Grid</code> class. By default, this data is read from the first set of data in a <code>CHGCAR</code> or <code>cube</code> format file. This typically represents the total charge density of both the spin-up and spin-down electrons.</p> <p>In VASP, spin polarized calculations will also write an additional set of data representing the difference between the spin-up and spin-down charge densities. When read from file, this data is stored in the <code>diff</code> property of the <code>Grid</code> class.</p> <p>Assuming we have run a spin-polarized calculation with VASP, we can run the Bader analysis on the separate spin-up and spin-down systems by creating two <code>Grid</code> and <code>Bader</code> class objects with the appropriate charge densities in the <code>total</code> property.</p> Command LinePython <ol> <li> <p>Split your file using the provided helper command. Replace 'chargefile' with your actual file path.</p> <pre><code>baderkit split chargefile\n</code></pre> </li> <li> <p>Run the bader analysis on the spin up system and copy it to avoid overwriting.</p> <pre><code>baderkit run chargefile_up\nmv bader_atom_summary.tsv bader_atom_summary_up.tsv\nmv bader_basin_summary.tsv bader_basin_summary_up.tsv\n</code></pre> </li> <li> <p>Run the bader analysis on the spin down system.</p> <pre><code>baderkit run chargefile_down\nmv bader_atom_summary.tsv bader_atom_summary_down.tsv\nmv bader_basin_summary.tsv bader_basin_summary_down.tsv\n</code></pre> </li> </ol> <pre><code># import \nfrom baderkit.core import Bader, Grid\n\n# load the spin polarized charge grid. Make sure the `total_only` tag is set to\n# false to indicate that we want to load all sets of data.\npolarized_grid = Grid.from_vasp(\"CHGCAR\", total_only=False)\n\n# split the polarized grid to the spin up and spin down components\ngrid_up, grid_down = polarized_grid.split_to_spin()\n\n# create our Bader classes\nbader_up = Bader(grid_up)\nbader_down = Bader(grid_down)\n\n# get results\nresults_up = bader_up.results_summary\nresults_down = bader_down.results_summary\n</code></pre> <p>Tip</p> <p>This analysis can be run on results from softwares other than VASP as well. Either set up the <code>polarized_grid</code> so that it follows VASP's <code>total</code> and <code>diff</code> format, or load/create the <code>grid_up</code> and <code>grid_down</code> from already split data.</p> <p>Warning</p> <p>This example does not use the core + valence charge density as we suggest in our warning. This is because VASP does not write spin separated <code>AECCAR0</code> or <code>AECCAR2</code> files. You can still use the <code>CHGCAR_sum</code> as a reference, but the bader basins will be defined by the total charge density, not the spin-polarized ones.</p>"}]}